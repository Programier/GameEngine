SLANG_RAW("// TODO: These keywords are not recognized but they should be.\n")
SLANG_RAW("#define highp\n")
SLANG_RAW("#define mediump\n")
SLANG_RAW("#define lowp\n")
SLANG_RAW("\n")
SLANG_RAW("#define VECTOR_MAP_UNARY(TYPE, COUNT, FUNC, VALUE) \\\n")
SLANG_RAW("    vector<TYPE,COUNT> result; for(int i = 0; i < COUNT; ++i) { result[i] = FUNC(VALUE[i]); } return result\n")
SLANG_RAW("\n")
SLANG_RAW("#define VECTOR_MAP_TRINARY(TYPE, COUNT, FUNC, A, B, C) \\\n")
SLANG_RAW("    vector<TYPE,COUNT> result; for(int i = 0; i < COUNT; ++i) { result[i] = FUNC(A[i], B[i], C[i]); } return result\n")
SLANG_RAW("\n")
SLANG_RAW("#define REQUIRE_KHRONOS [require(glsl)] [require(spirv)]\n")
SLANG_RAW("\n")
SLANG_RAW("//\n")
SLANG_RAW("// OpenGL 4.60 spec\n")
SLANG_RAW("//\n")
SLANG_RAW("\n")
SLANG_RAW("//\n")
SLANG_RAW("// Section 4.1. 'asic Types'\n")
SLANG_RAW("//\n")
SLANG_RAW("\n")
SLANG_RAW("public typealias vec2 = vector<float, 2>;\n")
SLANG_RAW("public typealias vec3 = vector<float, 3>;\n")
SLANG_RAW("public typealias vec4 = vector<float, 4>;\n")
SLANG_RAW("\n")
SLANG_RAW("public typealias dvec2 = vector<double, 2>;\n")
SLANG_RAW("public typealias dvec3 = vector<double, 3>;\n")
SLANG_RAW("public typealias dvec4 = vector<double, 4>;\n")
SLANG_RAW("\n")
SLANG_RAW("public typealias bvec2 = vector<bool, 2>;\n")
SLANG_RAW("public typealias bvec3 = vector<bool, 3>;\n")
SLANG_RAW("public typealias bvec4 = vector<bool, 4>;\n")
SLANG_RAW("\n")
SLANG_RAW("public typealias ivec2 = vector<int, 2>;\n")
SLANG_RAW("public typealias ivec3 = vector<int, 3>;\n")
SLANG_RAW("public typealias ivec4 = vector<int, 4>;\n")
SLANG_RAW("\n")
SLANG_RAW("public typealias uvec2 = vector<uint, 2>;\n")
SLANG_RAW("public typealias uvec3 = vector<uint, 3>;\n")
SLANG_RAW("public typealias uvec4 = vector<uint, 4>;\n")
SLANG_RAW("\n")
SLANG_RAW("public typealias i8vec2 = vector<int8_t, 2>;\n")
SLANG_RAW("public typealias i8vec3 = vector<int8_t, 3>;\n")
SLANG_RAW("public typealias i8vec4 = vector<int8_t, 4>;\n")
SLANG_RAW("\n")
SLANG_RAW("public typealias u8vec2 = vector<uint8_t, 2>;\n")
SLANG_RAW("public typealias u8vec3 = vector<uint8_t, 3>;\n")
SLANG_RAW("public typealias u8vec4 = vector<uint8_t, 4>;\n")
SLANG_RAW("\n")
SLANG_RAW("public typealias i16vec2 = vector<int16_t, 2>;\n")
SLANG_RAW("public typealias i16vec3 = vector<int16_t, 3>;\n")
SLANG_RAW("public typealias i16vec4 = vector<int16_t, 4>;\n")
SLANG_RAW("\n")
SLANG_RAW("public typealias u16vec2 = vector<uint16_t, 2>;\n")
SLANG_RAW("public typealias u16vec3 = vector<uint16_t, 3>;\n")
SLANG_RAW("public typealias u16vec4 = vector<uint16_t, 4>;\n")
SLANG_RAW("\n")
SLANG_RAW("public typealias i64vec2 = vector<int64_t, 2>;\n")
SLANG_RAW("public typealias i64vec3 = vector<int64_t, 3>;\n")
SLANG_RAW("public typealias i64vec4 = vector<int64_t, 4>;\n")
SLANG_RAW("\n")
SLANG_RAW("public typealias u64vec2 = vector<uint64_t, 2>;\n")
SLANG_RAW("public typealias u64vec3 = vector<uint64_t, 3>;\n")
SLANG_RAW("public typealias u64vec4 = vector<uint64_t, 4>;\n")
SLANG_RAW("\n")
SLANG_RAW("public typealias mat2 = matrix<float, 2, 2>;\n")
SLANG_RAW("public typealias mat3 = matrix<float, 3, 3>;\n")
SLANG_RAW("public typealias mat4 = matrix<float, 4, 4>;\n")
SLANG_RAW("\n")
SLANG_RAW("public typealias mat2x2 = matrix<float, 2, 2>;\n")
SLANG_RAW("public typealias mat2x3 = matrix<float, 3, 2>;\n")
SLANG_RAW("public typealias mat2x4 = matrix<float, 4, 2>;\n")
SLANG_RAW("\n")
SLANG_RAW("public typealias mat3x2 = matrix<float, 2, 3>;\n")
SLANG_RAW("public typealias mat3x3 = matrix<float, 3, 3>;\n")
SLANG_RAW("public typealias mat3x4 = matrix<float, 4, 3>;\n")
SLANG_RAW("\n")
SLANG_RAW("public typealias mat4x2 = matrix<float, 2, 4>;\n")
SLANG_RAW("public typealias mat4x3 = matrix<float, 3, 4>;\n")
SLANG_RAW("public typealias mat4x4 = matrix<float, 4, 4>;\n")
SLANG_RAW("\n")
SLANG_RAW("public typealias dmat2 = matrix<double, 2, 2>;\n")
SLANG_RAW("public typealias dmat3 = matrix<double, 3, 3>;\n")
SLANG_RAW("public typealias dmat4 = matrix<double, 4, 4>;\n")
SLANG_RAW("\n")
SLANG_RAW("public typealias dmat2x2 = matrix<double, 2, 2>;\n")
SLANG_RAW("public typealias dmat2x3 = matrix<double, 3, 2>;\n")
SLANG_RAW("public typealias dmat2x4 = matrix<double, 4, 2>;\n")
SLANG_RAW("\n")
SLANG_RAW("public typealias dmat3x2 = matrix<double, 2, 3>;\n")
SLANG_RAW("public typealias dmat3x3 = matrix<double, 3, 3>;\n")
SLANG_RAW("public typealias dmat3x4 = matrix<double, 4, 3>;\n")
SLANG_RAW("\n")
SLANG_RAW("public typealias dmat4x2 = matrix<double, 2, 4>;\n")
SLANG_RAW("public typealias dmat4x3 = matrix<double, 3, 4>;\n")
SLANG_RAW("public typealias dmat4x4 = matrix<double, 4, 4>;\n")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("public out float4 gl_Position : SV_Position;\n")
SLANG_RAW("public out float gl_PointSize : SV_PointSize;\n")
SLANG_RAW("public in vec4 gl_FragCoord : SV_Position;\n")
SLANG_RAW("public out float gl_FragDepth : SV_Depth;\n")
SLANG_RAW("public out int gl_FragStencilRef : SV_StencilRef;\n")
SLANG_RAW("\n")
SLANG_RAW("public in uvec3 gl_GlobalInvocationID : SV_DispatchThreadID;\n")
SLANG_RAW("public in uvec3 gl_WorkGroupID : SV_GroupID;\n")
SLANG_RAW("public in uvec3 gl_LocalInvocationIndex : SV_GroupIndex;\n")
SLANG_RAW("public in uvec3 gl_LocalInvocationID : SV_GroupThreadID;\n")
SLANG_RAW("\n")
SLANG_RAW("// TODO: define overload for tessellation control stage.\n")
SLANG_RAW("public in int gl_InvocationID : SV_GSInstanceID;\n")
SLANG_RAW("\n")
SLANG_RAW("public in int gl_InstanceIndex : SV_InstanceID;\n")
SLANG_RAW("public in bool gl_FrontFacing : SV_IsFrontFace;\n")
SLANG_RAW("\n")
SLANG_RAW("// TODO: define overload for geometry stage.\n")
SLANG_RAW("public in int gl_Layer : SV_RenderTargetArrayIndex;\n")
SLANG_RAW("\n")
SLANG_RAW("public in int gl_SampleID : SV_SampleIndex;\n")
SLANG_RAW("public in int gl_VertexIndex : SV_VertexID;\n")
SLANG_RAW("public in int gl_ViewIndex : SV_ViewID;\n")
SLANG_RAW("public in int gl_ViewportIndex : SV_ViewportArrayIndex;\n")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("// Override operator* behavior to compute algebric product of matrices and vectors.\n")
SLANG_RAW("\n")
SLANG_RAW("[OverloadRank(15)]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public matrix<float, N, N> operator*<let N:int>(matrix<float, N, N> m1, matrix<float, N, N> m2)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return mul(m2, m1);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[OverloadRank(15)]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public matrix<half, N, N> operator*<let N:int>(matrix<half, N, N> m1, matrix<half, N, N> m2)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return mul(m2, m1);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[OverloadRank(15)]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public matrix<double, N, N> operator*<let N:int>(matrix<double, N, N> m1, matrix<double, N, N> m2)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return mul(m2, m1);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("[OverloadRank(15)]\n")
SLANG_RAW("public matrix<T, R, L> operator*<T:__BuiltinFloatingPointType, let L : int, let C : int, let R : int>(matrix<T, C, L> m1, matrix<T, R, C> m2)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return mul(m2, m1);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("[OverloadRank(15)]\n")
SLANG_RAW("public vector<T, R> operator*<T:__BuiltinFloatingPointType, let C : int, let R : int>(vector<T, C> v, matrix<T, R, C> m)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return mul(m, v);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("[OverloadRank(15)]\n")
SLANG_RAW("public vector<T, C> operator*<T:__BuiltinFloatingPointType, let C : int, let R : int>(matrix<T, R, C> m, vector<T, R> v)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return mul(v, m);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__intrinsic_op(mul)\n")
SLANG_RAW("public matrix<T, N, M> matrixCompMult<T:__BuiltinFloatingPointType, let N:int, let M : int>(matrix<T,N,M> left, matrix<T,N,M> right);\n")
SLANG_RAW("\n")
SLANG_RAW("__intrinsic_op(cmpLE)\n")
SLANG_RAW("public vector<bool, N> lessThanEqual<T, let N:int>(vector<T, N> x, vector<T, N> y);\n")
SLANG_RAW("__intrinsic_op(cmpLT)\n")
SLANG_RAW("public vector<bool, N> lessThan<T, let N:int>(vector<T, N> x, vector<T, N> y);\n")
SLANG_RAW("__intrinsic_op(cmpGT)\n")
SLANG_RAW("public vector<bool, N> greaterThan<T, let N:int>(vector<T, N> x, vector<T, N> y);\n")
SLANG_RAW("__intrinsic_op(cmpGE)\n")
SLANG_RAW("public vector<bool, N> greaterThanEqual<T, let N:int>(vector<T, N> x, vector<T, N> y);\n")
SLANG_RAW("__intrinsic_op(cmpEQ)\n")
SLANG_RAW("public vector<bool, N> equal<T, let N:int>(vector<T, N> x, vector<T, N> y);\n")
SLANG_RAW("__intrinsic_op(cmpNE)\n")
SLANG_RAW("public vector<bool, N> notEqual<T, let N:int>(vector<T, N> x, vector<T, N> y);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T>\n")
SLANG_RAW("public extension vector<T, 2>\n")
SLANG_RAW("{\n")
SLANG_RAW("    [ForceInline] public __init(vector<T, 3> bigger) { this = bigger.xy; }\n")
SLANG_RAW("    [ForceInline] public __init(vector<T, 4> bigger) { this = bigger.xy; }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T>\n")
SLANG_RAW("public extension vector<T, 3>\n")
SLANG_RAW("{\n")
SLANG_RAW("    [ForceInline] public __init(vector<T, 4> bigger) { this = bigger.xyz; }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("[OverloadRank(15)]\n")
SLANG_RAW("public bool operator==<T:__BuiltinArithmeticType, let N:int>(vector<T, N> left, vector<T, N> right)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return all(equal(left, right));\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("[OverloadRank(15)]\n")
SLANG_RAW("public bool operator!=<T:__BuiltinArithmeticType, let N:int>(vector<T, N> left, vector<T, N> right)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return any(notEqual(left, right));\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("[OverloadRank(14)]\n")
SLANG_RAW("public bool operator==<T:__BuiltinFloatingPointType, let N:int>(vector<T, N> left, vector<T, N> right)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return all(equal(left, right));\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("[OverloadRank(14)]\n")
SLANG_RAW("public bool operator!=<T:__BuiltinFloatingPointType, let N:int>(vector<T, N> left, vector<T, N> right)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return any(notEqual(left, right));\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("[OverloadRank(14)]\n")
SLANG_RAW("public bool operator==<T:__BuiltinLogicalType, let N:int>(vector<T, N> left, vector<T, N> right)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return all(equal(left, right));\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("[OverloadRank(14)]\n")
SLANG_RAW("public bool operator!=<T:__BuiltinLogicalType, let N:int>(vector<T, N> left, vector<T, N> right)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return any(notEqual(left, right));\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")

for (auto type : kBaseTypes) {
    char const* typeName = type.name;
    if (!type.flags) continue;
SLANG_RAW("#line 244 \"glsl.meta.slang\"")
SLANG_RAW("\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("[OverloadRank(15)]\n")
SLANG_RAW("public bool operator==<let N:int>(vector<")
SLANG_SPLICE(typeName
)
SLANG_RAW(", N> left, vector<")
SLANG_SPLICE(typeName
)
SLANG_RAW(", N> right)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return all(equal(left, right));\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("[OverloadRank(15)]\n")
SLANG_RAW("public bool operator!=<let N:int>(vector<")
SLANG_SPLICE(typeName
)
SLANG_RAW(", N> left, vector<")
SLANG_SPLICE(typeName
)
SLANG_RAW(", N> right)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return any(notEqual(left, right));\n")
SLANG_RAW("}\n")

}
SLANG_RAW("#line 260 \"glsl.meta.slang\"")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("//\n")
SLANG_RAW("// Section 8.1. Angle and Trigonometry Functions\n")
SLANG_RAW("//\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType>\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public T atan(T y, T x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return atan2(y, x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N:int>\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<T,N> atan(vector<T,N> y, vector<T,N> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return atan2(y, x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType>\n")
SLANG_RAW("__target_intrinsic(cuda, \"$P_asinh($0)\")\n")
SLANG_RAW("__target_intrinsic(cpp, \"$P_asinh($0)\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public T asinh(T x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return log(x + sqrt(x * x + T(1)));\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N:int>\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<T,N> asinh(vector<T,N> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    VECTOR_MAP_UNARY(T, N, asinh, x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType>\n")
SLANG_RAW("__target_intrinsic(cuda, \"$P_acosh($0)\")\n")
SLANG_RAW("__target_intrinsic(cpp, \"$P_acosh($0)\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public T acosh(T x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return log(x + sqrt( x * x - T(1)));\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N:int>\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<T,N> acosh(vector<T,N> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    VECTOR_MAP_UNARY(T, N, acosh, x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType>\n")
SLANG_RAW("__target_intrinsic(cuda, \"$P_atanh($0)\")\n")
SLANG_RAW("__target_intrinsic(cpp, \"$P_atanh($0)\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public T atanh(T x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return T(0.5) * log((T(1) + x) / (T(1) - x));\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N:int>\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<T,N> atanh(vector<T,N> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    VECTOR_MAP_UNARY(T, N, atanh, x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("//\n")
SLANG_RAW("// Section 8.2. Exponential Functions\n")
SLANG_RAW("//\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType>\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public T inversesqrt(T x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return rsqrt(x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N:int>\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<T, N> inversesqrt(vector<T, N> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return rsqrt(x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("//\n")
SLANG_RAW("// Section 8.3. Common Functions\n")
SLANG_RAW("//\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType>\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public T roundEven(T x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    T i;\n")
SLANG_RAW("    if (T(0.5) <= fmod(x, i))\n")
SLANG_RAW("    {\n")
SLANG_RAW("        bool evenInteger = (fmod(i, T(2)) == T(0));\n")
SLANG_RAW("        if (!evenInteger)\n")
SLANG_RAW("        {\n")
SLANG_RAW("            x += T(0.1);\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("    return round(x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N:int>\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<T,N> roundEven(vector<T,N> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    VECTOR_MAP_UNARY(T, N, roundEven, x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType>\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public T fract(T x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return frac(x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N:int>\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<T, N> fract(vector<T, N> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return frac(x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType>\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public T mod(T x, T y)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return fmod(x, y);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N:int>\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<T, N> mod(vector<T, N> x, T y)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return fmod(x, vector<T, N>(y));\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N:int>\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<T, N> mod(vector<T, N> x, vector<T, N> y)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return fmod(x, y);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType>\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public T mix(T x, T y, T a)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return lerp(x, y, a);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N:int>\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<T, N> mix(vector<T, N> x, vector<T, N> y, T a)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return lerp(x, y, vector<T, N>(a));\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N:int>\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<T, N> mix(vector<T, N> x, vector<T, N> y, vector<T, N> a)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return lerp(x, y, a);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T>\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public T mix(T x, T y, bool a)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return (a ? y : x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T, let N:int>\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<T, N> mix(vector<T, N> x, vector<T, N> y, vector<bool, N> a)\n")
SLANG_RAW("{\n")
SLANG_RAW("    vector<T, N> result;\n")
SLANG_RAW("    for (int i = 0; i < N; i++)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        result[i] = (a[i] ? y[i] : x[i]);\n")
SLANG_RAW("    }\n")
SLANG_RAW("    return result;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public int floatBitsToInt(highp float x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return asint(x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<let N:int>\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<int, N> floatBitsToInt(highp vector<float, N> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return asint(x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public uint floatBitsToUint(highp float x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return asuint(x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<let N:int>\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<uint, N> floatBitsToUint(highp vector<float, N> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return asuint(x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public float intBitsToFloat(highp int x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return asfloat(x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<let N:int>\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<float, N> intBitsToFloat(highp vector<int, N> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return asfloat(x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public float uintBitsToFloat(highp uint x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return asfloat(x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<let N:int>\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<float, N> uintBitsToFloat(highp vector<uint, N> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return asfloat(x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("//\n")
SLANG_RAW("// Section 8.4. Floating-Point Pack and Unpack Functions\n")
SLANG_RAW("//\n")
SLANG_RAW("\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("uint packUnorm1x16(float c)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return uint(clamp(c, 0.0, 1.0) * 65535.0 + 0.5);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("uint packSnorm1x16(float v)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return uint(clamp(v ,-1.0, 1.0) * 32767.0 + 32767.5);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("uint packUnorm1x8(float c)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return uint(clamp(c, 0.0, 1.0) * 255.0 + 0.5);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("uint packSnorm1x8(float c)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return uint(clamp(c, -1.0, 1.0) * 127.0 + 127.5);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("float unpackUnorm1x16(uint p)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return float(p) / 65535.0;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("float unpackSnorm1x16(uint p)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return clamp((float(p) - 32767.0) / 32767.0, -1.0, 1.0);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("float unpackUnorm1x8(uint p)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return float(p) / 255.0;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("float unpackSnorm1x8(uint p)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return clamp((float(p) - 127.0) / 127.0, -1.0, 1.0);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("uint float2half(float f)\n")
SLANG_RAW("{\n")
SLANG_RAW("    uint u = floatBitsToUint(f);\n")
SLANG_RAW("    uint s = ((u >> uint(16)) & uint(0x8000));\n")
SLANG_RAW("    uint e = 0;\n")
SLANG_RAW("    uint m = ((u >> uint(13)) & uint(0x03ff));\n")
SLANG_RAW("    if (m != 0)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        e = ((((u & uint(0x7f800000)) - uint(0x38000000)) >> uint(13)) & uint(0x7c00));\n")
SLANG_RAW("    }\n")
SLANG_RAW("    return (s | e | m);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public uint packUnorm2x16(vec2 v)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return packUnorm1x16(v.x) | (packUnorm1x16(v.y) << uint(16));\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public uint packSnorm2x16(vec2 v)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return packSnorm1x16(v.x) | (packSnorm1x16(v.y) << uint(16));\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public uint packUnorm4x8(vec4 v)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return packUnorm1x8(v.x) | (packUnorm1x8(v.y) << uint(8)) | (packUnorm1x8(v.z) << uint(16)) | (packUnorm1x8(v.w) << uint(24));\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public uint packSnorm4x8(vec4 v)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return packSnorm1x8(v.x) | (packSnorm1x8(v.y) << uint(8)) | (packSnorm1x8(v.z) << uint(16)) | (packSnorm1x8(v.w) << uint(24));\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vec2 unpackUnorm2x16(uint p)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return vec2(unpackUnorm1x16(p & uint(0xffff)), unpackUnorm1x16(p >> uint(16)));\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vec2 unpackSnorm2x16(uint p)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return vec2(unpackSnorm1x16(p & uint(0xffff)), unpackSnorm1x16(p >> uint(16)));\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vec4 unpackUnorm4x8(highp uint p)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return vec4(unpackUnorm1x8(p & uint(0xffff)), unpackUnorm1x8(p >> uint(8)), unpackUnorm1x8(p >> uint(16)), unpackUnorm1x8(p >> uint(24)));\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vec4 unpackSnorm4x8(highp uint p)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return vec4(unpackSnorm1x8(p & uint(0xffff)), unpackSnorm1x8(p >> uint(8)), unpackSnorm1x8(p >> uint(16)), unpackSnorm1x8(p >> uint(24)));\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public uint packHalf2x16(vec2 v)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return float2half(v.x) | (float2half(v.y) << uint(16));\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public float half2float(uint h)\n")
SLANG_RAW("{\n")
SLANG_RAW("    uint s = ((h & uint(0x8000)) << uint(16));\n")
SLANG_RAW("    uint e = 0;\n")
SLANG_RAW("    uint m = ((h & uint(0x03ff)) << uint(13));\n")
SLANG_RAW("    if (m != 0)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        e = (((h & uint(0x7c00)) + uint(0x1c000)) << uint(13));\n")
SLANG_RAW("    }\n")
SLANG_RAW("    return uintBitsToFloat(s | e | m); \n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vec2 unpackHalf2x16(uint p)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return vec2(half2float(p & uint(0xffff)), half2float(p >> uint(16)));\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public double packDouble2x32(uvec2 v)\n")
SLANG_RAW("{\n")
SLANG_RAW("    // TODO: there is no \"asdouble()\"\n")
SLANG_RAW("    //return asdouble(uint64_t(v.x) | (uint64_t(v.y) << 32));\n")
SLANG_RAW("    return 0.0;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public uvec2 unpackDouble2x32(double v)\n")
SLANG_RAW("{\n")
SLANG_RAW("    // TODO: there is no \"asuint64()\"\n")
SLANG_RAW("    uint64_t u = 0; // asuint64(v);\n")
SLANG_RAW("    return uvec2(uint(u & 0xFFFFFFFF), uint(u >> 32));\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("//\n")
SLANG_RAW("// Section 8.5. Geometric Functions\n")
SLANG_RAW("//\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType>\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public T faceforward(T n, T i, T ng)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return dot(ng, i) < T(0.0f) ? n : -n;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("//\n")
SLANG_RAW("// Section 8.6. Matrix Functions\n")
SLANG_RAW("//\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let C : int, let R : int>\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("[OverloadRank(15)]\n")
SLANG_RAW("public matrix<T, C, R> outerProduct(vector<T, C> c, vector<T, R> r)\n")
SLANG_RAW("{\n")
SLANG_RAW("    // Column major matrix in GLSL\n")
SLANG_RAW("    matrix<T, C, R> result;\n")
SLANG_RAW("    for (int i = 0; i < C; ++i)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        for (int j = 0; j < R; ++j)\n")
SLANG_RAW("        {\n")
SLANG_RAW("            result[i][j] = c[i] * r[j];\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("    return result;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("matrix<T,N,N> inverse(matrix<T,N,N> m);\n")
SLANG_RAW("\n")
SLANG_RAW("//\n")
SLANG_RAW("// Section 8.8. Integer Functions\n")
SLANG_RAW("//\n")
SLANG_RAW("\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public uint uaddCarry(highp uint x, highp uint y, out lowp uint carry)\n")
SLANG_RAW("{\n")
SLANG_RAW("    let result = x * y;\n")
SLANG_RAW("    carry = ((result < x || result < y) ? 1 : 0);\n")
SLANG_RAW("    return result;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<let N:int>\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<uint,N> uaddCarry(highp vector<uint,N> x, highp vector<uint,N> y, out lowp vector<uint,N> carry)\n")
SLANG_RAW("{\n")
SLANG_RAW("    VECTOR_MAP_TRINARY(uint, N, uaddCarry, x, y, carry);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public uint usubBorrow(highp uint x, highp uint y, out lowp uint borrow)\n")
SLANG_RAW("{\n")
SLANG_RAW("    borrow = (y > x) ? 1 : 0;\n")
SLANG_RAW("    return x - y;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<let N:int>\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<uint,N> usubBorrow(highp vector<uint,N> x, highp vector<uint,N> y, out lowp vector<uint,N> borrow)\n")
SLANG_RAW("{\n")
SLANG_RAW("    VECTOR_MAP_TRINARY(uint, N, usubBorrow, x, y, borrow);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public void umulExtended(highp uint x, highp uint y, out highp uint msb, out highp uint lsb)\n")
SLANG_RAW("{\n")
SLANG_RAW("    uint64_t result = x * y;\n")
SLANG_RAW("    msb = uint(result >> 32);\n")
SLANG_RAW("    lsb = uint(result);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<let N:int>\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public void umulExtended(highp vector<uint,N> x, highp vector<uint,N> y, out highp vector<uint,N> msb, out highp vector<uint,N> lsb)\n")
SLANG_RAW("{\n")
SLANG_RAW("    for(int i = 0; i < N; ++i)\n")
SLANG_RAW("    {\n")
SLANG_RAW("       umulExtended(x[i], y[i], msb[i], lsb[i]);\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public void imulExtended(highp int x, highp int y, out highp int msb, out highp int lsb)\n")
SLANG_RAW("{\n")
SLANG_RAW("    int64_t result = x * y;\n")
SLANG_RAW("    msb = int(result >> 32);\n")
SLANG_RAW("    lsb = int(result);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<let N:int>\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public void imulExtended(highp vector<int,N> x, highp vector<int,N> y, out highp vector<int,N> msb, out highp vector<int,N> lsb)\n")
SLANG_RAW("{\n")
SLANG_RAW("    for(int i = 0; i < N; ++i)\n")
SLANG_RAW("    {\n")
SLANG_RAW("       imulExtended(x[i], y[i], msb[i], lsb[i]);\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public int bitfieldExtract(int value, int offset, int bits)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return int(uint(value >> offset) & ((1u << bits) - 1));\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<let N:int>\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<int,N> bitfieldExtract(vector<int,N> value, int offset, int bits)\n")
SLANG_RAW("{\n")
SLANG_RAW("    vector<int,N> result;\n")
SLANG_RAW("    for (int i = 0; i < N; ++i)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        result[i] = bitfieldExtract(value[i], offset, bits);\n")
SLANG_RAW("    }\n")
SLANG_RAW("    return result;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public uint bitfieldExtract(uint value, int offset, int bits)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return (value >> offset) & ((1u << bits) - 1);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<let N:int>\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<uint,N> bitfieldExtract(vector<uint,N> value, int offset, int bits)\n")
SLANG_RAW("{\n")
SLANG_RAW("    vector<uint,N> result;\n")
SLANG_RAW("    for (int i = 0; i < N; ++i)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        result[i] = bitfieldExtract(value[i], offset, bits);\n")
SLANG_RAW("    }\n")
SLANG_RAW("    return result;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public uint bitfieldInsert(uint base, uint insert, int offset, int bits)\n")
SLANG_RAW("{\n")
SLANG_RAW("    uint clearMask = ~(((1u << bits) - 1u) << offset);\n")
SLANG_RAW("    uint clearedBase = base & clearMask;\n")
SLANG_RAW("    uint maskedInsert = (insert & ((1u << bits) - 1u)) << offset;\n")
SLANG_RAW("    return clearedBase | maskedInsert;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<let N:int>\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<uint,N> bitfieldInsert(vector<uint,N> base, vector<uint,N> insert, int offset, int bits)\n")
SLANG_RAW("{\n")
SLANG_RAW("    vector<uint,N> result;\n")
SLANG_RAW("    for (int i = 0; i < N; ++i)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        result[i] = bitfieldInsert(base[i], insert[i], offset, bits);\n")
SLANG_RAW("    }\n")
SLANG_RAW("    return result;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public int bitfieldInsert(int base, int insert, int offset, int bits)\n")
SLANG_RAW("{\n")
SLANG_RAW("    uint clearMask = ~(((1u << bits) - 1u) << offset);\n")
SLANG_RAW("    uint clearedBase = base & clearMask;\n")
SLANG_RAW("    uint maskedInsert = (insert & ((1u << bits) - 1u)) << offset;\n")
SLANG_RAW("    return clearedBase | maskedInsert;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<let N:int>\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<int,N> bitfieldInsert(vector<int,N> base, vector<int,N> insert, int offset, int bits)\n")
SLANG_RAW("{\n")
SLANG_RAW("    vector<int,N> result;\n")
SLANG_RAW("    for (int i = 0; i < N; ++i)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        result[i] = bitfieldInsert(base[i], insert[i], offset, bits);\n")
SLANG_RAW("    }\n")
SLANG_RAW("    return result;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public int bitfieldReverse(highp int value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    value = ((value & 0xAAAAAAAA) >> 1) | ((value & 0x55555555) << 1);\n")
SLANG_RAW("    value = ((value & 0xCCCCCCCC) >> 2) | ((value & 0x33333333) << 2);\n")
SLANG_RAW("    value = ((value & 0xF0F0F0F0) >> 4) | ((value & 0x0F0F0F0F) << 4);\n")
SLANG_RAW("    value = ((value & 0xFF00FF00) >> 8) | ((value & 0x00FF00FF) << 8);\n")
SLANG_RAW("    value = ((value & 0xFFFF0000) >> 16) | ((value & 0x0000FFFF) << 16);\n")
SLANG_RAW("    return value;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<let N:int>\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<int,N> bitfieldReverse(highp vector<int,N> value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    VECTOR_MAP_UNARY(int, N, bitfieldReverse, value);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public uint bitfieldReverse(highp uint value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    value = ((value & 0xAAAAAAAA) >> 1) | ((value & 0x55555555) << 1);\n")
SLANG_RAW("    value = ((value & 0xCCCCCCCC) >> 2) | ((value & 0x33333333) << 2);\n")
SLANG_RAW("    value = ((value & 0xF0F0F0F0) >> 4) | ((value & 0x0F0F0F0F) << 4);\n")
SLANG_RAW("    value = ((value & 0xFF00FF00) >> 8) | ((value & 0x00FF00FF) << 8);\n")
SLANG_RAW("    value = ((value & 0xFFFF0000) >> 16) | ((value & 0x0000FFFF) << 16);\n")
SLANG_RAW("    return value;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<let N:int>\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<uint,N> bitfieldReverse(highp vector<uint,N> value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    VECTOR_MAP_UNARY(int, N, bitfieldReverse, value);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[__readNone] [ForceInline] REQUIRE_KHRONOS\n")
SLANG_RAW("public uint bitCount(uint value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return countbits(value);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<let N:int>\n")
SLANG_RAW("[__readNone] [ForceInline] REQUIRE_KHRONOS\n")
SLANG_RAW("public vector<uint,N> bitCount(vector<uint,N> value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    VECTOR_MAP_UNARY(uint, N, countbits, value);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[__readNone] [ForceInline] REQUIRE_KHRONOS\n")
SLANG_RAW("public int bitCount(int value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return countbits(uint(value));\n")
SLANG_RAW("}\n")
SLANG_RAW("    \n")
SLANG_RAW("__generic<let N:int>\n")
SLANG_RAW("[__readNone] [ForceInline] REQUIRE_KHRONOS\n")
SLANG_RAW("public vector<int,N> bitCount(vector<int,N> value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    VECTOR_MAP_UNARY(int, N, countbits, value);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public int findLSB(int v)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return firstbitlow(v);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<let N:int>\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<int,N> findLSB(vector<int,N> value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return firstbitlow(value);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public uint findLSB(uint v)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return firstbitlow(v);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<let N:int>\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<uint,N> findLSB(vector<uint,N> value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return firstbitlow(value);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public int findMSB(int value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return firstbithigh(value);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<let N:int>\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<int,N> findMSB(vector<int,N> value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return firstbithigh(value);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public uint findMSB(uint value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return firstbithigh(value);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<let N:int>\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<uint,N> findMSB(vector<uint,N> value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return firstbithigh(value);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<let N:int>\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<bool,N> not(vector<bool,N> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return !x;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("//\n")
SLANG_RAW("// Section 8.9.1. Texture Query Functions\n")
SLANG_RAW("//\n")
SLANG_RAW("\n")
SLANG_RAW("public typealias usampler1D = Sampler1D<uint4>;\n")
SLANG_RAW("public typealias isampler1D = Sampler1D<int4>;\n")
SLANG_RAW("public typealias sampler1D = Sampler1D<float4>;\n")
SLANG_RAW("\n")
SLANG_RAW("public typealias usampler2D = Sampler2D<uint4>;\n")
SLANG_RAW("public typealias isampler2D = Sampler2D<int4>;\n")
SLANG_RAW("public typealias sampler2D = Sampler2D<float4>;\n")
SLANG_RAW("\n")
SLANG_RAW("public typealias usampler3D = Sampler3D<uint4>;\n")
SLANG_RAW("public typealias isampler3D = Sampler3D<int4>;\n")
SLANG_RAW("public typealias sampler3D = Sampler3D<float4>;\n")
SLANG_RAW("\n")
SLANG_RAW("public typealias usamplerCube = SamplerCube<uint4>;\n")
SLANG_RAW("public typealias isamplerCube = SamplerCube<int4>;\n")
SLANG_RAW("public typealias samplerCube = SamplerCube<float4>;\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<let sampleCount:int=0, let format:int=0>\n")
SLANG_RAW("public typealias sampler1DShadow = __TextureImpl<\n")
SLANG_RAW("    float,\n")
SLANG_RAW("    __Shape1D,\n")
SLANG_RAW("    0, // isArray\n")
SLANG_RAW("    0, // isMS\n")
SLANG_RAW("    sampleCount,\n")
SLANG_RAW("    0, // access\n")
SLANG_RAW("    1, // isShadow\n")
SLANG_RAW("    1, // isCombined\n")
SLANG_RAW("    format\n")
SLANG_RAW(">;\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<let sampleCount:int=0, let format:int=0>\n")
SLANG_RAW("public typealias sampler2DShadow = __TextureImpl<\n")
SLANG_RAW("    float,\n")
SLANG_RAW("    __Shape2D,\n")
SLANG_RAW("    0, // isArray\n")
SLANG_RAW("    0, // isMS\n")
SLANG_RAW("    sampleCount,\n")
SLANG_RAW("    0, // access\n")
SLANG_RAW("    1, // isShadow\n")
SLANG_RAW("    1, // isCombined\n")
SLANG_RAW("    format\n")
SLANG_RAW(">;\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<let sampleCount:int=0, let format:int=0>\n")
SLANG_RAW("public typealias samplerCubeShadow = __TextureImpl<\n")
SLANG_RAW("    float,\n")
SLANG_RAW("    __ShapeCube,\n")
SLANG_RAW("    0, // isArray\n")
SLANG_RAW("    0, // isMS\n")
SLANG_RAW("    sampleCount,\n")
SLANG_RAW("    0, // access\n")
SLANG_RAW("    1, // isShadow\n")
SLANG_RAW("    1, // isCombined\n")
SLANG_RAW("    format\n")
SLANG_RAW(">;\n")
SLANG_RAW("\n")
SLANG_RAW("public typealias usampler1DArray = Sampler1DArray<uint4>;\n")
SLANG_RAW("public typealias isampler1DArray = Sampler1DArray<int4>;\n")
SLANG_RAW("public typealias sampler1DArray = Sampler1DArray<float4>;\n")
SLANG_RAW("\n")
SLANG_RAW("public typealias usampler2DArray = Sampler2DArray<uint4>;\n")
SLANG_RAW("public typealias isampler2DArray = Sampler2DArray<int4>;\n")
SLANG_RAW("public typealias sampler2DArray = Sampler2DArray<float4>;\n")
SLANG_RAW("\n")
SLANG_RAW("public typealias usamplerCubeArray = SamplerCubeArray<uint4>;\n")
SLANG_RAW("public typealias isamplerCubeArray = SamplerCubeArray<int4>;\n")
SLANG_RAW("public typealias samplerCubeArray = SamplerCubeArray<float4>;\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<let sampleCount:int=0, let format:int=0>\n")
SLANG_RAW("public typealias sampler1DArrayShadow = __TextureImpl<\n")
SLANG_RAW("    float,\n")
SLANG_RAW("    __Shape1D,\n")
SLANG_RAW("    1, // isArray\n")
SLANG_RAW("    0, // isMS\n")
SLANG_RAW("    sampleCount,\n")
SLANG_RAW("    0, // access\n")
SLANG_RAW("    1, // isShadow\n")
SLANG_RAW("    1, // isCombined\n")
SLANG_RAW("    format\n")
SLANG_RAW(">;\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<let sampleCount:int=0, let format:int=0>\n")
SLANG_RAW("public typealias sampler2DArrayShadow = __TextureImpl<\n")
SLANG_RAW("    float,\n")
SLANG_RAW("    __Shape2D,\n")
SLANG_RAW("    1, // isArray\n")
SLANG_RAW("    0, // isMS\n")
SLANG_RAW("    sampleCount,\n")
SLANG_RAW("    0, // access\n")
SLANG_RAW("    1, // isShadow\n")
SLANG_RAW("    1, // isCombined\n")
SLANG_RAW("    format\n")
SLANG_RAW(">;\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<let sampleCount:int=0, let format:int=0>\n")
SLANG_RAW("public typealias samplerCubeArrayShadow = __TextureImpl<\n")
SLANG_RAW("    float,\n")
SLANG_RAW("    __ShapeCube,\n")
SLANG_RAW("    1, // isArray\n")
SLANG_RAW("    0, // isMS\n")
SLANG_RAW("    sampleCount,\n")
SLANG_RAW("    0, // access\n")
SLANG_RAW("    1, // isShadow\n")
SLANG_RAW("    1, // isCombined\n")
SLANG_RAW("    format\n")
SLANG_RAW(">;\n")
SLANG_RAW("\n")
SLANG_RAW("public typealias sampler2DMS = Sampler2DMS<float4>;\n")
SLANG_RAW("public typealias isampler2DMS = Sampler2DMS<int4>;\n")
SLANG_RAW("public typealias usampler2DMS = Sampler2DMS<uint4>;\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T=float4, let sampleCount:int=0, let format:int=0>\n")
SLANG_RAW("public typealias Sampler2DMSArray = Sampler2DArrayMS<T, sampleCount, format>;\n")
SLANG_RAW("public typealias sampler2DMSArray = Sampler2DMSArray<float4>;\n")
SLANG_RAW("public typealias isampler2DMSArray = Sampler2DMSArray<int4>;\n")
SLANG_RAW("public typealias usampler2DMSArray = Sampler2DMSArray<uint4>;\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T=float4, let sampleCount:int=0, let format:int=0>\n")
SLANG_RAW("public typealias Sampler2DRect = __TextureImpl<T, __Shape2D, 0, 0, sampleCount, 0, 0, 1, format>;\n")
SLANG_RAW("public typealias sampler2DRect = Sampler2DRect<float4>;\n")
SLANG_RAW("public typealias isampler2DRect = Sampler2DRect<int4>;\n")
SLANG_RAW("public typealias usampler2DRect = Sampler2DRect<uint4>;\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<let sampleCount:int=0, let format:int=0>\n")
SLANG_RAW("public typealias sampler2DRectShadow = __TextureImpl<\n")
SLANG_RAW("    float,\n")
SLANG_RAW("    __Shape2D,\n")
SLANG_RAW("    0, // isArray\n")
SLANG_RAW("    0, // isMS\n")
SLANG_RAW("    sampleCount,\n")
SLANG_RAW("    0, // access\n")
SLANG_RAW("    1, // isShadow\n")
SLANG_RAW("    1, // isCombined\n")
SLANG_RAW("    format\n")
SLANG_RAW(">;\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T, let format:int=0>\n")
SLANG_RAW("public typealias SamplerBuffer = __TextureImpl<\n")
SLANG_RAW("    T,\n")
SLANG_RAW("    __ShapeBuffer,\n")
SLANG_RAW("    0, // isArray\n")
SLANG_RAW("    0, // isMS\n")
SLANG_RAW("    0, // sampleCount\n")
SLANG_RAW("    1, // RW\n")
SLANG_RAW("    0, // isShadow\n")
SLANG_RAW("    0, // isCombined\n")
SLANG_RAW("    format\n")
SLANG_RAW(">;\n")
SLANG_RAW("public typealias samplerBuffer = SamplerBuffer<vec4>;\n")
SLANG_RAW("public typealias isamplerBuffer = SamplerBuffer<int4>;\n")
SLANG_RAW("public typealias usamplerBuffer = SamplerBuffer<uint4>;\n")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("// -------------------\n")
SLANG_RAW("// textureSize\n")
SLANG_RAW("// -------------------\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public int textureSize(Sampler1D<vector<T,N>> sampler, int lod)\n")
SLANG_RAW("{\n")
SLANG_RAW("    int result;\n")
SLANG_RAW("    int numberOfLevels;\n")
SLANG_RAW("    sampler.GetDimensions(lod, result, numberOfLevels);\n")
SLANG_RAW("    return result;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public ivec2 textureSize(Sampler2D<vector<T,N>> sampler, int lod)\n")
SLANG_RAW("{\n")
SLANG_RAW("    vector<int,2> result;\n")
SLANG_RAW("    int numberOfLevels;\n")
SLANG_RAW("    sampler.GetDimensions(lod, result.x, result.y, numberOfLevels);\n")
SLANG_RAW("    return result;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public ivec3 textureSize(Sampler3D<vector<T,N>> sampler, int lod)\n")
SLANG_RAW("{\n")
SLANG_RAW("    vector<int,3> result;\n")
SLANG_RAW("    int numberOfLevels;\n")
SLANG_RAW("    sampler.GetDimensions(lod, result.x, result.y, result.z, numberOfLevels);\n")
SLANG_RAW("    return result;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public ivec2 textureSize(SamplerCube<vector<T,N>> sampler, int lod)\n")
SLANG_RAW("{\n")
SLANG_RAW("    vector<int,2> result;\n")
SLANG_RAW("    int numberOfLevels;\n")
SLANG_RAW("    sampler.GetDimensions(lod, result.x, result.y, numberOfLevels);\n")
SLANG_RAW("    return result;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public int textureSize(sampler1DShadow sampler, int lod)\n")
SLANG_RAW("{\n")
SLANG_RAW("    int result;\n")
SLANG_RAW("    int numberOfLevels;\n")
SLANG_RAW("    sampler.GetDimensions(lod, result, numberOfLevels);\n")
SLANG_RAW("    return result;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public ivec2 textureSize(sampler2DShadow sampler, int lod)\n")
SLANG_RAW("{\n")
SLANG_RAW("    vector<int,2> result;\n")
SLANG_RAW("    int numberOfLevels;\n")
SLANG_RAW("    sampler.GetDimensions(lod, result.x, result.y, numberOfLevels);\n")
SLANG_RAW("    return result;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public ivec2 textureSize(samplerCubeShadow sampler, int lod)\n")
SLANG_RAW("{\n")
SLANG_RAW("    vector<int,2> result;\n")
SLANG_RAW("    int numberOfLevels;\n")
SLANG_RAW("    sampler.GetDimensions(lod, result.x, result.y, numberOfLevels);\n")
SLANG_RAW("    return result;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public ivec3 textureSize(SamplerCubeArray<vector<T,N>> sampler, int lod)\n")
SLANG_RAW("{\n")
SLANG_RAW("    vector<int,3> result;\n")
SLANG_RAW("    int numberOfLevels;\n")
SLANG_RAW("    sampler.GetDimensions(lod, result.x, result.y, result.z, numberOfLevels);\n")
SLANG_RAW("    return result;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public ivec3 textureSize(samplerCubeArrayShadow sampler, int lod)\n")
SLANG_RAW("{\n")
SLANG_RAW("    vector<int,3> result;\n")
SLANG_RAW("    int numberOfLevels;\n")
SLANG_RAW("    sampler.GetDimensions(lod, result.x, result.y, result.z, numberOfLevels);\n")
SLANG_RAW("    return result;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public ivec2 textureSize(Sampler2DRect<vector<T,N>> sampler)\n")
SLANG_RAW("{\n")
SLANG_RAW("    vector<int,2> result;\n")
SLANG_RAW("    int numberOfLevels;\n")
SLANG_RAW("    sampler.GetDimensions(0, result.x, result.y, numberOfLevels);\n")
SLANG_RAW("    return result;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public ivec2 textureSize(sampler2DRectShadow sampler)\n")
SLANG_RAW("{\n")
SLANG_RAW("    vector<int,2> result;\n")
SLANG_RAW("    int numberOfLevels;\n")
SLANG_RAW("    sampler.GetDimensions(result.x, result.y);\n")
SLANG_RAW("    return result;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public ivec2 textureSize(Sampler1DArray<vector<T,N>> sampler, int lod)\n")
SLANG_RAW("{\n")
SLANG_RAW("    vector<int,2> result;\n")
SLANG_RAW("    int numberOfLevels;\n")
SLANG_RAW("    sampler.GetDimensions(lod, result.x, result.y, numberOfLevels);\n")
SLANG_RAW("    return result;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public ivec2 textureSize(sampler1DArrayShadow sampler, int lod)\n")
SLANG_RAW("{\n")
SLANG_RAW("    vector<int,2> result;\n")
SLANG_RAW("    int numberOfLevels;\n")
SLANG_RAW("    sampler.GetDimensions(lod, result.x, result.y, numberOfLevels);\n")
SLANG_RAW("    return result;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public ivec3 textureSize(Sampler2DArray<vector<T,N>> sampler, int lod)\n")
SLANG_RAW("{\n")
SLANG_RAW("    vector<int,3> result;\n")
SLANG_RAW("    int numberOfLevels;\n")
SLANG_RAW("    sampler.GetDimensions(lod, result.x, result.y, result.z, numberOfLevels);\n")
SLANG_RAW("    return result;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public ivec3 textureSize(sampler2DArrayShadow sampler, int lod)\n")
SLANG_RAW("{\n")
SLANG_RAW("    vector<int,3> result;\n")
SLANG_RAW("    int numberOfLevels;\n")
SLANG_RAW("    sampler.GetDimensions(lod, result.x, result.y, result.z, numberOfLevels);\n")
SLANG_RAW("    return result;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int, let format:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public int textureSize(SamplerBuffer<vector<T,N>,format> sampler)\n")
SLANG_RAW("{\n")
SLANG_RAW("    uint result;\n")
SLANG_RAW("    sampler.GetDimensions(result);\n")
SLANG_RAW("    return int(result);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int, let sampleCount:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public ivec2 textureSize(Sampler2DMS<vector<T,N>,sampleCount> sampler)\n")
SLANG_RAW("{\n")
SLANG_RAW("    vector<int,2> result;\n")
SLANG_RAW("    int sampleCount;\n")
SLANG_RAW("    int numberOfLevels;\n")
SLANG_RAW("    sampler.GetDimensions(result.x, result.y, sampleCount);\n")
SLANG_RAW("    return result;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int, let sampleCount:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public ivec3 textureSize(Sampler2DMSArray<vector<T,N>,sampleCount> sampler)\n")
SLANG_RAW("{\n")
SLANG_RAW("    vector<int,3> result;\n")
SLANG_RAW("    int sampleCount;\n")
SLANG_RAW("    int numberOfLevels;\n")
SLANG_RAW("    sampler.GetDimensions(result.x, result.y, result.z, sampleCount);\n")
SLANG_RAW("    return result;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// -------------------\n")
SLANG_RAW("// textureQueryLod\n")
SLANG_RAW("// -------------------\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T, let isArray:int, let sampleCount:int, let isShadow:int, let format:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vec2 textureQueryLod(__TextureImpl<\n")
SLANG_RAW("        T,\n")
SLANG_RAW("        __Shape1D,\n")
SLANG_RAW("        isArray,\n")
SLANG_RAW("        0, // isMS\n")
SLANG_RAW("        sampleCount,\n")
SLANG_RAW("        0, // access\n")
SLANG_RAW("        isShadow,\n")
SLANG_RAW("        1, // isCombined\n")
SLANG_RAW("        format\n")
SLANG_RAW("    > sampler, float p)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return vec2(\n")
SLANG_RAW("        sampler.CalculateLevelOfDetail(p),\n")
SLANG_RAW("        sampler.CalculateLevelOfDetailUnclamped(p)\n")
SLANG_RAW("        );\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T, Shape: __ITextureShape, let isArray:int, let sampleCount:int, let isShadow:int, let format:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vec2 textureQueryLod(__TextureImpl<T,\n")
SLANG_RAW("        Shape,\n")
SLANG_RAW("        isArray,\n")
SLANG_RAW("        0, // isMS\n")
SLANG_RAW("        sampleCount,\n")
SLANG_RAW("        0, // access\n")
SLANG_RAW("        isShadow,\n")
SLANG_RAW("        1, // isCombined\n")
SLANG_RAW("        format\n")
SLANG_RAW("    > sampler, vector<float,Shape.dimensions> p)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return vec2(\n")
SLANG_RAW("        sampler.CalculateLevelOfDetail(p),\n")
SLANG_RAW("        sampler.CalculateLevelOfDetailUnclamped(p)\n")
SLANG_RAW("        );\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// -------------------\n")
SLANG_RAW("// textureQueryLevels\n")
SLANG_RAW("// -------------------\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public int textureQueryLevels(Sampler1D<vector<T,N>> sampler)\n")
SLANG_RAW("{\n")
SLANG_RAW("    int width;\n")
SLANG_RAW("    int numberOfLevels;\n")
SLANG_RAW("    sampler.GetDimensions(0, width, numberOfLevels);\n")
SLANG_RAW("    return numberOfLevels;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public int textureQueryLevels(Sampler2D<vector<T,N>> sampler)\n")
SLANG_RAW("{\n")
SLANG_RAW("    vector<int,2> dim;\n")
SLANG_RAW("    int numberOfLevels;\n")
SLANG_RAW("    sampler.GetDimensions(0, dim.x, dim.y, numberOfLevels);\n")
SLANG_RAW("    return numberOfLevels;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public int textureQueryLevels(Sampler3D<vector<T,N>> sampler)\n")
SLANG_RAW("{\n")
SLANG_RAW("    vector<int,3> dim;\n")
SLANG_RAW("    int numberOfLevels;\n")
SLANG_RAW("    sampler.GetDimensions(0, dim.x, dim.y, dim.z, numberOfLevels);\n")
SLANG_RAW("    return numberOfLevels;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public int textureQueryLevels(SamplerCube<vector<T,N>> sampler)\n")
SLANG_RAW("{\n")
SLANG_RAW("    vector<int,2> dim;\n")
SLANG_RAW("    int numberOfLevels;\n")
SLANG_RAW("    sampler.GetDimensions(0, dim.x, dim.y, numberOfLevels);\n")
SLANG_RAW("    return numberOfLevels;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public int textureQueryLevels(Sampler1DArray<vector<T,N>> sampler)\n")
SLANG_RAW("{\n")
SLANG_RAW("    vector<int,2> dim;\n")
SLANG_RAW("    int numberOfLevels;\n")
SLANG_RAW("    sampler.GetDimensions(0, dim.x, dim.y, numberOfLevels);\n")
SLANG_RAW("    return numberOfLevels;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public int textureQueryLevels(Sampler2DArray<vector<T,N>> sampler)\n")
SLANG_RAW("{\n")
SLANG_RAW("    vector<int,3> dim;\n")
SLANG_RAW("    int numberOfLevels;\n")
SLANG_RAW("    sampler.GetDimensions(0, dim.x, dim.y, dim.z, numberOfLevels);\n")
SLANG_RAW("    return numberOfLevels;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public int textureQueryLevels(SamplerCubeArray<vector<T,N>> sampler)\n")
SLANG_RAW("{\n")
SLANG_RAW("    vector<int,3> dim;\n")
SLANG_RAW("    int numberOfLevels;\n")
SLANG_RAW("    sampler.GetDimensions(0, dim.x, dim.y, dim.z, numberOfLevels);\n")
SLANG_RAW("    return numberOfLevels;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public int textureQueryLevels(sampler1DShadow sampler)\n")
SLANG_RAW("{\n")
SLANG_RAW("    int dim;\n")
SLANG_RAW("    int numberOfLevels;\n")
SLANG_RAW("    sampler.GetDimensions(0, dim, numberOfLevels);\n")
SLANG_RAW("    return numberOfLevels;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public int textureQueryLevels(sampler2DShadow sampler)\n")
SLANG_RAW("{\n")
SLANG_RAW("    vector<int,2> dim;\n")
SLANG_RAW("    int numberOfLevels;\n")
SLANG_RAW("    sampler.GetDimensions(0, dim.x, dim.y, numberOfLevels);\n")
SLANG_RAW("    return numberOfLevels;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public int textureQueryLevels(samplerCubeShadow sampler)\n")
SLANG_RAW("{\n")
SLANG_RAW("    vector<int,2> dim;\n")
SLANG_RAW("    int numberOfLevels;\n")
SLANG_RAW("    sampler.GetDimensions(0, dim.x, dim.y, numberOfLevels);\n")
SLANG_RAW("    return numberOfLevels;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public int textureQueryLevels(sampler1DArrayShadow sampler)\n")
SLANG_RAW("{\n")
SLANG_RAW("    vector<int,2> dim;\n")
SLANG_RAW("    int numberOfLevels;\n")
SLANG_RAW("    sampler.GetDimensions(0, dim.x, dim.y, numberOfLevels);\n")
SLANG_RAW("    return numberOfLevels;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public int textureQueryLevels(sampler2DArrayShadow sampler)\n")
SLANG_RAW("{\n")
SLANG_RAW("    vector<int,3> dim;\n")
SLANG_RAW("    int numberOfLevels;\n")
SLANG_RAW("    sampler.GetDimensions(0, dim.x, dim.y, dim.z, numberOfLevels);\n")
SLANG_RAW("    return numberOfLevels;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public int textureQueryLevels(samplerCubeArrayShadow sampler)\n")
SLANG_RAW("{\n")
SLANG_RAW("    vector<int,3> dim;\n")
SLANG_RAW("    int numberOfLevels;\n")
SLANG_RAW("    sampler.GetDimensions(0, dim.x, dim.y, dim.z, numberOfLevels);\n")
SLANG_RAW("    return numberOfLevels;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// -------------------\n")
SLANG_RAW("// textureSamples\n")
SLANG_RAW("// -------------------\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int, let sampleCount:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public int textureSamples(Sampler2DMS<vector<T,N>,sampleCount> sampler)\n")
SLANG_RAW("{\n")
SLANG_RAW("    vector<int,2> dim;\n")
SLANG_RAW("    int sampleCount;\n")
SLANG_RAW("    int numberOfLevels;\n")
SLANG_RAW("    sampler.GetDimensions( dim.x, dim.y, sampleCount);\n")
SLANG_RAW("    return sampleCount;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int, let sampleCount:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public int textureSamples(Sampler2DMSArray<vector<T,N>,sampleCount> sampler)\n")
SLANG_RAW("{\n")
SLANG_RAW("    vector<int,3> dim;\n")
SLANG_RAW("    int sampleCount;\n")
SLANG_RAW("    int numberOfLevels;\n")
SLANG_RAW("    sampler.GetDimensions(dim.x, dim.y, dim.z, sampleCount);\n")
SLANG_RAW("    return sampleCount;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("//\n")
SLANG_RAW("// Section 8.9.2. Texel Lookup Functions\n")
SLANG_RAW("//\n")
SLANG_RAW("\n")
SLANG_RAW("// -------------------\n")
SLANG_RAW("// texture\n")
SLANG_RAW("// -------------------\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<T,4> texture(Sampler1D<vector<T,N>> sampler, float p)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return __vectorReshape<4>(sampler.Sample(p));\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<T,4> texture(Sampler1D<vector<T,N>> sampler, float p, constexpr float bias)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return __vectorReshape<4>(sampler.SampleBias(p, bias));\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int, Shape: __ITextureShape, let isArray:int, let sampleCount:int, let format:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<T,4> texture(__TextureImpl<\n")
SLANG_RAW("        vector<T,N>,\n")
SLANG_RAW("        Shape,\n")
SLANG_RAW("        isArray,\n")
SLANG_RAW("        0, // isMS\n")
SLANG_RAW("        sampleCount,\n")
SLANG_RAW("        0, // access\n")
SLANG_RAW("        0, // isShadow\n")
SLANG_RAW("        1, // isCombined\n")
SLANG_RAW("        format\n")
SLANG_RAW("    > sampler, vector<float,Shape.dimensions+isArray> p)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return __vectorReshape<4>(sampler.Sample(p));\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int, Shape: __ITextureShape, let isArray:int, let sampleCount:int, let format:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<T,4> texture(__TextureImpl<\n")
SLANG_RAW("        vector<T,N>,\n")
SLANG_RAW("        Shape,\n")
SLANG_RAW("        isArray,\n")
SLANG_RAW("        0, // isMS\n")
SLANG_RAW("        sampleCount,\n")
SLANG_RAW("        0, // access\n")
SLANG_RAW("        0, // isShadow\n")
SLANG_RAW("        1, // isCombined\n")
SLANG_RAW("        format\n")
SLANG_RAW("    > sampler, vector<float,Shape.dimensions+isArray> p, constexpr float bias)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return __vectorReshape<4>(sampler.SampleBias(p, bias));\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public float texture(sampler1DShadow sampler, vec3 p)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return sampler.SampleCmp(p.x, p.z);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public float texture(sampler1DShadow sampler, vec3 p, float bias)\n")
SLANG_RAW("{\n")
SLANG_RAW("    // TODO: Need to apply bias\n")
SLANG_RAW("    return sampler.SampleCmp(p.x, p.z);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public float texture(sampler2DShadow sampler, vec3 p)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return sampler.SampleCmp(p.xy, p.z);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public float texture(sampler2DShadow sampler, vec3 p, float bias)\n")
SLANG_RAW("{\n")
SLANG_RAW("    // TODO: Need to apply bias\n")
SLANG_RAW("    return sampler.SampleCmp(p.xy, p.z);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public float texture(samplerCubeShadow sampler, vec4 p)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return sampler.SampleCmp(p.xyz, p.w);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public float texture(samplerCubeShadow sampler, vec4 p, float bias)\n")
SLANG_RAW("{\n")
SLANG_RAW("    // TODO: Need to apply bias\n")
SLANG_RAW("    return sampler.SampleCmp(p.xyz, p.w);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public float texture(sampler1DArrayShadow sampler, vec3 p)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return sampler.SampleCmp(p.xy, p.z);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public float texture(sampler1DArrayShadow sampler, vec3 p, float bias)\n")
SLANG_RAW("{\n")
SLANG_RAW("    // TODO: Need to apply bias\n")
SLANG_RAW("    return sampler.SampleCmp(p.xy, p.z);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public float texture(sampler2DArrayShadow sampler, vec4 p)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return sampler.SampleCmp(p.xyz, p.w);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public float texture(samplerCubeArrayShadow sampler, vec4 p, float compare)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return sampler.SampleCmp(p, compare);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// -------------------\n")
SLANG_RAW("// textureProj\n")
SLANG_RAW("// -------------------\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<T,4> textureProj(Sampler1D<vector<T,N>> sampler, vec2 p)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return texture(sampler, p.x / p.y);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<T,4> textureProj(Sampler1D<vector<T,N>> sampler, vec2 p, float bias)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return texture(sampler, p.x / p.y, bias);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<T,4> textureProj(Sampler1D<vector<T,N>> sampler, vec4 p)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return texture(sampler, p.x / p.w);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<T,4> textureProj(Sampler1D<vector<T,N>> sampler, vec4 p, float bias)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return texture(sampler, p.x / p.w, bias);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<T,4> textureProj(Sampler2D<vector<T,N>> sampler, vec3 p)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return texture(sampler, p.xy / p.z);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<T,4> textureProj(Sampler2D<vector<T,N>> sampler, vec3 p, float bias)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return texture(sampler, p.xy / p.z, bias);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<T,4> textureProj(Sampler2D<vector<T,N>> sampler, vec4 p)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return texture(sampler, p.xy / p.w);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<T,4> textureProj(Sampler2D<vector<T,N>> sampler, vec4 p, float bias)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return texture(sampler, p.xy / p.w, bias);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<T,4> textureProj(Sampler3D<vector<T,N>> sampler, vec4 p)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return texture(sampler, p.xyz / p.w);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<T,4> textureProj(Sampler3D<vector<T,N>> sampler, vec4 p, float bias)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return texture(sampler, p.xyz / p.w, bias);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public float textureProj(sampler1DShadow sampler, vec4 p)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return texture(sampler, p.xyz / p.w);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public float textureProj(sampler1DShadow sampler, vec4 p, float bias)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return texture(sampler, p.xyz / p.w, bias);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public float textureProj(sampler2DShadow sampler, vec4 p)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return texture(sampler, p.xyz / p.w);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public float textureProj(sampler2DShadow sampler, vec4 p, float bias)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return texture(sampler, p.xyz / p.w, bias);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// -------------------\n")
SLANG_RAW("// textureLod\n")
SLANG_RAW("// -------------------\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<T,4> textureLod(Sampler1D<vector<T,N>> sampler, float p, float lod)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return __vectorReshape<4>(sampler.SampleLevel(p, lod));\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int, Shape: __ITextureShape, let isArray:int, let sampleCount:int, let format:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<T,4> textureLod(__TextureImpl<\n")
SLANG_RAW("        vector<T,N>,\n")
SLANG_RAW("        Shape,\n")
SLANG_RAW("        isArray,\n")
SLANG_RAW("        0, // isMS\n")
SLANG_RAW("        sampleCount,\n")
SLANG_RAW("        0, // access\n")
SLANG_RAW("        0, // isShadow\n")
SLANG_RAW("        1, // isCombined\n")
SLANG_RAW("        format\n")
SLANG_RAW("    > sampler, vector<float,Shape.dimensions+isArray> p, float lod)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return __vectorReshape<4>(sampler.SampleLevel(p, lod));\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public float textureLod(sampler2DShadow sampler, vec3 p, float lod)\n")
SLANG_RAW("{\n")
SLANG_RAW("    // TODO: Need to apply lod\n")
SLANG_RAW("    return sampler.SampleCmp(p.xy, p.z);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public float textureLod(sampler1DShadow sampler, vec3 p, float lod)\n")
SLANG_RAW("{\n")
SLANG_RAW("    // TODO: Need to apply lod\n")
SLANG_RAW("    return sampler.SampleCmp(p.x, p.z);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public float textureLod(sampler1DArrayShadow sampler, vec3 p, float lod)\n")
SLANG_RAW("{\n")
SLANG_RAW("    // TODO: Need to apply lod\n")
SLANG_RAW("    return sampler.SampleCmp(p.xy, p.z);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// -------------------\n")
SLANG_RAW("// textureOffset\n")
SLANG_RAW("// -------------------\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<T,4> textureOffset(Sampler1D<vector<T,N>> sampler, float p, constexpr int offset, float bias = 0.0)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return __vectorReshape<4>(sampler.SampleBias(p, bias, offset));\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<T,4> textureOffset(Sampler2D<vector<T,N>> sampler, vec2 p, constexpr ivec2 offset, float bias = 0.0)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return __vectorReshape<4>(sampler.SampleBias(p, bias, offset));\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<T,4> textureOffset(Sampler3D<vector<T,N>> sampler, vec3 p, constexpr ivec3 offset, float bias = 0.0)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return __vectorReshape<4>(sampler.SampleBias(p, bias, offset));\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public float textureOffset(sampler2DShadow sampler, vec3 p, constexpr ivec2 offset, float bias = 0.0)\n")
SLANG_RAW("{\n")
SLANG_RAW("    // TODO: Need to apply bias\n")
SLANG_RAW("    return sampler.SampleCmp(p.xy, p.z, offset);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public float textureOffset(sampler1DShadow sampler, vec3 p, constexpr int offset, float bias = 0.0)\n")
SLANG_RAW("{\n")
SLANG_RAW("    // TODO: Need to apply bias\n")
SLANG_RAW("    return sampler.SampleCmp(p.x, p.z, offset);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<T,4> textureOffset(Sampler1DArray<vector<T,N>> sampler, vec2 p, constexpr int offset, float bias = 0.0)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return __vectorReshape<4>(sampler.SampleBias(p, bias, offset));\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<T,4> textureOffset(Sampler2DArray<vector<T,N>> sampler, vec3 p, constexpr ivec2 offset, float bias = 0.0)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return __vectorReshape<4>(sampler.SampleBias(p, bias, offset));\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public float textureOffset(sampler1DArrayShadow sampler, vec3 p, constexpr int offset, float bias = 0.0)\n")
SLANG_RAW("{\n")
SLANG_RAW("    // TODO: Need to apply bias\n")
SLANG_RAW("    return sampler.SampleCmp(p.xy, p.z, vector<int,1>(offset));\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public float textureOffset(sampler2DArrayShadow sampler, vec4 p, constexpr ivec2 offset)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return sampler.SampleCmp(p.xyz, p.w, offset);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// -------------------\n")
SLANG_RAW("// texelFetch\n")
SLANG_RAW("// -------------------\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<T,4> texelFetch(Sampler1D<vector<T,N>> sampler, int p, int lod)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return __vectorReshape<4>(sampler.Load(int2(p, lod)));\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int, Shape:__ITextureShape, let isArray:int, let sampleCount:int, let format:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<T,4> texelFetch(__TextureImpl<\n")
SLANG_RAW("        vector<T,N>,\n")
SLANG_RAW("        Shape,\n")
SLANG_RAW("        isArray,\n")
SLANG_RAW("        0, // isMS\n")
SLANG_RAW("        sampleCount,\n")
SLANG_RAW("        0, // access\n")
SLANG_RAW("        0, // isShadow\n")
SLANG_RAW("        1, // isCombined\n")
SLANG_RAW("        format\n")
SLANG_RAW("    > sampler, vector<int,Shape.dimensions+isArray> p, int lod)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return __vectorReshape<4>(sampler.Load(__makeVector(p,lod)));\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<T,4> texelFetch(Sampler2DRect<vector<T,N>> sampler, ivec2 p)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return __vectorReshape<4>(sampler.Load(int3(p.xy,0)));\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int, let format:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<T,4> texelFetch(SamplerBuffer<vector<T,N>,format> sampler, int p)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return __vectorReshape<4>(sampler.Load(p));\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int, let isArray:int, let sampleCount:int, let format:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<T,4> texelFetch(__TextureImpl<\n")
SLANG_RAW("        vector<T,N>,\n")
SLANG_RAW("        __Shape2D,\n")
SLANG_RAW("        isArray,\n")
SLANG_RAW("        1, // isMS\n")
SLANG_RAW("        sampleCount,\n")
SLANG_RAW("        0, // access\n")
SLANG_RAW("        0, // isShadow\n")
SLANG_RAW("        1, // isCombined\n")
SLANG_RAW("        format\n")
SLANG_RAW("    > sampler, vector<int,2+isArray> p, int lod)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return __vectorReshape<4>(sampler.Load(p, lod));\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// -------------------\n")
SLANG_RAW("// texelFetchOffset\n")
SLANG_RAW("// -------------------\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<T,4> texelFetchOffset(Sampler1D<vector<T,N>> sampler, int p, int lod, constexpr int offset)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return texelFetch(sampler, p + offset, lod);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int, Shape:__ITextureShape, let sampleCount:int, let format:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<T,4> texelFetchOffset(__TextureImpl<\n")
SLANG_RAW("        vector<T,N>,\n")
SLANG_RAW("        Shape,\n")
SLANG_RAW("        0, // isArray\n")
SLANG_RAW("        0, // isMS\n")
SLANG_RAW("        sampleCount,\n")
SLANG_RAW("        0, // access\n")
SLANG_RAW("        0, // isShadow\n")
SLANG_RAW("        1, // isCombined\n")
SLANG_RAW("        format\n")
SLANG_RAW("    > sampler, vector<int,Shape.dimensions> p, int lod, constexpr vector<int,Shape.dimensions> offset)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return texelFetch(sampler, p + offset, lod);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int, Shape:__ITextureShape, let sampleCount:int, let format:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<T,4> texelFetchOffset(__TextureImpl<\n")
SLANG_RAW("        vector<T,N>,\n")
SLANG_RAW("        Shape,\n")
SLANG_RAW("        1, // isArray\n")
SLANG_RAW("        0, // isMS\n")
SLANG_RAW("        sampleCount,\n")
SLANG_RAW("        0, // access\n")
SLANG_RAW("        0, // isShadow\n")
SLANG_RAW("        1, // isCombined\n")
SLANG_RAW("        format\n")
SLANG_RAW("    > sampler, vector<int,Shape.dimensions+1> p, int lod, constexpr vector<int,Shape.dimensions> offset)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return texelFetch(sampler, p + __makeVector(offset,0), lod);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<T,4> texelFetchOffset(Sampler2DRect<vector<T,N>> sampler, ivec2 p, constexpr ivec2 offset)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return texelFetch(sampler, p + offset);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// -------------------\n")
SLANG_RAW("// textureProjOffset\n")
SLANG_RAW("// -------------------\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<T,4> textureProjOffset(Sampler1D<vector<T,N>> sampler, vec2 p, constexpr int offset, float bias = 0.0)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return textureOffset(sampler, p.x / p.y, offset, bias);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<T,4> textureProjOffset(Sampler1D<vector<T,N>> sampler, vec4 p, constexpr int offset, float bias = 0.0)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return textureOffset(sampler, p.x / p.w, offset, bias);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<T,4> textureProjOffset(Sampler2D<vector<T,N>> sampler, vec3 p, constexpr ivec2 offset, float bias = 0.0)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return textureOffset(sampler, p.xy / p.z, offset, bias);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<T,4> textureProjOffset(Sampler2D<vector<T,N>> sampler, vec4 p, constexpr ivec2 offset, float bias = 0.0)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return textureOffset(sampler, p.xy / p.w, offset, bias);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<T,4> textureProjOffset(Sampler3D<vector<T,N>> sampler, vec4 p, constexpr ivec3 offset, float bias = 0.0)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return textureOffset(sampler, p.xyz / p.w, offset, bias);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public float textureProjOffset(sampler1DShadow sampler, vec4 p, constexpr int offset, float bias = 0.0)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return textureOffset(sampler, p.xyz / p.w, offset, bias);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public float textureProjOffset(sampler2DShadow sampler, vec4 p, constexpr ivec2 offset, float bias = 0.0)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return textureOffset(sampler, p.xyz / p.w, offset, bias);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// -------------------\n")
SLANG_RAW("// textureLodOffset\n")
SLANG_RAW("// -------------------\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<T,4> textureLodOffset(Sampler1D<vector<T,N>> sampler, float p, float lod, constexpr int offset)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return __vectorReshape<4>(sampler.SampleLevel(p, lod, offset));\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int, Shape:__ITextureShape, let isArray:int, let sampleCount:int, let format:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<T,4> textureLodOffset(__TextureImpl<\n")
SLANG_RAW("        vector<T,N>,\n")
SLANG_RAW("        Shape,\n")
SLANG_RAW("        isArray,\n")
SLANG_RAW("        0, // isMS\n")
SLANG_RAW("        sampleCount,\n")
SLANG_RAW("        0, // access\n")
SLANG_RAW("        0, // isShadow\n")
SLANG_RAW("        1, // isCombined\n")
SLANG_RAW("        format\n")
SLANG_RAW("    > sampler, vector<float,Shape.dimensions+isArray> p, float lod, constexpr vector<int,Shape.planeDimensions> offset)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return __vectorReshape<4>(sampler.SampleLevel(p, lod, offset));\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public float textureLodOffset(sampler1DShadow sampler, vec3 p, float lod, constexpr int offset)\n")
SLANG_RAW("{\n")
SLANG_RAW("    // TODO: Need to apply lod\n")
SLANG_RAW("    return sampler.SampleCmpLevelZero(p.x, p.z, offset);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public float textureLodOffset(sampler2DShadow sampler, vec3 p, float lod, constexpr ivec2 offset)\n")
SLANG_RAW("{\n")
SLANG_RAW("    // TODO: Need to apply lod\n")
SLANG_RAW("    return sampler.SampleCmpLevelZero(p.xy, p.z, offset);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public float textureLodOffset(sampler1DArrayShadow sampler, vec3 p, float lod, constexpr int offset)\n")
SLANG_RAW("{\n")
SLANG_RAW("    // TODO: Need to apply lod\n")
SLANG_RAW("    return sampler.SampleCmpLevelZero(p.xy, p.z, offset);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// -------------------\n")
SLANG_RAW("// textureProjLod\n")
SLANG_RAW("// -------------------\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<T,4> textureProjLod(Sampler1D<vector<T,N>> sampler, vec2 p, float lod)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return textureLod(sampler, p.x / p.y, lod);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<T,4> textureProjLod(Sampler1D<vector<T,N>> sampler, vec4 p, float lod)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return textureLod(sampler, p.x / p.w, lod);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<T,4> textureProjLod(Sampler2D<vector<T,N>> sampler, vec3 p, float lod)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return textureLod(sampler, p.xy / p.z, lod);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<T,4> textureProjLod(Sampler2D<vector<T,N>> sampler, vec4 p, float lod)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return textureLod(sampler, p.xy / p.w, lod);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<T,4> textureProjLod(Sampler3D<vector<T,N>> sampler, vec4 p, float lod)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return textureLod(sampler, p.xyz / p.w, lod);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public float textureProjLod(sampler1DShadow sampler, vec4 p, float lod)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return textureLod(sampler, p.xyz / p.w, lod);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public float textureProjLod(sampler2DShadow sampler, vec4 p, float lod)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return textureLod(sampler, p.xyz / p.w, lod);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// -------------------\n")
SLANG_RAW("// textureProjLodOffset\n")
SLANG_RAW("// -------------------\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<T,4> textureProjLodOffset(Sampler1D<vector<T,N>> sampler, vec2 p, float lod, constexpr int offset)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return textureLodOffset(sampler, p.x / p.y, lod, offset);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<T,4> textureProjLodOffset(Sampler1D<vector<T,N>> sampler, vec4 p, float lod, constexpr int offset)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return textureLodOffset(sampler, p.x / p.w, lod, offset);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<T,4> textureProjLodOffset(Sampler2D<vector<T,N>> sampler, vec3 p, float lod, constexpr ivec2 offset)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return textureLodOffset(sampler, p.xy / p.z, lod, offset);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<T,4> textureProjLodOffset(Sampler2D<vector<T,N>> sampler, vec4 p, float lod, constexpr ivec2 offset)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return textureLodOffset(sampler, p.xy / p.w, lod, offset);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<T,4> textureProjLodOffset(Sampler3D<vector<T,N>> sampler, vec4 p, float lod, constexpr ivec3 offset)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return textureLodOffset(sampler, p.xyz / p.w, lod, offset);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public float textureProjLodOffset(sampler1DShadow sampler, vec4 p, float lod, constexpr int offset)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return textureLodOffset(sampler, p.xyz / p.w, lod, offset);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public float textureProjLodOffset(sampler2DShadow sampler, vec4 p, float lod, constexpr ivec2 offset)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return textureLodOffset(sampler, p.xyz / p.w, lod, offset);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// -------------------\n")
SLANG_RAW("// textureGrad\n")
SLANG_RAW("// -------------------\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<T,4> textureGrad(Sampler1D<vector<T,N>> sampler, float p, float dPdx, float dPdy)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return __vectorReshape<4>(sampler.SampleGrad(p, dPdx, dPdy));\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int, Shape:__ITextureShape, let isArray:int, let sampleCount:int, let format:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<T,4> textureGrad(__TextureImpl<\n")
SLANG_RAW("        vector<T,N>,\n")
SLANG_RAW("        Shape,\n")
SLANG_RAW("        isArray,\n")
SLANG_RAW("        0, // isMS\n")
SLANG_RAW("        sampleCount,\n")
SLANG_RAW("        0, // access\n")
SLANG_RAW("        0, // isShadow\n")
SLANG_RAW("        1, // isCombined\n")
SLANG_RAW("        format\n")
SLANG_RAW("    > sampler, vector<float,Shape.dimensions+isArray> p, vector<float,Shape.dimensions> dPdx, vector<float,Shape.dimensions> dPdy)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return __vectorReshape<4>(sampler.SampleGrad(p, dPdx, dPdy));\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public float textureGrad(sampler1DShadow sampler, vec3 p, float dPdx, float dPdy)\n")
SLANG_RAW("{\n")
SLANG_RAW("    // TODO: Not implemented\n")
SLANG_RAW("    return 0;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public float textureGrad(sampler1DArrayShadow sampler, vec3 p, float dPdx, float dPdy)\n")
SLANG_RAW("{\n")
SLANG_RAW("    // TODO: Not implemented\n")
SLANG_RAW("    return 0;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public float textureGrad(sampler2DShadow sampler, vec3 p, vec2 dPdx, vec2 dPdy)\n")
SLANG_RAW("{\n")
SLANG_RAW("    // TODO: Not implemented on HLSL side yet.\n")
SLANG_RAW("    return 0;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public float textureGrad(samplerCubeShadow sampler, vec4 p, vec3 dPdx, vec3 dPdy)\n")
SLANG_RAW("{\n")
SLANG_RAW("    // TODO: Not implemented on HLSL side yet.\n")
SLANG_RAW("    return 0;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public float textureGrad(sampler2DArrayShadow sampler, vec4 p, vec2 dPdx, vec2 dPdy)\n")
SLANG_RAW("{\n")
SLANG_RAW("    // TODO: Not implemented on HLSL side yet.\n")
SLANG_RAW("    return 0;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// -------------------\n")
SLANG_RAW("// textureGradOffset\n")
SLANG_RAW("// -------------------\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<T,4> textureGradOffset(Sampler1D<vector<T,N>> sampler, float p, float dPdx, float dPdy, constexpr int offset)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return __vectorReshape<4>(sampler.SampleGrad(p, dPdx, dPdy, offset));\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int, Shape:__ITextureShape, let isArray:int, let sampleCount:int, let format:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<T,4> textureGradOffset(__TextureImpl<\n")
SLANG_RAW("        vector<T,N>,\n")
SLANG_RAW("        Shape,\n")
SLANG_RAW("        isArray,\n")
SLANG_RAW("        0, // isMS\n")
SLANG_RAW("        sampleCount,\n")
SLANG_RAW("        0, // access\n")
SLANG_RAW("        0, // isShadow\n")
SLANG_RAW("        1, // isCombined\n")
SLANG_RAW("        format\n")
SLANG_RAW("    > sampler, vector<float,Shape.dimensions+isArray> p, vector<float,Shape.dimensions> dPdx, vector<float,Shape.dimensions> dPdy, constexpr vector<int,Shape.dimensions> offset)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return __vectorReshape<4>(sampler.SampleGrad(p, dPdx, dPdy, offset));\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public float textureGradOffset(sampler1DShadow sampler, vec3 p, float dPdx, float dPdy, constexpr int offset)\n")
SLANG_RAW("{\n")
SLANG_RAW("    // TODO: Not implemented on HLSL side yet.\n")
SLANG_RAW("    return 0;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public float textureGradOffset(sampler2DShadow sampler, vec3 p, vec2 dPdx, vec2 dPdy, constexpr ivec2 offset)\n")
SLANG_RAW("{\n")
SLANG_RAW("    // TODO: Not implemented on HLSL side yet.\n")
SLANG_RAW("    return 0;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public float textureGradOffset(sampler1DArrayShadow sampler, vec3 p, float dPdx, float dPdy, constexpr int offset)\n")
SLANG_RAW("{\n")
SLANG_RAW("    // TODO: Not implemented on HLSL side yet.\n")
SLANG_RAW("    return 0;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public float textureGradOffset(sampler2DArrayShadow sampler, vec4 p, vec2 dPdx, vec2 dPdy, constexpr ivec2 offset)\n")
SLANG_RAW("{\n")
SLANG_RAW("    // TODO: Not implemented on HLSL side yet.\n")
SLANG_RAW("    return 0;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// -------------------\n")
SLANG_RAW("// textureProjGrad\n")
SLANG_RAW("// -------------------\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<T,4> textureProjGrad(Sampler1D<vector<T,N>> sampler, vec2 p, float dPdx, float dPdy)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return textureGrad(sampler, p.x / p.y, dPdx, dPdy);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<T,4> textureProjGrad(Sampler1D<vector<T,N>> sampler, vec4 p, float dPdx, float dPdy)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return textureGrad(sampler, p.x / p.w, dPdx, dPdy);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<T,4> textureProjGrad(Sampler2D<vector<T,N>> sampler, vec3 p, vec2 dPdx, vec2 dPdy)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return textureGrad(sampler, p.xy / p.z, dPdx, dPdy);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<T,4> textureProjGrad(Sampler2D<vector<T,N>> sampler, vec4 p, vec2 dPdx, vec2 dPdy)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return textureGrad(sampler, p.xy / p.w, dPdx, dPdy);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<T,4> textureProjGrad(Sampler3D<vector<T,N>> sampler, vec4 p, vec3 dPdx, vec3 dPdy)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return textureGrad(sampler, p.xyz / p.w, dPdx, dPdy);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public float textureProjGrad(sampler1DShadow sampler, vec4 p, float dPdx, float dPdy)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return textureGrad(sampler, p.xyz / p.w, dPdx, dPdy);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public float textureProjGrad(sampler2DShadow sampler, vec4 p, vec2 dPdx, vec2 dPdy)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return textureGrad(sampler, p.xyz / p.w, dPdx, dPdy);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// -------------------\n")
SLANG_RAW("// textureProjGradOffset\n")
SLANG_RAW("// -------------------\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<T,4> textureProjGradOffset(Sampler1D<vector<T,N>> sampler, vec2 p, float dPdx, float dPdy, constexpr int offset)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return textureGradOffset(sampler, p.x / p.y, dPdx, dPdy, offset);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<T,4> textureProjGradOffset(Sampler1D<vector<T,N>> sampler, vec4 p, float dPdx, float dPdy, constexpr int offset)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return textureGradOffset(sampler, p.x / p.w, dPdx, dPdy, offset);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<T,4> textureProjGradOffset(Sampler2D<vector<T,N>> sampler, vec3 p, vec2 dPdx, vec2 dPdy, constexpr ivec2 offset)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return textureGradOffset(sampler, p.xy / p.z, dPdx, dPdy, offset);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<T,4> textureProjGradOffset(Sampler2D<vector<T,N>> sampler, vec4 p, vec2 dPdx, vec2 dPdy, constexpr ivec2 offset)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return textureGradOffset(sampler, p.xy / p.w, dPdx, dPdy, offset);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<T,4> textureProjGradOffset(Sampler3D<vector<T,N>> sampler, vec4 p, vec3 dPdx, vec3 dPdy, constexpr ivec3 offset)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return textureGradOffset(sampler, p.xyz / p.w, dPdx, dPdy, offset);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public float textureProjGradOffset(sampler1DShadow sampler, vec4 p, float dPdx, float dPdy, constexpr int offset)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return textureGradOffset(sampler, p.xyz / p.w, dPdx, dPdy, offset);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public float textureProjGradOffset(sampler2DShadow sampler, vec4 p, vec2 dPdx, vec2 dPdy, constexpr ivec2 offset)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return textureGradOffset(sampler, p.xyz / p.w, dPdx, dPdy, offset);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("//\n")
SLANG_RAW("// Section 8.9.4. Texture Gather Functions\n")
SLANG_RAW("//\n")
SLANG_RAW("\n")
SLANG_RAW("// -------------------\n")
SLANG_RAW("// textureGather\n")
SLANG_RAW("// -------------------\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int, Shape:__ITextureShape, let isArray:int, let sampleCount:int, let format:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<T,4> textureGather(__TextureImpl<\n")
SLANG_RAW("        vector<T,N>,\n")
SLANG_RAW("        Shape,\n")
SLANG_RAW("        isArray,\n")
SLANG_RAW("        0, // isMS\n")
SLANG_RAW("        sampleCount,\n")
SLANG_RAW("        0, // access\n")
SLANG_RAW("        0, // isShadow\n")
SLANG_RAW("        1, // isCombined\n")
SLANG_RAW("        format\n")
SLANG_RAW("    > sampler, vector<float,Shape.dimensions+isArray> p, int comp = 0)\n")
SLANG_RAW("{\n")
SLANG_RAW("    switch (comp)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        case 1: return sampler.GatherGreen(p);\n")
SLANG_RAW("        case 2: return sampler.GatherBlue(p);\n")
SLANG_RAW("        case 3: return sampler.GatherAlpha(p);\n")
SLANG_RAW("    }\n")
SLANG_RAW("    return sampler.GatherRed(p);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<Shape:__ITextureShape, let isArray:int, let sampleCount:int, let format:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vec4 textureGather(__TextureImpl<\n")
SLANG_RAW("        float,\n")
SLANG_RAW("        Shape,\n")
SLANG_RAW("        isArray,\n")
SLANG_RAW("        0, // isMS\n")
SLANG_RAW("        sampleCount,\n")
SLANG_RAW("        0, // access\n")
SLANG_RAW("        1, // isShadow\n")
SLANG_RAW("        1, // isCombined\n")
SLANG_RAW("        format\n")
SLANG_RAW("    > sampler, vector<float,Shape.dimensions+isArray> p, float refZ)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return sampler.GatherCmp(p, refZ);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// -------------------\n")
SLANG_RAW("// textureGatherOffset\n")
SLANG_RAW("// -------------------\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int, let isArray:int, let sampleCount:int, let format:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<T,4> textureGatherOffset(__TextureImpl<\n")
SLANG_RAW("        vector<T,N>,\n")
SLANG_RAW("        __Shape2D,\n")
SLANG_RAW("        isArray,\n")
SLANG_RAW("        0, // isMS\n")
SLANG_RAW("        sampleCount,\n")
SLANG_RAW("        0, // access\n")
SLANG_RAW("        0, // isShadow\n")
SLANG_RAW("        1, // isCombined\n")
SLANG_RAW("        format\n")
SLANG_RAW("    > sampler, vector<float,2+isArray> p, constexpr vector<int,2> offset, int comp = 0)\n")
SLANG_RAW("{\n")
SLANG_RAW("    switch (comp)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        case 1: return sampler.GatherGreen(p, offset);\n")
SLANG_RAW("        case 2: return sampler.GatherBlue(p, offset);\n")
SLANG_RAW("        case 3: return sampler.GatherAlpha(p, offset);\n")
SLANG_RAW("    }\n")
SLANG_RAW("    return sampler.Gather(p, offset);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<let isArray:int, let sampleCount:int, let format:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vec4 textureGatherOffset(__TextureImpl<\n")
SLANG_RAW("        float,\n")
SLANG_RAW("        __Shape2D,\n")
SLANG_RAW("        isArray,\n")
SLANG_RAW("        0, // isMS\n")
SLANG_RAW("        sampleCount,\n")
SLANG_RAW("        0, // access\n")
SLANG_RAW("        1, // isShadow\n")
SLANG_RAW("        1, // isCombined\n")
SLANG_RAW("        format\n")
SLANG_RAW("    > sampler, vector<float,2+isArray> p, float refZ, constexpr vector<int,2> offset)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return sampler.GatherCmp(p, refZ, offset);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// -------------------\n")
SLANG_RAW("// textureGatherOffsets\n")
SLANG_RAW("// -------------------\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, let N:int, let isArray:int, let sampleCount:int, let format:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vector<T,4> textureGatherOffsets(__TextureImpl<\n")
SLANG_RAW("        vector<T,N>,\n")
SLANG_RAW("        __Shape2D,\n")
SLANG_RAW("        isArray,\n")
SLANG_RAW("        0, // isMS\n")
SLANG_RAW("        sampleCount,\n")
SLANG_RAW("        0, // access\n")
SLANG_RAW("        0, // isShadow\n")
SLANG_RAW("        1, // isCombined\n")
SLANG_RAW("        format\n")
SLANG_RAW("    > sampler, vector<float,2+isArray> p, constexpr vector<int,2> offsets[4], int comp = 0)\n")
SLANG_RAW("{\n")
SLANG_RAW("    switch (comp)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        case 1: return sampler.GatherGreen(p, offsets[0], offsets[1], offsets[2], offsets[3]);\n")
SLANG_RAW("        case 2: return sampler.GatherBlue(p, offsets[0], offsets[1], offsets[2], offsets[3]);\n")
SLANG_RAW("        case 3: return sampler.GatherAlpha(p, offsets[0], offsets[1], offsets[2], offsets[3]);\n")
SLANG_RAW("    }\n")
SLANG_RAW("    return sampler.Gather(p, offsets[0], offsets[1], offsets[2], offsets[3]);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<let isArray:int, let sampleCount:int, let format:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public vec4 textureGatherOffsets(__TextureImpl<\n")
SLANG_RAW("        float,\n")
SLANG_RAW("        __Shape2D,\n")
SLANG_RAW("        isArray,\n")
SLANG_RAW("        0, // isMS\n")
SLANG_RAW("        sampleCount,\n")
SLANG_RAW("        0, // access\n")
SLANG_RAW("        1, // isShadow\n")
SLANG_RAW("        1, // isCombined\n")
SLANG_RAW("        format\n")
SLANG_RAW("    > sampler, vector<float,2+isArray> p, float refZ, constexpr vector<int,2> offsets[4])\n")
SLANG_RAW("{\n")
SLANG_RAW("    return sampler.GatherCmp(p, refZ, offsets[0], offsets[1], offsets[2], offsets[3]);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("//\n")
SLANG_RAW("// Section 8.9.5. Compatibility Profile Texture Functions\n")
SLANG_RAW("//\n")
SLANG_RAW("\n")
SLANG_RAW("public vec4 texture1D(sampler1D sampler, float coord)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return texture(sampler, coord);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("public vec4 texture1D(sampler1D sampler, float coord, float bias)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return texture(sampler, coord, bias);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("public vec4 texture1DProj(sampler1D sampler, vec2 coord)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return textureProj(sampler, coord);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("public vec4 texture1DProj(sampler1D sampler, vec2 coord, float bias)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return textureProj(sampler, coord, bias);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("public vec4 texture1DProj(sampler1D sampler, vec4 coord)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return textureProj(sampler, coord);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("public vec4 texture1DProj(sampler1D sampler, vec4 coord, float bias)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return textureProj(sampler, coord, bias);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("public vec4 texture1DLod(sampler1D sampler, float coord, float lod)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return textureLod(sampler, coord, lod);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("public vec4 texture1DProjLod(sampler1D sampler, vec2 coord, float lod)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return textureProjLod(sampler, coord, lod);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("public vec4 texture1DProjLod(sampler1D sampler, vec4 coord, float lod)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return textureProjLod(sampler, coord, lod);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("public vec4 texture2D(sampler2D sampler, vec2 coord)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return texture(sampler, coord);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("public vec4 texture2D(sampler2D sampler, vec2 coord, float bias)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return texture(sampler, coord, bias);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("public vec4 texture2DProj(sampler2D sampler, vec3 coord)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return textureProj(sampler, coord);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("public vec4 texture2DProj(sampler2D sampler, vec3 coord, float bias)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return textureProj(sampler, coord, bias);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("public vec4 texture2DProj(sampler2D sampler, vec4 coord)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return textureProj(sampler, coord);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("public vec4 texture2DProj(sampler2D sampler, vec4 coord, float bias)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return textureProj(sampler, coord, bias);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("public vec4 texture2DLod(sampler2D sampler, vec2 coord, float lod)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return textureLod(sampler, coord, lod);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("public vec4 texture2DProjLod(sampler2D sampler, vec3 coord, float lod)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return textureProjLod(sampler, coord, lod);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("public vec4 texture2DProjLod(sampler2D sampler, vec4 coord, float lod)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return textureProjLod(sampler, coord, lod);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("public vec4 texture3D(sampler3D sampler, vec3 coord)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return texture(sampler, coord);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("public vec4 texture3D(sampler3D sampler, vec3 coord, float bias)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return texture(sampler, coord, bias);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("public vec4 texture3DProj(sampler3D sampler, vec4 coord)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return textureProj(sampler, coord);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("public vec4 texture3DProj(sampler3D sampler, vec4 coord, float bias)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return textureProj(sampler, coord, bias);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("public vec4 texture3DLod(sampler3D sampler, vec3 coord, float lod)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return textureLod(sampler, coord, lod);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("public vec4 texture3DProjLod(sampler3D sampler, vec4 coord, float lod)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return textureProjLod(sampler, coord, lod);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("public vec4 textureCube(samplerCube sampler, vec3 coord)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return texture(sampler, coord);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("public vec4 textureCube(samplerCube sampler, vec3 coord, float bias)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return texture(sampler, coord, bias);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("public vec4 textureCubeLod(samplerCube sampler, vec3 coord, float lod)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return textureLod(sampler, coord, lod);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("public vec4 shadow1D(sampler1DShadow sampler, vec3 coord)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return texture(sampler, coord);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("public vec4 shadow1D(sampler1DShadow sampler, vec3 coord, float bias)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return texture(sampler, coord, bias);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("public vec4 shadow2D(sampler2DShadow sampler, vec3 coord)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return texture(sampler, coord);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("public vec4 shadow2D(sampler2DShadow sampler, vec3 coord, float bias)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return texture(sampler, coord, bias);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("public vec4 shadow1DProj(sampler1DShadow sampler, vec4 coord)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return textureProj(sampler, coord);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("public vec4 shadow1DProj(sampler1DShadow sampler, vec4 coord, float bias)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return textureProj(sampler, coord, bias);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("public vec4 shadow2DProj(sampler2DShadow sampler, vec4 coord)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return textureProj(sampler, coord);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("public vec4 shadow2DProj(sampler2DShadow sampler, vec4 coord, float bias)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return textureProj(sampler, coord, bias);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("public vec4 shadow1DLod(sampler1DShadow sampler, vec3 coord, float lod)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return textureLod(sampler, coord, lod);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("public vec4 shadow2DLod(sampler2DShadow sampler, vec3 coord, float lod)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return textureLod(sampler, coord, lod);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("public vec4 shadow1DProjLod(sampler1DShadow sampler, vec4 coord, float lod)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return textureProjLod(sampler, coord, lod);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("public vec4 shadow2DProjLod(sampler2DShadow sampler, vec4 coord, float lod)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return textureProjLod(sampler, coord, lod);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("//\n")
SLANG_RAW("// Ray tracing\n")
SLANG_RAW("//\n")
SLANG_RAW("\n")
SLANG_RAW("public typealias rayQueryEXT = RayQuery;\n")
SLANG_RAW("\n")
SLANG_RAW("__glsl_extension(GL_EXT_ray_query)\n")
SLANG_RAW("__glsl_version(460)\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public void rayQueryConfirmIntersectionEXT(inout rayQueryEXT q)\n")
SLANG_RAW("{\n")
SLANG_RAW("    q.CommitNonOpaqueTriangleHit();\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__glsl_extension(GL_EXT_ray_query)\n")
SLANG_RAW("__glsl_version(460)\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("public bool rayQueryProceedEXT(inout rayQueryEXT q)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return q.Proceed();\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__glsl_extension(GL_EXT_ray_query)\n")
SLANG_RAW("__glsl_version(460)\n")
SLANG_RAW("[__NoSideEffect]\n")
SLANG_RAW("public uint rayQueryGetIntersectionTypeEXT(rayQueryEXT q, bool committed)\n")
SLANG_RAW("{\n")
SLANG_RAW("    if (committed)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        q.CommittedStatus();\n")
SLANG_RAW("    }\n")
SLANG_RAW("    else\n")
SLANG_RAW("    {\n")
SLANG_RAW("        q.CandidateType();\n")
SLANG_RAW("    }\n")
SLANG_RAW("    return 0;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// TODO: implementation of built-in variables; proper tests; these are stubs\n")
SLANG_RAW("// likley related to the following issue since GLSL adds new \n")
SLANG_RAW("// 'system' variables: https://github.com/shader-slang/slang/issues/411\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinType>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("void typeRequireChecks_shader_subgroup_GLSL() {\n")
SLANG_RAW("    // the following is a seperate function call, since else the `__requireGLSLExtension` and associated __intrinsic_asm is ignored if the calling function also calls an __intrinsic_asm\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        if (__type_equals<T, half>()\n")
SLANG_RAW("            || __type_equals<T, float16_t>()\n")
SLANG_RAW("            ) __requireGLSLExtension(\"GL_EXT_shader_subgroup_extended_types_float16\");\n")
SLANG_RAW("        else if (__type_equals<T, uint8_t>()\n")
SLANG_RAW("            || __type_equals<T, int8_t>()\n")
SLANG_RAW("            ) __requireGLSLExtension(\"GL_EXT_shader_subgroup_extended_types_int8\");\n")
SLANG_RAW("        else if (__type_equals<T, uint16_t>()\n")
SLANG_RAW("            || __type_equals<T, int16_t>()\n")
SLANG_RAW("            ) __requireGLSLExtension(\"GL_EXT_shader_subgroup_extended_types_int16\");\n")
SLANG_RAW("        else if (__type_equals<T, uint64_t>()\n")
SLANG_RAW("            || __type_equals<T, int64_t>()\n")
SLANG_RAW("            ) __requireGLSLExtension(\"GL_EXT_shader_subgroup_extended_types_int64\");\n")
SLANG_RAW("\n")
SLANG_RAW("        __intrinsic_asm \"\";\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinType>\n")
SLANG_RAW("void shader_subgroup_preamble() {\n")
SLANG_RAW("    // checks needed for shader_subgroup functions; __requireGLSLExtension does not work \n")
SLANG_RAW("    // (does not add the ext specified correctly to the compile output; using extended type\n")
SLANG_RAW("    // will result in error for using the type)\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        typeRequireChecks_shader_subgroup_GLSL<T>();\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return;\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("} \n")
SLANG_RAW("\n")
SLANG_RAW("// GL_KHR_shader_subgroup_basic Built-in Variables\n")
SLANG_RAW("\n")
SLANG_RAW("void requireGLSLExtForSubgroupBasicBuiltin() {\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __requireGLSLExtension(\"GL_KHR_shader_subgroup_basic\");\n")
SLANG_RAW("        __intrinsic_asm \"\";\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__spirv_version(1.3) \n")
SLANG_RAW("void setupExtForSubgroupBasicBuiltIn() {\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        requireGLSLExtForSubgroupBasicBuiltin();\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return;\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("void requireGLSLExtForSubgroupBallotBuiltin() {\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __requireGLSLExtension(\"GL_KHR_shader_subgroup_ballot\");\n")
SLANG_RAW("        __intrinsic_asm \"\";\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__spirv_version(1.3) \n")
SLANG_RAW("void setupExtForSubgroupBallotBuiltIn() {\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        requireGLSLExtForSubgroupBallotBuiltin();\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return;\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[require(glsl)]\n")
SLANG_RAW("[require(spirv)]\n")
SLANG_RAW("public property uint gl_NumSubgroups {\n")
SLANG_RAW("    \n")
SLANG_RAW("    get {\n")
SLANG_RAW("        setupExtForSubgroupBasicBuiltIn();\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case glsl:\n")
SLANG_RAW("            __intrinsic_asm \"(gl_NumSubgroups)\";\n")
SLANG_RAW("        case spirv:\n")
SLANG_RAW("            return spirv_asm {\n")
SLANG_RAW("                    OpCapability GroupNonUniform;\n")
SLANG_RAW("                    result:$$uint = OpLoad builtin(NumSubgroups:uint);\n")
SLANG_RAW("                };\n")
SLANG_RAW("        }\n")
SLANG_RAW("\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[require(glsl)]\n")
SLANG_RAW("[require(spirv)]\n")
SLANG_RAW("public property uint gl_SubgroupID\n")
SLANG_RAW("{\n")
SLANG_RAW("    get {\n")
SLANG_RAW("        setupExtForSubgroupBasicBuiltIn();\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case glsl:\n")
SLANG_RAW("            __intrinsic_asm \"(gl_SubgroupID)\";\n")
SLANG_RAW("        case spirv:\n")
SLANG_RAW("            return spirv_asm {\n")
SLANG_RAW("                        OpCapability GroupNonUniform;\n")
SLANG_RAW("                        result:$$uint = OpLoad builtin(SubgroupId:uint);\n")
SLANG_RAW("                    };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[require(glsl)]\n")
SLANG_RAW("[require(spirv)]\n")
SLANG_RAW("public property uint gl_SubgroupSize\n")
SLANG_RAW("{\n")
SLANG_RAW("    get {\n")
SLANG_RAW("        setupExtForSubgroupBasicBuiltIn();\n")
SLANG_RAW("        return WaveGetLaneCount();\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[require(glsl)]\n")
SLANG_RAW("[require(spirv)]\n")
SLANG_RAW("public property uint gl_SubgroupInvocationID\n")
SLANG_RAW("{\n")
SLANG_RAW("    get {\n")
SLANG_RAW("        setupExtForSubgroupBasicBuiltIn();\n")
SLANG_RAW("        return WaveGetLaneIndex();\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[require(glsl)]\n")
SLANG_RAW("[require(spirv)]\n")
SLANG_RAW("public property uvec4 gl_SubgroupEqMask\n")
SLANG_RAW("{\n")
SLANG_RAW("    get {\n")
SLANG_RAW("        setupExtForSubgroupBasicBuiltIn();\n")
SLANG_RAW("        setupExtForSubgroupBallotBuiltIn();\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case glsl:\n")
SLANG_RAW("            __intrinsic_asm \"(gl_SubgroupEqMask)\";\n")
SLANG_RAW("        case spirv:\n")
SLANG_RAW("            return spirv_asm {\n")
SLANG_RAW("                        OpCapability GroupNonUniformBallot;\n")
SLANG_RAW("                        result:$$uvec4 = OpLoad builtin(SubgroupEqMask:uvec4);\n")
SLANG_RAW("                    };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[require(glsl)]\n")
SLANG_RAW("[require(spirv)]\n")
SLANG_RAW("public property uvec4 gl_SubgroupGeMask\n")
SLANG_RAW("{\n")
SLANG_RAW("    get {\n")
SLANG_RAW("        setupExtForSubgroupBasicBuiltIn();\n")
SLANG_RAW("        setupExtForSubgroupBallotBuiltIn();\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case glsl:\n")
SLANG_RAW("            __intrinsic_asm \"(gl_SubgroupGeMask)\";\n")
SLANG_RAW("        case spirv:\n")
SLANG_RAW("            return spirv_asm {\n")
SLANG_RAW("                        OpCapability GroupNonUniformBallot;\n")
SLANG_RAW("                        result:$$uvec4 = OpLoad builtin(SubgroupGeMask:uvec4);\n")
SLANG_RAW("                    };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[require(glsl)]\n")
SLANG_RAW("[require(spirv)]\n")
SLANG_RAW("public property uvec4 gl_SubgroupGtMask\n")
SLANG_RAW("{\n")
SLANG_RAW("    get {\n")
SLANG_RAW("        setupExtForSubgroupBasicBuiltIn();\n")
SLANG_RAW("        setupExtForSubgroupBallotBuiltIn();\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case glsl:\n")
SLANG_RAW("            __intrinsic_asm \"(gl_SubgroupGtMask)\";\n")
SLANG_RAW("        case spirv:\n")
SLANG_RAW("            return spirv_asm {\n")
SLANG_RAW("                        OpCapability GroupNonUniformBallot;\n")
SLANG_RAW("                        result:$$uvec4 = OpLoad builtin(SubgroupGtMask:uvec4);\n")
SLANG_RAW("                    };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[require(glsl)]\n")
SLANG_RAW("[require(spirv)]\n")
SLANG_RAW("public property uvec4 gl_SubgroupLeMask\n")
SLANG_RAW("{\n")
SLANG_RAW("    get {\n")
SLANG_RAW("        setupExtForSubgroupBasicBuiltIn();\n")
SLANG_RAW("        setupExtForSubgroupBallotBuiltIn();\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case glsl:\n")
SLANG_RAW("            __intrinsic_asm \"(gl_SubgroupLeMask)\";\n")
SLANG_RAW("        case spirv:\n")
SLANG_RAW("            return spirv_asm {\n")
SLANG_RAW("                        OpCapability GroupNonUniformBallot;\n")
SLANG_RAW("                        result:$$uvec4 = OpLoad builtin(SubgroupLeMask:uvec4);\n")
SLANG_RAW("                    };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[require(glsl)]\n")
SLANG_RAW("[require(spirv)]\n")
SLANG_RAW("public property uvec4 gl_SubgroupLtMask\n")
SLANG_RAW("{\n")
SLANG_RAW("    get {\n")
SLANG_RAW("        setupExtForSubgroupBasicBuiltIn();\n")
SLANG_RAW("        setupExtForSubgroupBallotBuiltIn();\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case glsl:\n")
SLANG_RAW("            __intrinsic_asm \"(gl_SubgroupLtMask)\";\n")
SLANG_RAW("        case spirv:\n")
SLANG_RAW("            return spirv_asm {\n")
SLANG_RAW("                        OpCapability GroupNonUniformBallot;\n")
SLANG_RAW("                        result:$$uvec4 = OpLoad builtin(SubgroupLtMask:uvec4);\n")
SLANG_RAW("                    };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// GL_KHR_shader_subgroup_basic\n")
SLANG_RAW("\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_basic) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public void subgroupBarrier()\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case cuda:\n")
SLANG_RAW("        __intrinsic_asm \"__syncwarp()\";\n")
SLANG_RAW("    case hlsl:\n")
SLANG_RAW("        __intrinsic_asm \"AllMemoryBarrierWithGroupSync()\";\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"subgroupBarrier()\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        spirv_asm {\n")
SLANG_RAW("            OpCapability Shader;\n")
SLANG_RAW("            OpControlBarrier Subgroup Subgroup AcquireRelease|SubgroupMemory|ImageMemory|UniformMemory\n")
SLANG_RAW("        };\n")
SLANG_RAW("\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_basic) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public void subgroupMemoryBarrier()\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case cuda:\n")
SLANG_RAW("        __intrinsic_asm \"__threadfence_block()\";\n")
SLANG_RAW("    case hlsl:\n")
SLANG_RAW("        __intrinsic_asm \"AllMemoryBarrier()\";\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"subgroupMemoryBarrier()\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        spirv_asm {\n")
SLANG_RAW("            OpCapability Shader;\n")
SLANG_RAW("            OpMemoryBarrier Subgroup AcquireRelease|SubgroupMemory|ImageMemory|UniformMemory\n")
SLANG_RAW("        };\n")
SLANG_RAW("\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_basic) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public void subgroupMemoryBarrierBuffer()\n")
SLANG_RAW("{\n")
SLANG_RAW("    // the following implementation is NOT the same as DeviceMemoryBarrier\n")
SLANG_RAW("    // HLSL lacks the same granularity of blocking on subgroup memory within a subgroup\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case cuda:\n")
SLANG_RAW("        __intrinsic_asm \"__threadfence_block()\";\n")
SLANG_RAW("    case hlsl:\n")
SLANG_RAW("        __intrinsic_asm \"DeviceMemoryBarrier()\";\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"subgroupMemoryBarrierBuffer()\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        spirv_asm {\n")
SLANG_RAW("            OpCapability Shader;\n")
SLANG_RAW("            OpMemoryBarrier Subgroup AcquireRelease|UniformMemory\n")
SLANG_RAW("        };\n")
SLANG_RAW("\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_basic) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public void subgroupMemoryBarrierImage()\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case cuda:\n")
SLANG_RAW("        __intrinsic_asm \"__threadfence_block()\";\n")
SLANG_RAW("    case hlsl:\n")
SLANG_RAW("        __intrinsic_asm \"DeviceMemoryBarrier()\";\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"subgroupMemoryBarrierImage()\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        spirv_asm {\n")
SLANG_RAW("            OpMemoryBarrier Subgroup AcquireRelease|ImageMemory\n")
SLANG_RAW("        };\n")
SLANG_RAW("\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_basic) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public void subgroupMemoryBarrierShared()\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case cuda:\n")
SLANG_RAW("        __intrinsic_asm \"__threadfence_block()\";\n")
SLANG_RAW("    case hlsl:\n")
SLANG_RAW("        __intrinsic_asm \"GroupMemoryBarrier()\";\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"subgroupMemoryBarrierShared()\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        spirv_asm {\n")
SLANG_RAW("            // SubgroupMemory triggers vulkan validation layer error; \n")
SLANG_RAW("            // WorkgroupMemory is the next level of granularity \n")
SLANG_RAW("            OpMemoryBarrier Subgroup AcquireRelease|WorkgroupMemory\n")
SLANG_RAW("        };\n")
SLANG_RAW("\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_basic) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public bool subgroupElect()\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case cuda:\n")
SLANG_RAW("        __intrinsic_asm \"( (__activemask() & (__activemask()*-1)) == _getLaneId())\";    \n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("    case hlsl:\n")
SLANG_RAW("        return WaveIsFirstLane();\n")
SLANG_RAW("\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// GL_KHR_shader_subgroup_vote\n")
SLANG_RAW("\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_vote) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public bool subgroupAll(bool value)\n")
SLANG_RAW("{\n")
SLANG_RAW("\n")
SLANG_RAW("    return WaveActiveAllTrue(value);\n")
SLANG_RAW("\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_vote) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public bool subgroupAny(bool value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return WaveActiveAnyTrue(value);\n")
SLANG_RAW("    \n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinType>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_vote) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public bool subgroupAllEqual(T value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    shader_subgroup_preamble<T>();\n")
SLANG_RAW("    return WaveActiveAllEqual(value);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinType, let N : int>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_vote) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public bool subgroupAllEqual(vector<T,N> value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    shader_subgroup_preamble<T>();\n")
SLANG_RAW("    return WaveActiveAllEqual(value);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// GL_KHR_shader_subgroup_arithmetic\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_arithmetic) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public T subgroupAdd(T value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    shader_subgroup_preamble<T>();\n")
SLANG_RAW("    return WaveActiveSum(value);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_arithmetic) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public T subgroupMul(T value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    shader_subgroup_preamble<T>();\n")
SLANG_RAW("    return WaveActiveProduct(value);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_arithmetic) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public T subgroupMin(T value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    shader_subgroup_preamble<T>();\n")
SLANG_RAW("    return WaveActiveMin(value);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_arithmetic) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public T subgroupMax(T value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    shader_subgroup_preamble<T>();\n")
SLANG_RAW("    return WaveActiveMax(value);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinLogicalType>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_arithmetic) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public T subgroupAnd(T value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    shader_subgroup_preamble<T>();\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"subgroupAnd($0)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        if (__isBool<T>()) {\n")
SLANG_RAW("            return spirv_asm {\n")
SLANG_RAW("                OpCapability GroupNonUniformArithmetic;\n")
SLANG_RAW("                OpGroupNonUniformLogicalAnd $$T result Subgroup 0 $value\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("        else {\n")
SLANG_RAW("            return spirv_asm {\n")
SLANG_RAW("                OpCapability GroupNonUniformArithmetic;\n")
SLANG_RAW("                OpGroupNonUniformBitwiseAnd $$T result Subgroup 0 $value\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinLogicalType>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_arithmetic) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public T subgroupOr(T value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    shader_subgroup_preamble<T>();\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"subgroupOr($0)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        if (__isBool<T>()) {\n")
SLANG_RAW("            return spirv_asm {\n")
SLANG_RAW("                OpCapability GroupNonUniformArithmetic;\n")
SLANG_RAW("                OpGroupNonUniformLogicalOr $$T result Subgroup 0 $value\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("        else {\n")
SLANG_RAW("            return spirv_asm {\n")
SLANG_RAW("                OpCapability GroupNonUniformArithmetic;\n")
SLANG_RAW("                OpGroupNonUniformBitwiseOr $$T result Subgroup 0 $value\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinLogicalType>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_arithmetic) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public T subgroupXor(T value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    shader_subgroup_preamble<T>();\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"subgroupXor($0)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        if (__isBool<T>()) {\n")
SLANG_RAW("            return spirv_asm {\n")
SLANG_RAW("                OpCapability GroupNonUniformArithmetic;\n")
SLANG_RAW("                OpGroupNonUniformLogicalXor $$T result Subgroup 0 $value\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("        else {\n")
SLANG_RAW("            return spirv_asm {\n")
SLANG_RAW("                OpCapability GroupNonUniformArithmetic;\n")
SLANG_RAW("                OpGroupNonUniformBitwiseXor $$T result Subgroup 0 $value\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_arithmetic) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public T subgroupInclusiveAdd(T value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    shader_subgroup_preamble<T>();\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"subgroupInclusiveAdd($0)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        if (__isFloat<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformFAdd $$T result Subgroup InclusiveScan $value};\n")
SLANG_RAW("        else if (__isInt<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformIAdd $$T result Subgroup InclusiveScan $value};\n")
SLANG_RAW("        else return value;\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_arithmetic) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public T subgroupInclusiveMul(T value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    shader_subgroup_preamble<T>();\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"subgroupInclusiveMul($0)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        if (__isFloat<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformFMul $$T result Subgroup InclusiveScan $value};\n")
SLANG_RAW("        else if (__isInt<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformIMul $$T result Subgroup InclusiveScan $value};\n")
SLANG_RAW("        else return value;\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_arithmetic) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public T subgroupInclusiveMin(T value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    shader_subgroup_preamble<T>();\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"subgroupInclusiveMin($0)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        if (__isFloat<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformFMin $$T result Subgroup InclusiveScan $value};\n")
SLANG_RAW("        else if (__isSignedInt<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformSMin $$T result Subgroup InclusiveScan $value};\n")
SLANG_RAW("        else if (__isUnsignedInt<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformUMin $$T result Subgroup InclusiveScan $value};\n")
SLANG_RAW("        else return value;\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_arithmetic) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public T subgroupInclusiveMax(T value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    shader_subgroup_preamble<T>();\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"subgroupInclusiveMax($0)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        if (__isFloat<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformFMax $$T result Subgroup InclusiveScan $value};\n")
SLANG_RAW("        else if (__isSignedInt<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformSMax $$T result Subgroup InclusiveScan $value};\n")
SLANG_RAW("        else if (__isUnsignedInt<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformUMax $$T result Subgroup InclusiveScan $value};\n")
SLANG_RAW("        else return value;\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinLogicalType>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_arithmetic) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public T subgroupInclusiveAnd(T value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    shader_subgroup_preamble<T>();\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"subgroupInclusiveAnd($0)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        if (__isBool<T>()) {\n")
SLANG_RAW("            return spirv_asm {\n")
SLANG_RAW("                OpCapability GroupNonUniformArithmetic;\n")
SLANG_RAW("                OpGroupNonUniformLogicalAnd $$T result Subgroup InclusiveScan $value\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("        else {\n")
SLANG_RAW("            return spirv_asm {\n")
SLANG_RAW("                OpCapability GroupNonUniformArithmetic;\n")
SLANG_RAW("                OpGroupNonUniformBitwiseAnd $$T result Subgroup InclusiveScan $value\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinLogicalType>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_arithmetic) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public T subgroupInclusiveOr(T value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    shader_subgroup_preamble<T>();\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"subgroupInclusiveOr($0)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        if (__isBool<T>()) {\n")
SLANG_RAW("            return spirv_asm {\n")
SLANG_RAW("                OpCapability GroupNonUniformArithmetic;\n")
SLANG_RAW("                OpGroupNonUniformLogicalOr $$T result Subgroup InclusiveScan $value\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("        else {\n")
SLANG_RAW("            return spirv_asm {\n")
SLANG_RAW("                OpCapability GroupNonUniformArithmetic;\n")
SLANG_RAW("                OpGroupNonUniformBitwiseOr $$T result Subgroup InclusiveScan $value\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinLogicalType>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_arithmetic) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public T subgroupInclusiveXor(T value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    shader_subgroup_preamble<T>();\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"subgroupInclusiveXor($0)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        if (__isBool<T>()) return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformLogicalXor $$T result Subgroup InclusiveScan $value};\n")
SLANG_RAW("        else return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformBitwiseXor $$T result Subgroup InclusiveScan $value};\n")
SLANG_RAW("    }\n")
SLANG_RAW("    return T(0);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_arithmetic) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public T subgroupExclusiveAdd(T value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    shader_subgroup_preamble<T>();\n")
SLANG_RAW("    return WavePrefixSum(value);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_arithmetic) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public T subgroupExclusiveMul(T value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    shader_subgroup_preamble<T>();\n")
SLANG_RAW("    return WavePrefixProduct(value);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_arithmetic) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public T subgroupExclusiveMin(T value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    shader_subgroup_preamble<T>();\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"subgroupExclusiveMin($0)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        if (__isFloat<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformFMin $$T result Subgroup ExclusiveScan $value};\n")
SLANG_RAW("        else if (__isSignedInt<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformSMin $$T result Subgroup ExclusiveScan $value};\n")
SLANG_RAW("        else if (__isUnsignedInt<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformUMin $$T result Subgroup ExclusiveScan $value};\n")
SLANG_RAW("        else return value;\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_arithmetic) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public T subgroupExclusiveMax(T value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    shader_subgroup_preamble<T>();\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"subgroupExclusiveMax($0)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        if (__isFloat<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformFMax $$T result Subgroup ExclusiveScan $value};\n")
SLANG_RAW("        else if (__isSignedInt<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformSMax $$T result Subgroup ExclusiveScan $value};\n")
SLANG_RAW("        else if (__isUnsignedInt<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformUMax $$T result Subgroup ExclusiveScan $value};\n")
SLANG_RAW("        else return value;\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinLogicalType>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_arithmetic) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public T subgroupExclusiveAnd(T value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    shader_subgroup_preamble<T>();\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"subgroupExclusiveAnd($0)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        if (__isBool<T>()) return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformLogicalAnd $$T result Subgroup ExclusiveScan $value};\n")
SLANG_RAW("        else return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformBitwiseAnd $$T result Subgroup ExclusiveScan $value};\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinLogicalType>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_arithmetic) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public T subgroupExclusiveOr(T value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    shader_subgroup_preamble<T>();\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"subgroupExclusiveOr($0)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        if (__isBool<T>()) return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformLogicalOr $$T result Subgroup ExclusiveScan $value};\n")
SLANG_RAW("        else return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformBitwiseOr $$T result Subgroup ExclusiveScan $value};\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinLogicalType>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_arithmetic) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public T subgroupExclusiveXor(T value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    shader_subgroup_preamble<T>();\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"subgroupExclusiveXor($0)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        if (__isBool<T>()) return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformLogicalXor $$T result Subgroup ExclusiveScan $value};\n")
SLANG_RAW("        else return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformBitwiseXor $$T result Subgroup ExclusiveScan $value};\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// GL_KHR_shader_subgroup_arithmetic\n")
SLANG_RAW("//note: this is a seperate section because it is so huge that the only reasonable way to implement this is to just regex replace code\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_arithmetic) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public vector<T,N> subgroupAdd(vector<T,N> value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    shader_subgroup_preamble<T>();\n")
SLANG_RAW("    return WaveActiveSum(value);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_arithmetic) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public vector<T,N> subgroupMul(vector<T,N> value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    shader_subgroup_preamble<T>();\n")
SLANG_RAW("    return WaveActiveProduct(value);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_arithmetic) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public vector<T,N> subgroupMin(vector<T,N> value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    shader_subgroup_preamble<T>();\n")
SLANG_RAW("    return WaveActiveMin(value);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_arithmetic) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public vector<T,N> subgroupMax(vector<T,N> value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    shader_subgroup_preamble<T>();\n")
SLANG_RAW("    return WaveActiveMax(value);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinLogicalType, let N : int>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_arithmetic) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public vector<T,N> subgroupAnd(vector<T,N> value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    shader_subgroup_preamble<T>();\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"subgroupAnd($0)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        if (__isBool<T>()) {\n")
SLANG_RAW("            return spirv_asm {\n")
SLANG_RAW("                OpCapability GroupNonUniformArithmetic;\n")
SLANG_RAW("                OpGroupNonUniformLogicalAnd $$vector<T,N> result Subgroup 0 $value\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("        else {\n")
SLANG_RAW("            return spirv_asm {\n")
SLANG_RAW("                OpCapability GroupNonUniformArithmetic;\n")
SLANG_RAW("                OpGroupNonUniformBitwiseAnd $$vector<T,N> result Subgroup 0 $value\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinLogicalType, let N : int>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_arithmetic) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public vector<T,N> subgroupOr(vector<T,N> value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    shader_subgroup_preamble<T>();\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"subgroupOr($0)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        if (__isBool<T>()) {\n")
SLANG_RAW("            return spirv_asm {\n")
SLANG_RAW("                OpCapability GroupNonUniformArithmetic;\n")
SLANG_RAW("                OpGroupNonUniformLogicalOr $$vector<T,N> result Subgroup 0 $value\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("        else {\n")
SLANG_RAW("            return spirv_asm {\n")
SLANG_RAW("                OpCapability GroupNonUniformArithmetic;\n")
SLANG_RAW("                OpGroupNonUniformBitwiseOr $$vector<T,N> result Subgroup 0 $value\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinLogicalType, let N : int>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_arithmetic) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public vector<T,N> subgroupXor(vector<T,N> value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    shader_subgroup_preamble<T>();\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"subgroupXor($0)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        if (__isBool<T>()) {\n")
SLANG_RAW("            return spirv_asm {\n")
SLANG_RAW("                OpCapability GroupNonUniformArithmetic;\n")
SLANG_RAW("                OpGroupNonUniformLogicalXor $$vector<T,N> result Subgroup 0 $value\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("        else {\n")
SLANG_RAW("            return spirv_asm {\n")
SLANG_RAW("                OpCapability GroupNonUniformArithmetic;\n")
SLANG_RAW("                OpGroupNonUniformBitwiseXor $$vector<T,N> result Subgroup 0 $value\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_arithmetic) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public vector<T,N> subgroupInclusiveAdd(vector<T,N> value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    shader_subgroup_preamble<T>();\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"subgroupInclusiveAdd($0)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        if (__isFloat<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformFAdd $$vector<T,N> result Subgroup InclusiveScan $value};\n")
SLANG_RAW("        else if (__isInt<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformIAdd $$vector<T,N> result Subgroup InclusiveScan $value};\n")
SLANG_RAW("        else return value;\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_arithmetic) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public vector<T,N> subgroupInclusiveMul(vector<T,N> value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    shader_subgroup_preamble<T>();\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"subgroupInclusiveMul($0)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        if (__isFloat<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformFMul $$vector<T,N> result Subgroup InclusiveScan $value};\n")
SLANG_RAW("        else if (__isInt<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformIMul $$vector<T,N> result Subgroup InclusiveScan $value};\n")
SLANG_RAW("        else return value;\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_arithmetic) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public vector<T,N> subgroupInclusiveMin(vector<T,N> value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    shader_subgroup_preamble<T>();\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"subgroupInclusiveMin($0)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        if (__isFloat<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformFMin $$vector<T,N> result Subgroup InclusiveScan $value};\n")
SLANG_RAW("        else if (__isSignedInt<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformSMin $$vector<T,N> result Subgroup InclusiveScan $value};\n")
SLANG_RAW("        else if (__isUnsignedInt<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformUMin $$vector<T,N> result Subgroup InclusiveScan $value};\n")
SLANG_RAW("        else return value;\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_arithmetic) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public vector<T,N> subgroupInclusiveMax(vector<T,N> value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    shader_subgroup_preamble<T>();\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"subgroupInclusiveMax($0)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        if (__isFloat<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformFMax $$vector<T,N> result Subgroup InclusiveScan $value};\n")
SLANG_RAW("        else if (__isSignedInt<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformSMax $$vector<T,N> result Subgroup InclusiveScan $value};\n")
SLANG_RAW("        else if (__isUnsignedInt<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformUMax $$vector<T,N> result Subgroup InclusiveScan $value};\n")
SLANG_RAW("        else return value;\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinLogicalType, let N : int>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_arithmetic) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public vector<T,N> subgroupInclusiveAnd(vector<T,N> value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    shader_subgroup_preamble<T>();\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"subgroupInclusiveAnd($0)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        if (__isBool<T>()) return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformLogicalAnd $$vector<T,N> result Subgroup InclusiveScan $value};\n")
SLANG_RAW("        else return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformBitwiseAnd $$vector<T,N> result Subgroup InclusiveScan $value};\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinLogicalType, let N : int>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_arithmetic) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public vector<T,N> subgroupInclusiveOr(vector<T,N> value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    shader_subgroup_preamble<T>();\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"subgroupInclusiveOr($0)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        if (__isBool<T>()) return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformLogicalOr $$vector<T,N> result Subgroup InclusiveScan $value};\n")
SLANG_RAW("        else return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformBitwiseOr $$vector<T,N> result Subgroup InclusiveScan $value};\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinLogicalType, let N : int>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_arithmetic) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public vector<T,N> subgroupInclusiveXor(vector<T,N> value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    shader_subgroup_preamble<T>();\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"subgroupInclusiveXor($0)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        if (__isBool<T>()) return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformLogicalXor $$vector<T,N> result Subgroup InclusiveScan $value};\n")
SLANG_RAW("        else return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformBitwiseXor $$vector<T,N> result Subgroup InclusiveScan $value};\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_arithmetic) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public vector<T,N> subgroupExclusiveAdd(vector<T,N> value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    shader_subgroup_preamble<T>();\n")
SLANG_RAW("    return WavePrefixSum(value);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_arithmetic) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public vector<T,N> subgroupExclusiveMul(vector<T,N> value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    shader_subgroup_preamble<T>();\n")
SLANG_RAW("    return WavePrefixProduct(value);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_arithmetic) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public vector<T,N> subgroupExclusiveMin(vector<T,N> value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    shader_subgroup_preamble<T>();\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"subgroupExclusiveMin($0)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        if (__isFloat<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformFMin $$vector<T,N> result Subgroup ExclusiveScan $value};\n")
SLANG_RAW("        else if (__isSignedInt<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformSMin $$vector<T,N> result Subgroup ExclusiveScan $value};\n")
SLANG_RAW("        else if (__isUnsignedInt<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformUMin $$vector<T,N> result Subgroup ExclusiveScan $value};\n")
SLANG_RAW("        else return value;\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_arithmetic) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public vector<T,N> subgroupExclusiveMax(vector<T,N> value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    shader_subgroup_preamble<T>();\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"subgroupExclusiveMax($0)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        if (__isFloat<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformFMax $$vector<T,N> result Subgroup ExclusiveScan $value};\n")
SLANG_RAW("        else if (__isSignedInt<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformSMax $$vector<T,N> result Subgroup ExclusiveScan $value};\n")
SLANG_RAW("        else if (__isUnsignedInt<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformUMax $$vector<T,N> result Subgroup ExclusiveScan $value};\n")
SLANG_RAW("        else return value;\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinLogicalType, let N : int>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_arithmetic) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public vector<T,N> subgroupExclusiveAnd(vector<T,N> value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    shader_subgroup_preamble<T>();\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"subgroupExclusiveAnd($0)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        if (__isBool<T>()) return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformLogicalAnd $$vector<T,N> result Subgroup ExclusiveScan $value};\n")
SLANG_RAW("        else return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformBitwiseAnd $$vector<T,N> result Subgroup ExclusiveScan $value};\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinLogicalType, let N : int>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_arithmetic) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public vector<T,N> subgroupExclusiveOr(vector<T,N> value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    shader_subgroup_preamble<T>();\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"subgroupExclusiveOr($0)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        if (__isBool<T>()) return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformLogicalOr $$vector<T,N> result Subgroup ExclusiveScan $value};\n")
SLANG_RAW("        else return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformBitwiseOr $$vector<T,N> result Subgroup ExclusiveScan $value};\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinLogicalType, let N : int>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_arithmetic) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public vector<T,N> subgroupExclusiveXor(vector<T,N> value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    shader_subgroup_preamble<T>();\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"subgroupExclusiveXor($0)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        if (__isBool<T>()) return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformLogicalXor $$vector<T,N> result Subgroup ExclusiveScan $value};\n")
SLANG_RAW("        else return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformBitwiseXor $$vector<T,N> result Subgroup ExclusiveScan $value};\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// GL_KHR_shader_subgroup_ballot\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinType>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_ballot) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public T subgroupBroadcast(T value, uint id)\n")
SLANG_RAW("{\n")
SLANG_RAW("    shader_subgroup_preamble<T>();\n")
SLANG_RAW("    return WaveMaskBroadcastLaneAt(WaveGetActiveMask(), value, id);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinType, let N : int>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_ballot) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public vector<T,N> subgroupBroadcast(vector<T,N> value, uint id)\n")
SLANG_RAW("{\n")
SLANG_RAW("    shader_subgroup_preamble<T>();\n")
SLANG_RAW("    return WaveMaskBroadcastLaneAt(WaveGetActiveMask(), value, id);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinType>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_ballot) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public T subgroupBroadcastFirst(T value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    shader_subgroup_preamble<T>();\n")
SLANG_RAW("    return WaveMaskReadLaneFirst(WaveGetActiveMask(), value);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinType, let N : int>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_ballot) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public vector<T,N> subgroupBroadcastFirst(vector<T,N> value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    shader_subgroup_preamble<T>();\n")
SLANG_RAW("    return WaveMaskReadLaneFirst(WaveGetActiveMask(), value);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// WaveMaskBallot is not the same; it force trunc's\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_ballot) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public uvec4 subgroupBallot(bool value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return WaveActiveBallot(value);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// logic for HLSL and CUDA which lack InverseBalloc\n")
SLANG_RAW("// CUDA: works exclusivly 32 waves, therefore only need comp x\n")
SLANG_RAW("// HLSL:{\n")
SLANG_RAW("// 1. index into comp I want: index = trunc(float(lane)*(1/32))\n")
SLANG_RAW("// 2. lane & value[index]\n")
SLANG_RAW("// note: 1/32 wil be converted to multiplication\n")
SLANG_RAW("// we do 1/32 since 1 uint stores 32 threads \n")
SLANG_RAW("// note 2: we have a waveLaneCount check because based on wave lane count we can determine if we can do a \n")
SLANG_RAW("// fast path or slow path (know index is 0 or non 0)\n")
SLANG_RAW("// }\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_ballot) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public bool subgroupInverseBallot(uvec4 value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case cuda:\n")
SLANG_RAW("        // only has 32 warps\n")
SLANG_RAW("        __intrinsic_asm \"(($0).x >> (_getLaneId()) & 1)\";\n")
SLANG_RAW("    case hlsl:\n")
SLANG_RAW("        // much like _WaveCountBits, but here we hope that we hit case 0; we can then avoid the expensive logic\n")
SLANG_RAW("        const uint waveLaneCount = WaveGetLaneCount();\n")
SLANG_RAW("        switch ((waveLaneCount - 1) / 32)\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case 0:\n")
SLANG_RAW("            __intrinsic_asm \"(($0)[0] >> WaveGetLaneIndex()) & 1)\";\n")
SLANG_RAW("        case 1:\n")
SLANG_RAW("        case 2:\n")
SLANG_RAW("        case 3:\n")
SLANG_RAW("            __intrinsic_asm \"((($0)[uint(float(WaveGetLaneIndex())*0.03125f)] >> WaveGetLaneIndex()) & 1)\";\n")
SLANG_RAW("        }\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"subgroupInverseBallot($0)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm {\n")
SLANG_RAW("                OpCapability GroupNonUniformBallot; \n")
SLANG_RAW("                OpGroupNonUniformInverseBallot $$bool result Subgroup $value\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("    return false;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// same logic as subgroupInverseBallot\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_ballot) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public bool subgroupBallotBitExtract(uvec4 value, uint index)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case cuda:\n")
SLANG_RAW("        __intrinsic_asm \"($1 & ($0).x) != 0\";\n")
SLANG_RAW("    case hlsl:\n")
SLANG_RAW("        const uint waveLaneCount = WaveGetLaneCount();\n")
SLANG_RAW("        switch ((waveLaneCount - 1) / 32)\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case 0:\n")
SLANG_RAW("            __intrinsic_asm \"($0)[0] & ($1)\";\n")
SLANG_RAW("        case 1:\n")
SLANG_RAW("        case 2:\n")
SLANG_RAW("        case 3:\n")
SLANG_RAW("            __intrinsic_asm \"($0)[uint(float($1)*0.03125f)] & ($1)\";\n")
SLANG_RAW("        }\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"subgroupBallotBitExtract($0, $1)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm {\n")
SLANG_RAW("                OpCapability GroupNonUniformBallot; \n")
SLANG_RAW("                OpGroupNonUniformBallotBitExtract $$bool result Subgroup $value $index\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("    return false;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("// the count is only supposed to use uvec4 values within bottom bits of subgroup launched, not a simple countbits\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_ballot) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public uint subgroupBallotBitCount(uvec4 value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"subgroupBallotBitCount($0)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm {\n")
SLANG_RAW("            OpCapability GroupNonUniformBallot; \n")
SLANG_RAW("            OpGroupNonUniformBallotBitCount $$uint result Subgroup Reduce $value\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_ballot) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public uint subgroupBallotInclusiveBitCount(uvec4 value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"subgroupBallotInclusiveBitCount($0)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm {\n")
SLANG_RAW("            OpCapability GroupNonUniformBallot; \n")
SLANG_RAW("            OpGroupNonUniformBallotBitCount $$uint result Subgroup InclusiveScan $value\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_ballot) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public uint subgroupBallotExclusiveBitCount(uvec4 value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"subgroupBallotExclusiveBitCount($0)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm {\n")
SLANG_RAW("            OpCapability GroupNonUniformBallot; \n")
SLANG_RAW("            OpGroupNonUniformBallotBitCount $$uint result Subgroup ExclusiveScan $value\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_ballot) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public uint subgroupBallotFindLSB(uvec4 value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"subgroupBallotFindLSB($0)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm {\n")
SLANG_RAW("            OpCapability GroupNonUniformBallot; \n")
SLANG_RAW("            OpGroupNonUniformBallotFindLSB $$uint result Subgroup $value\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_ballot) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public uint subgroupBallotFindMSB(uvec4 value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"subgroupBallotFindMSB($0)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm {\n")
SLANG_RAW("            OpCapability GroupNonUniformBallot; \n")
SLANG_RAW("            OpGroupNonUniformBallotFindMSB $$uint result Subgroup $value\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// GL_KHR_shader_subgroup_shuffle\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinType>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_shuffle) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public T subgroupShuffle(T value, uint index)\n")
SLANG_RAW("{\n")
SLANG_RAW("    shader_subgroup_preamble<T>();\n")
SLANG_RAW("    return WaveShuffle(value, index);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinType>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_shuffle) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public T subgroupShuffleXor(T value, uint mask)\n")
SLANG_RAW("{\n")
SLANG_RAW("    shader_subgroup_preamble<T>();\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"subgroupShuffleXor($0,$1)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm {\n")
SLANG_RAW("            OpCapability GroupNonUniformBallot; \n")
SLANG_RAW("            OpGroupNonUniformShuffleXor $$T result Subgroup $value $mask\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinType, let N : int>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_shuffle) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public vector<T,N> subgroupShuffle(vector<T,N> value, uint index)\n")
SLANG_RAW("{\n")
SLANG_RAW("    shader_subgroup_preamble<T>();\n")
SLANG_RAW("    return WaveShuffle(value, index);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinType, let N : int>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_shuffle) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public vector<T,N> subgroupShuffleXor(vector<T,N> value, uint mask)\n")
SLANG_RAW("{\n")
SLANG_RAW("    shader_subgroup_preamble<T>();\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"subgroupShuffleXor($0,$1)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm {\n")
SLANG_RAW("            OpCapability GroupNonUniformBallot; \n")
SLANG_RAW("            OpGroupNonUniformShuffleXor $$vector<T,N> result Subgroup $value $mask\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("// GL_KHR_shader_subgroup_shuffle_relative\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinType>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_shuffle_relative) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public T subgroupShuffleUp(T value, uint delta)\n")
SLANG_RAW("{\n")
SLANG_RAW("    shader_subgroup_preamble<T>();\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"subgroupShuffleUp($0, $1)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm {\n")
SLANG_RAW("            OpCapability GroupNonUniformShuffleRelative;\n")
SLANG_RAW("            OpGroupNonUniformShuffleUp $$T result Subgroup $value $delta\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinType>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_shuffle_relative) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public T subgroupShuffleDown(T value, uint delta)\n")
SLANG_RAW("{\n")
SLANG_RAW("    shader_subgroup_preamble<T>();\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"subgroupShuffleDown($0, $1)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm {\n")
SLANG_RAW("            OpCapability GroupNonUniformShuffleRelative; \n")
SLANG_RAW("            OpGroupNonUniformShuffleDown $$T result Subgroup $value $delta\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinType, let N : int>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_shuffle_relative) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public vector<T,N> subgroupShuffleUp(vector<T,N> value, uint delta)\n")
SLANG_RAW("{\n")
SLANG_RAW("    shader_subgroup_preamble<T>();\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"subgroupShuffleUp($0, $1)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm {\n")
SLANG_RAW("            OpCapability GroupNonUniformShuffleRelative;\n")
SLANG_RAW("            OpGroupNonUniformShuffleUp $$vector<T,N> result Subgroup $value $delta\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinType, let N : int>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_shuffle_relative) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public vector<T,N> subgroupShuffleDown(vector<T,N> value, uint delta)\n")
SLANG_RAW("{\n")
SLANG_RAW("    shader_subgroup_preamble<T>();\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"subgroupShuffleDown($0, $1)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm {\n")
SLANG_RAW("            OpCapability GroupNonUniformShuffleRelative;\n")
SLANG_RAW("            OpGroupNonUniformShuffleDown $$vector<T,N> result Subgroup $value $delta\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("// GL_KHR_shader_subgroup_clustered\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_clustered) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public T subgroupClusteredAdd(T value, uint clusterSize)\n")
SLANG_RAW("{\n")
SLANG_RAW("    shader_subgroup_preamble<T>();\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"subgroupClusteredAdd($0, $1)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        if (__isFloat<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpCapability GroupNonUniformClustered; OpGroupNonUniformFAdd $$T result Subgroup ClusteredReduce $value $clusterSize};\n")
SLANG_RAW("        else if (__isInt<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpCapability GroupNonUniformClustered; OpGroupNonUniformIAdd $$T result Subgroup ClusteredReduce $value $clusterSize};\n")
SLANG_RAW("        else return value;\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_clustered) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public T subgroupClusteredMul(T value, uint clusterSize)\n")
SLANG_RAW("{\n")
SLANG_RAW("    shader_subgroup_preamble<T>();\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"subgroupClusteredMul($0, $1)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        if (__isFloat<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpCapability GroupNonUniformClustered; OpGroupNonUniformFMul $$T result Subgroup ClusteredReduce $value $clusterSize};\n")
SLANG_RAW("        else if (__isInt<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpCapability GroupNonUniformClustered; OpGroupNonUniformIMul $$T result Subgroup ClusteredReduce $value $clusterSize};\n")
SLANG_RAW("        else return value;\n")
SLANG_RAW("    } \n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_clustered) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public T subgroupClusteredMin(T value, uint clusterSize)\n")
SLANG_RAW("{\n")
SLANG_RAW("    shader_subgroup_preamble<T>();\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"subgroupClusteredMin($0, $1)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        if (__isFloat<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpCapability GroupNonUniformClustered; OpGroupNonUniformFMin $$T result Subgroup ClusteredReduce $value $clusterSize};\n")
SLANG_RAW("        else if (__isSignedInt<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpCapability GroupNonUniformClustered; OpGroupNonUniformSMin $$T result Subgroup ClusteredReduce $value $clusterSize};\n")
SLANG_RAW("        else if (__isUnsignedInt<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpCapability GroupNonUniformClustered; OpGroupNonUniformUMin $$T result Subgroup ClusteredReduce $value $clusterSize};\n")
SLANG_RAW("        else return value;\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_clustered) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public T subgroupClusteredMax(T value, uint clusterSize)\n")
SLANG_RAW("{\n")
SLANG_RAW("    shader_subgroup_preamble<T>();\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"subgroupClusteredMax($0, $1)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        if (__isFloat<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpCapability GroupNonUniformClustered; OpGroupNonUniformFMax $$T result Subgroup ClusteredReduce $value $clusterSize};\n")
SLANG_RAW("        else if (__isSignedInt<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpCapability GroupNonUniformClustered; OpGroupNonUniformSMax $$T result Subgroup ClusteredReduce $value $clusterSize};\n")
SLANG_RAW("        else if (__isUnsignedInt<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpCapability GroupNonUniformClustered;  OpGroupNonUniformUMax $$T result Subgroup ClusteredReduce $value $clusterSize};\n")
SLANG_RAW("        else return value;\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinLogicalType>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_clustered) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public T subgroupClusteredAnd(T value, uint clusterSize)\n")
SLANG_RAW("{\n")
SLANG_RAW("    shader_subgroup_preamble<T>();\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"subgroupClusteredAnd($0, $1)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        if (__isBool<T>()) return spirv_asm {OpCapability GroupNonUniformArithmetic; OpCapability GroupNonUniformClustered; OpGroupNonUniformLogicalAnd $$T result Subgroup ClusteredReduce $value $clusterSize};\n")
SLANG_RAW("        else return spirv_asm {OpCapability GroupNonUniformArithmetic; OpCapability GroupNonUniformClustered; OpGroupNonUniformBitwiseAnd $$T result Subgroup ClusteredReduce $value $clusterSize};\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinLogicalType>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_clustered) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public T subgroupClusteredOr(T value, uint clusterSize)\n")
SLANG_RAW("{\n")
SLANG_RAW("    shader_subgroup_preamble<T>();\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"subgroupClusteredOr($0, $1)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        if (__isBool<T>()) return spirv_asm {OpCapability GroupNonUniformArithmetic; OpCapability GroupNonUniformClustered; OpGroupNonUniformLogicalOr $$T result Subgroup ClusteredReduce $value $clusterSize};\n")
SLANG_RAW("        else return spirv_asm {OpCapability GroupNonUniformArithmetic; OpCapability GroupNonUniformClustered; OpGroupNonUniformBitwiseOr $$T result Subgroup ClusteredReduce $value $clusterSize};\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinLogicalType>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_clustered) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public T subgroupClusteredXor(T value, uint clusterSize)\n")
SLANG_RAW("{\n")
SLANG_RAW("    shader_subgroup_preamble<T>();\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"subgroupClusteredXor($0, $1)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        if (__isBool<T>()) return spirv_asm {OpCapability GroupNonUniformArithmetic; OpCapability GroupNonUniformClustered; OpGroupNonUniformLogicalXor $$T result Subgroup ClusteredReduce $value $clusterSize};\n")
SLANG_RAW("        else return spirv_asm {OpCapability GroupNonUniformArithmetic; OpCapability GroupNonUniformClustered; OpGroupNonUniformBitwiseXor $$T result Subgroup ClusteredReduce $value $clusterSize};\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_clustered) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public vector<T,N> subgroupClusteredAdd(vector<T,N> value, uint clusterSize)\n")
SLANG_RAW("{\n")
SLANG_RAW("    shader_subgroup_preamble<T>();\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"subgroupClusteredAdd($0, $1)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        if (__isFloat<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpCapability GroupNonUniformClustered; \n")
SLANG_RAW("            OpGroupNonUniformFAdd $$vector<T,N> result Subgroup ClusteredReduce $value $clusterSize};\n")
SLANG_RAW("        else if (__isInt<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpCapability GroupNonUniformClustered; OpGroupNonUniformIAdd $$vector<T,N> result Subgroup ClusteredReduce $value $clusterSize};\n")
SLANG_RAW("        else return value;\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_clustered) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public vector<T,N> subgroupClusteredMul(vector<T,N> value, uint clusterSize)\n")
SLANG_RAW("{\n")
SLANG_RAW("    shader_subgroup_preamble<T>();\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"subgroupClusteredMul($0, $1)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        if (__isFloat<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpCapability GroupNonUniformClustered; OpGroupNonUniformFMul $$vector<T,N> result Subgroup ClusteredReduce $value $clusterSize};\n")
SLANG_RAW("        else if (__isInt<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpCapability GroupNonUniformClustered; OpGroupNonUniformIMul $$vector<T,N> result Subgroup ClusteredReduce $value $clusterSize};\n")
SLANG_RAW("        else return value;\n")
SLANG_RAW("    } \n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_clustered) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public vector<T,N> subgroupClusteredMin(vector<T,N> value, uint clusterSize)\n")
SLANG_RAW("{\n")
SLANG_RAW("    shader_subgroup_preamble<T>();\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"subgroupClusteredMin($0, $1)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        if (__isFloat<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpCapability GroupNonUniformClustered; OpGroupNonUniformFMin $$vector<T,N> result Subgroup ClusteredReduce $value $clusterSize};\n")
SLANG_RAW("        else if (__isSignedInt<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpCapability GroupNonUniformClustered; OpGroupNonUniformSMin $$vector<T,N> result Subgroup ClusteredReduce $value $clusterSize};\n")
SLANG_RAW("        else if (__isUnsignedInt<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpCapability GroupNonUniformClustered; OpGroupNonUniformUMin $$vector<T,N> result Subgroup ClusteredReduce $value $clusterSize};\n")
SLANG_RAW("        else return value;\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_clustered) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public vector<T,N> subgroupClusteredMax(vector<T,N> value, uint clusterSize)\n")
SLANG_RAW("{\n")
SLANG_RAW("    shader_subgroup_preamble<T>();\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"subgroupClusteredMax($0, $1)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        if (__isFloat<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpCapability GroupNonUniformClustered; OpGroupNonUniformFMax $$vector<T,N> result Subgroup ClusteredReduce $value $clusterSize};\n")
SLANG_RAW("        else if (__isSignedInt<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpCapability GroupNonUniformClustered; OpGroupNonUniformSMax $$vector<T,N> result Subgroup ClusteredReduce $value $clusterSize};\n")
SLANG_RAW("        else if (__isUnsignedInt<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpCapability GroupNonUniformClustered;  OpGroupNonUniformUMax $$vector<T,N> result Subgroup ClusteredReduce $value $clusterSize};\n")
SLANG_RAW("        else return value;\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinLogicalType, let N : int>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_clustered) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public vector<T,N> subgroupClusteredAnd(vector<T,N> value, uint clusterSize)\n")
SLANG_RAW("{\n")
SLANG_RAW("    shader_subgroup_preamble<T>();\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"subgroupClusteredAnd($0, $1)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        if (__isBool<T>()) return spirv_asm {OpCapability GroupNonUniformArithmetic; OpCapability GroupNonUniformClustered; OpGroupNonUniformLogicalAnd $$vector<T,N> result Subgroup ClusteredReduce $value $clusterSize};\n")
SLANG_RAW("        else return spirv_asm {OpCapability GroupNonUniformArithmetic; OpCapability GroupNonUniformClustered; OpGroupNonUniformBitwiseAnd $$vector<T,N> result Subgroup ClusteredReduce $value $clusterSize};\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinLogicalType, let N : int>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_clustered) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public vector<T,N> subgroupClusteredOr(vector<T,N> value, uint clusterSize)\n")
SLANG_RAW("{\n")
SLANG_RAW("    shader_subgroup_preamble<T>();\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"subgroupClusteredOr($0, $1)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        if (__isBool<T>()) return spirv_asm {OpCapability GroupNonUniformArithmetic; OpCapability GroupNonUniformClustered; OpGroupNonUniformLogicalOr $$vector<T,N> result Subgroup ClusteredReduce $value $clusterSize};\n")
SLANG_RAW("        else return spirv_asm {OpCapability GroupNonUniformArithmetic; OpCapability GroupNonUniformClustered; OpGroupNonUniformBitwiseOr $$vector<T,N> result Subgroup ClusteredReduce $value $clusterSize};\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinLogicalType, let N : int>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_clustered) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public vector<T,N> subgroupClusteredXor(vector<T,N> value, uint clusterSize)\n")
SLANG_RAW("{\n")
SLANG_RAW("    shader_subgroup_preamble<T>();\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"subgroupClusteredXor($0, $1)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        if (__isBool<T>()) return spirv_asm {OpCapability GroupNonUniformArithmetic; OpCapability GroupNonUniformClustered; OpGroupNonUniformLogicalXor $$vector<T,N> result Subgroup ClusteredReduce $value $clusterSize};\n")
SLANG_RAW("        else return spirv_asm {OpCapability GroupNonUniformArithmetic; OpCapability GroupNonUniformClustered; OpGroupNonUniformBitwiseXor $$vector<T,N> result Subgroup ClusteredReduce $value $clusterSize};\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// GL_KHR_shader_subgroup_quad\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinType>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_quad) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public T subgroupQuadBroadcast(T value, uint id)\n")
SLANG_RAW("{\n")
SLANG_RAW("    shader_subgroup_preamble<T>();\n")
SLANG_RAW("    return QuadReadLaneAt(value, id);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinType>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_quad) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public T subgroupQuadSwapHorizontal(T value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    shader_subgroup_preamble<T>();\n")
SLANG_RAW("    return QuadReadAcrossX(value);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinType>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_quad) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public T subgroupQuadSwapVertical(T value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    shader_subgroup_preamble<T>();\n")
SLANG_RAW("    return QuadReadAcrossY(value);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinType>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_quad) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public T subgroupQuadSwapDiagonal(T value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    shader_subgroup_preamble<T>();\n")
SLANG_RAW("    return QuadReadAcrossDiagonal(value);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinType, let N : int>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_quad) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public vector<T,N> subgroupQuadBroadcast(vector<T,N> value, uint id)\n")
SLANG_RAW("{\n")
SLANG_RAW("    shader_subgroup_preamble<T>();\n")
SLANG_RAW("    return QuadReadLaneAt(value, id);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinType, let N : int>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_quad) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public vector<T,N> subgroupQuadSwapHorizontal(vector<T,N> value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    shader_subgroup_preamble<T>();\n")
SLANG_RAW("    return QuadReadAcrossX(value);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinType, let N : int>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_quad) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public vector<T,N> subgroupQuadSwapVertical(vector<T,N> value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    shader_subgroup_preamble<T>();\n")
SLANG_RAW("    return QuadReadAcrossY(value);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinType, let N : int>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_quad) [require(glsl)] \n")
SLANG_RAW("__spirv_version(1.3) [require(spirv)]\n")
SLANG_RAW("[ForceInline] public vector<T,N> subgroupQuadSwapDiagonal(vector<T,N> value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    shader_subgroup_preamble<T>();\n")
SLANG_RAW("    return QuadReadAcrossDiagonal(value);\n")
SLANG_RAW("}")
