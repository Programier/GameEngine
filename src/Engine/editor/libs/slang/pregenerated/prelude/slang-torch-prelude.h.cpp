// generated code; do not edit
#include "../source/core/slang-basic.h"
Slang::String get_slang_torch_prelude()
{
Slang::StringBuilder sb;
sb << 
"// Prelude for PyTorch cpp binding.\n"
"\n"
"#include <torch/extension.h>\n"
"#include <ATen/cuda/CUDAContext.h>\n"
"#include <ATen/cuda/CUDAUtils.h>\n"
"#include <vector>\n"
"#include <stdexcept>\n"
"#include <string>\n"
"\n"
"#ifdef SLANG_LLVM\n"
"#ifndef SLANG_LLVM_H\n"
"#define SLANG_LLVM_H\n"
"\n"
"// TODO(JS): \n"
"// Disable exception declspecs, as not supported on LLVM without some extra options.\n"
"// We could enable with `-fms-extensions`\n"
"#define SLANG_DISABLE_EXCEPTIONS 1\n"
"\n"
"#ifndef SLANG_PRELUDE_ASSERT\n"
"#   ifdef SLANG_PRELUDE_ENABLE_ASSERT\n"
"extern \"C\" void assertFailure(const char* msg);\n"
"#       define SLANG_PRELUDE_EXPECT(VALUE, MSG) if(VALUE) {} else assertFailure(\"assertion failed: '\" MSG \"'\")\n"
"#       define SLANG_PRELUDE_ASSERT(VALUE) SLANG_PRELUDE_EXPECT(VALUE, #VALUE)\n"
"#   else // SLANG_PRELUDE_ENABLE_ASSERT\n"
"#       define SLANG_PRELUDE_EXPECT(VALUE, MSG)\n"
"#       define SLANG_PRELUDE_ASSERT(x) \n"
"#   endif // SLANG_PRELUDE_ENABLE_ASSERT\n"
"#endif\n"
"\n"
"/*\n"
"Taken from stddef.h \n"
"*/\n"
"\n"
"typedef __PTRDIFF_TYPE__ ptrdiff_t;\n"
"typedef __SIZE_TYPE__ size_t;\n"
"typedef __SIZE_TYPE__ rsize_t;\n"
"\n"
"//typedef __WCHAR_TYPE__ wchar_t;\n"
"\n"
"#if defined(__need_NULL)\n"
"#undef NULL\n"
"#ifdef __cplusplus\n"
"#  if !defined(__MINGW32__) && !defined(_MSC_VER)\n"
"#    define NULL __null\n"
"#  else\n"
"#    define NULL 0\n"
"#  endif\n"
"#else\n"
"#  define NULL ((void*)0)\n"
"#endif\n"
"#ifdef __cplusplus\n"
"#if defined(_MSC_EXTENSIONS) && defined(_NATIVE_NULLPTR_SUPPORTED)\n"
"namespace std { typedef decltype(nullptr) nullptr_t; }\n"
"using ::std::nullptr_t;\n"
"#endif\n"
"#endif\n"
"#undef __need_NULL\n"
"#endif /* defined(__need_NULL) */\n"
"\n"
"\n"
"/*\n"
"The following are taken verbatim from stdint.h from Clang in LLVM. Only 8/16/32/64 types are needed. \n"
"*/\n"
"\n"
"// LLVM/Clang types such that we can use LLVM/Clang without headers for C++ output from Slang\n"
"\n"
"#ifdef __INT64_TYPE__\n"
"# ifndef __int8_t_defined /* glibc sys/types.h also defines int64_t*/\n"
"typedef __INT64_TYPE__ int64_t;\n"
"# endif /* __int8_t_defined */\n"
"typedef __UINT64_TYPE__ uint64_t;\n"
"# define __int_least64_t int64_t\n"
"# define __uint_least64_t uint64_t\n"
"#endif /* __INT64_TYPE__ */\n"
"\n"
"#ifdef __int_least64_t\n"
"typedef __int_least64_t int_least64_t;\n"
"typedef __uint_least64_t uint_least64_t;\n"
"typedef __int_least64_t int_fast64_t;\n"
"typedef __uint_least64_t uint_fast64_t;\n"
"#endif /* __int_least64_t */\n"
"\n"
"#ifdef __INT32_TYPE__\n"
"\n"
"# ifndef __int8_t_defined /* glibc sys/types.h also defines int32_t*/\n"
"typedef __INT32_TYPE__ int32_t;\n"
"# endif /* __int8_t_defined */\n"
"\n"
"# ifndef __uint32_t_defined  /* more glibc compatibility */\n"
"# define __uint32_t_defined\n"
"typedef __UINT32_TYPE__ uint32_t;\n"
"# endif /* __uint32_t_defined */\n"
"\n"
"# define __int_least32_t int32_t\n"
"# define __uint_least32_t uint32_t\n"
"#endif /* __INT32_TYPE__ */\n"
"\n"
"#ifdef __int_least32_t\n"
"typedef __int_least32_t int_least32_t;\n"
"typedef __uint_least32_t uint_least32_t;\n"
"typedef __int_least32_t int_fast32_t;\n"
"typedef __uint_least32_t uint_fast32_t;\n"
"#endif /* __int_least32_t */\n"
"\n"
"#ifdef __INT16_TYPE__\n"
"#ifndef __int8_t_defined /* glibc sys/types.h also defines int16_t*/\n"
"typedef __INT16_TYPE__ int16_t;\n"
"#endif /* __int8_t_defined */\n"
"typedef __UINT16_TYPE__ uint16_t;\n"
"# define __int_least16_t int16_t\n"
"# define __uint_least16_t uint16_t\n"
"#endif /* __INT16_TYPE__ */\n"
"\n"
"#ifdef __int_least16_t\n"
"typedef __int_least16_t int_least16_t;\n"
"typedef __uint_least16_t uint_least16_t;\n"
"typedef __int_least16_t int_fast16_t;\n"
"typedef __uint_least16_t uint_fast16_t;\n"
"#endif /* __int_least16_t */\n"
"\n"
"#ifdef __INT8_TYPE__\n"
"#ifndef __int8_t_defined  /* glibc sys/types.h also defines int8_t*/\n"
"typedef __INT8_TYPE__ int8_t;\n"
"#endif /* __int8_t_defined */\n"
"typedef __UINT8_TYPE__ uint8_t;\n"
"# define __int_least8_t int8_t\n"
"# define __uint_least8_t uint8_t\n"
"#endif /* __INT8_TYPE__ */\n"
"\n"
"#ifdef __int_least8_t\n"
"typedef __int_least8_t int_least8_t;\n"
"typedef __uint_least8_t uint_least8_t;\n"
"typedef __int_least8_t int_fast8_t;\n"
"typedef __uint_least8_t uint_fast8_t;\n"
"#endif /* __int_least8_t */\n"
"\n"
"/* prevent glibc sys/types.h from defining conflicting types */\n"
"#ifndef __int8_t_defined\n"
"# define __int8_t_defined\n"
"#endif /* __int8_t_defined */\n"
"\n"
"/* C99 7.18.1.4 Integer types capable of holding object pointers.\n"
" */\n"
"#define __stdint_join3(a,b,c) a ## b ## c\n"
"\n"
"#ifndef _INTPTR_T\n"
"#ifndef __intptr_t_defined\n"
"typedef __INTPTR_TYPE__ intptr_t;\n"
"#define __intptr_t_defined\n"
"#define _INTPTR_T\n"
"#endif\n"
"#endif\n"
"\n"
"#ifndef _UINTPTR_T\n"
"typedef __UINTPTR_TYPE__ uintptr_t;\n"
"#define _UINTPTR_T\n"
"#endif\n"
"\n"
"/* C99 7.18.1.5 Greatest-width integer types.\n"
" */\n"
"typedef __INTMAX_TYPE__  intmax_t;\n"
"typedef __UINTMAX_TYPE__ uintmax_t;\n"
"\n"
"/* C99 7.18.4 Macros for minimum-width integer constants.\n"
" *\n"
" * The standard requires that integer constant macros be defined for all the\n"
" * minimum-width types defined above. As 8-, 16-, 32-, and 64-bit minimum-width\n"
" * types are required, the corresponding integer constant macros are defined\n"
" * here. This implementation also defines minimum-width types for every other\n"
" * integer width that the target implements, so corresponding macros are\n"
" * defined below, too.\n"
" *\n"
" * These macros are defined using the same successive-shrinking approach as\n"
" * the type definitions above. It is likewise important that macros are defined\n"
" * in order of decending width.\n"
" *\n"
" * Note that C++ should not check __STDC_CONSTANT_MACROS here, contrary to the\n"
" * claims of the C standard (see C++ 18.3.1p2, [cstdint.syn]).\n"
" */\n"
"\n"
"#define __int_c_join(a, b) a ## b\n"
"#define __int_c(v, suffix) __int_c_join(v, suffix)\n"
"#define __uint_c(v, suffix) __int_c_join(v##U, suffix)\n"
"\n"
"#ifdef __INT64_TYPE__\n"
"# ifdef __INT64_C_SUFFIX__\n"
"#  define __int64_c_suffix __INT64_C_SUFFIX__\n"
"# else\n"
"#  undef __int64_c_suffix\n"
"# endif /* __INT64_C_SUFFIX__ */\n"
"#endif /* __INT64_TYPE__ */\n"
"\n"
"#ifdef __int_least64_t\n"
"# ifdef __int64_c_suffix\n"
"#  define INT64_C(v) __int_c(v, __int64_c_suffix)\n"
"#  define UINT64_C(v) __uint_c(v, __int64_c_suffix)\n"
"# else\n"
"#  define INT64_C(v) v\n"
"#  define UINT64_C(v) v ## U\n"
"# endif /* __int64_c_suffix */\n"
"#endif /* __int_least64_t */\n"
"\n"
"\n"
"#ifdef __INT32_TYPE__\n"
"# ifdef __INT32_C_SUFFIX__\n"
"#  define __int32_c_suffix __INT32_C_SUFFIX__\n"
"#else\n"
"#  undef __int32_c_suffix\n"
"# endif /* __INT32_C_SUFFIX__ */\n"
"#endif /* __INT32_TYPE__ */\n"
"\n"
"#ifdef __int_least32_t\n"
"# ifdef __int32_c_suffix\n"
"#  define INT32_C(v) __int_c(v, __int32_c_suffix)\n"
"#  define UINT32_C(v) __uint_c(v, __int32_c_suffix)\n"
"# else\n"
"#  define INT32_C(v) v\n"
"#  define UINT32_C(v) v ## U\n"
"# endif /* __int32_c_suffix */\n"
"#endif /* __int_least32_t */\n"
"\n"
"#ifdef __INT16_TYPE__\n"
"# ifdef __INT16_C_SUFFIX__\n"
"#  define __int16_c_suffix __INT16_C_SUFFIX__\n"
"#else\n"
"#  undef __int16_c_suffix\n"
"# endif /* __INT16_C_SUFFIX__ */\n"
"#endif /* __INT16_TYPE__ */\n"
"\n"
"#ifdef __int_least16_t\n"
"# ifdef __int16_c_suffix\n"
"#  define INT16_C(v) __int_c(v, __int16_c_suffix)\n"
"#  define UINT16_C(v) __uint_c(v, __int16_c_suffix)\n"
"# else\n"
"#  define INT16_C(v) v\n"
"#  define UINT16_C(v) v ## U\n"
"# endif /* __int16_c_suffix */\n"
"#endif /* __int_least16_t */\n"
"\n"
"\n"
"#ifdef __INT8_TYPE__\n"
"# ifdef __INT8_C_SUFFIX__\n"
"#  define __int8_c_suffix __INT8_C_SUFFIX__\n"
"#else\n"
"#  undef  __int8_c_suffix\n"
"# endif /* __INT8_C_SUFFIX__ */\n"
"#endif /* __INT8_TYPE__ */\n"
"\n"
"#ifdef __int_least8_t\n"
"# ifdef __int8_c_suffix\n"
"#  define INT8_C(v) __int_c(v, __int8_c_suffix)\n"
"#  define UINT8_C(v) __uint_c(v, __int8_c_suffix)\n"
"# else\n"
"#  define INT8_C(v) v\n"
"#  define UINT8_C(v) v ## U\n"
"# endif /* __int8_c_suffix */\n"
"#endif /* __int_least8_t */\n"
"\n"
"/* C99 7.18.2.1 Limits of exact-width integer types.\n"
" * C99 7.18.2.2 Limits of minimum-width integer types.\n"
" * C99 7.18.2.3 Limits of fastest minimum-width integer types.\n"
" *\n"
" * The presence of limit macros are completely optional in C99.  This\n"
" * implementation defines limits for all of the types (exact- and\n"
" * minimum-width) that it defines above, using the limits of the minimum-width\n"
" * type for any types that do not have exact-width representations.\n"
" *\n"
" * As in the type definitions, this section takes an approach of\n"
" * successive-shrinking to determine which limits to use for the standard (8,\n"
" * 16, 32, 64) bit widths when they don't have exact representations. It is\n"
" * therefore important that the definitions be kept in order of decending\n"
" * widths.\n"
" *\n"
" * Note that C++ should not check __STDC_LIMIT_MACROS here, contrary to the\n"
" * claims of the C standard (see C++ 18.3.1p2, [cstdint.syn]).\n"
" */\n"
"\n"
"#ifdef __INT64_TYPE__\n"
"# define INT64_MAX           INT64_C( 9223372036854775807)\n"
"# define INT64_MIN         (-INT64_C( 9223372036854775807)-1)\n"
"# define UINT64_MAX         UINT64_C(18446744073709551615)\n"
"# define __INT_LEAST64_MIN   INT64_MIN\n"
"# define __INT_LEAST64_MAX   INT64_MAX\n"
"# define __UINT_LEAST64_MAX UINT64_MAX\n"
"#endif /* __INT64_TYPE__ */\n"
"\n"
"#ifdef __INT_LEAST64_MIN\n"
"# define INT_LEAST64_MIN   __INT_LEAST64_MIN\n"
"# define INT_LEAST64_MAX   __INT_LEAST64_MAX\n"
"# define UINT_LEAST64_MAX __UINT_LEAST64_MAX\n"
"# define INT_FAST64_MIN    __INT_LEAST64_MIN\n"
"# define INT_FAST64_MAX    __INT_LEAST64_MAX\n"
"# define UINT_FAST64_MAX  __UINT_LEAST64_MAX\n"
"#endif /* __INT_LEAST64_MIN */\n"
"\n"
"#ifdef __INT32_TYPE__\n"
"# define INT32_MAX           INT32_C(2147483647)\n"
"# define INT32_MIN         (-INT32_C(2147483647)-1)\n"
"# define UINT32_MAX         UINT32_C(4294967295)\n"
"# define __INT_LEAST32_MIN   INT32_MIN\n"
"# define __INT_LEAST32_MAX   INT32_MAX\n"
"# define __UINT_LEAST32_MAX UINT32_MAX\n"
"#endif /* __INT32_TYPE__ */\n"
"\n"
"#ifdef __INT_LEAST32_MIN\n"
"# define INT_LEAST32_MIN   __INT_LEAST32_MIN\n"
"# define INT_LEAST32_MAX   __INT_LEAST32_MAX\n"
"# define UINT_LEAST32_MAX __UINT_LEAST32_MAX\n"
"# define INT_FAST32_MIN    __INT_LEAST32_MIN\n"
"# define INT_FAST32_MAX    __INT_LEAST32_MAX\n"
"# define UINT_FAST32_MAX  __UINT_LEAST32_MAX\n"
"#endif /* __INT_LEAST32_MIN */\n"
"\n"
"#ifdef __INT16_TYPE__\n"
"#define INT16_MAX            INT16_C(32767)\n"
"#define INT16_MIN          (-INT16_C(32767)-1)\n"
"#define UINT16_MAX          UINT16_C(65535)\n"
"# define __INT_LEAST16_MIN   INT16_MIN\n"
"# define __INT_LEAST16_MAX   INT16_MAX\n"
"# define __UINT_LEAST16_MAX UINT16_MAX\n"
"#endif /* __INT16_TYPE__ */\n"
"\n"
"#ifdef __INT_LEAST16_MIN\n"
"# define INT_LEAST16_MIN   __INT_LEAST16_MIN\n"
"# define INT_LEAST16_MAX   __INT_LEAST16_MAX\n"
"# define UINT_LEAST16_MAX __UINT_LEAST16_MAX\n"
"# define INT_FAST16_MIN    __INT_LEAST16_MIN\n"
"# define INT_FAST16_MAX    __INT_LEAST16_MAX\n"
"# define UINT_FAST16_MAX  __UINT_LEAST16_MAX\n"
"#endif /* __INT_LEAST16_MIN */\n"
"\n"
"\n"
"#ifdef __INT8_TYPE__\n"
"# define INT8_MAX            INT8_C(127)\n"
"# define INT8_MIN          (-INT8_C(127)-1)\n"
"# define UINT8_MAX          UINT8_C(255)\n"
"# define __INT_LEAST8_MIN    INT8_MIN\n"
"# define __INT_LEAST8_MAX    INT8_MAX\n"
"# define __UINT_LEAST8_MAX  UINT8_MAX\n"
"#endif /* __INT8_TYPE__ */\n"
"\n"
"#ifdef __INT_LEAST8_MIN\n"
"# define INT_LEAST8_MIN   __INT_LEAST8_MIN\n"
"# define INT_LEAST8_MAX   __INT_LEAST8_MAX\n"
"# define UINT_LEAST8_MAX __UINT_LEAST8_MAX\n"
"# define INT_FAST8_MIN    __INT_LEAST8_MIN\n"
"# define INT_FAST8_MAX    __INT_LEAST8_MAX\n"
"# define UINT_FAST8_MAX  __UINT_LEAST8_MAX\n"
"#endif /* __INT_LEAST8_MIN */\n"
"\n"
"/* Some utility macros */\n"
"#define  __INTN_MIN(n)  __stdint_join3( INT, n, _MIN)\n"
"#define  __INTN_MAX(n)  __stdint_join3( INT, n, _MAX)\n"
"#define __UINTN_MAX(n)  __stdint_join3(UINT, n, _MAX)\n"
"#define  __INTN_C(n, v) __stdint_join3( INT, n, _C(v))\n"
"#define __UINTN_C(n, v) __stdint_join3(UINT, n, _C(v))\n"
"\n"
"/* C99 7.18.2.4 Limits of integer types capable of holding object pointers. */\n"
"/* C99 7.18.3 Limits of other integer types. */\n"
"\n"
"#define  INTPTR_MIN  (-__INTPTR_MAX__-1)\n"
"#define  INTPTR_MAX    __INTPTR_MAX__\n"
"#define UINTPTR_MAX   __UINTPTR_MAX__\n"
"#define PTRDIFF_MIN (-__PTRDIFF_MAX__-1)\n"
"#define PTRDIFF_MAX   __PTRDIFF_MAX__\n"
"#define    SIZE_MAX      __SIZE_MAX__\n"
"\n"
"/* ISO9899:2011 7.20 (C11 Annex K): Define RSIZE_MAX if __STDC_WANT_LIB_EXT1__\n"
" * is enabled. */\n"
"#if defined(__STDC_WANT_LIB_EXT1__) && __STDC_WANT_LIB_EXT1__ >= 1\n"
"#define   RSIZE_MAX            (SIZE_MAX >> 1)\n"
"#endif\n"
"\n"
"/* C99 7.18.2.5 Limits of greatest-width integer types. */\n"
"#define  INTMAX_MIN (-__INTMAX_MAX__-1)\n"
"#define  INTMAX_MAX   __INTMAX_MAX__\n"
"#define UINTMAX_MAX  __UINTMAX_MAX__\n"
"\n"
"/* C99 7.18.3 Limits of other integer types. */\n"
"#define SIG_ATOMIC_MIN __INTN_MIN(__SIG_ATOMIC_WIDTH__)\n"
"#define SIG_ATOMIC_MAX __INTN_MAX(__SIG_ATOMIC_WIDTH__)\n"
"#ifdef __WINT_UNSIGNED__\n"
"# define WINT_MIN       __UINTN_C(__WINT_WIDTH__, 0)\n"
"# define WINT_MAX       __UINTN_MAX(__WINT_WIDTH__)\n"
"#else\n"
"# define WINT_MIN       __INTN_MIN(__WINT_WIDTH__)\n"
"# define WINT_MAX       __INTN_MAX(__WINT_WIDTH__)\n"
"#endif\n"
"\n"
"#ifndef WCHAR_MAX\n"
"# define WCHAR_MAX __WCHAR_MAX__\n"
"#endif\n"
"#ifndef WCHAR_MIN\n"
"# if __WCHAR_MAX__ == __INTN_MAX(__WCHAR_WIDTH__)\n"
"#  define WCHAR_MIN __INTN_MIN(__WCHAR_WIDTH__)\n"
"# else\n"
"#  define WCHAR_MIN __UINTN_C(__WCHAR_WIDTH__, 0)\n"
"# endif\n"
"#endif\n"
"\n"
"/* 7.18.4.2 Macros for greatest-width integer constants. */\n"
"#define  INTMAX_C(v) __int_c(v,  __INTMAX_C_SUFFIX__)\n"
"#define UINTMAX_C(v) __int_c(v, __UINTMAX_C_SUFFIX__)\n"
"\n"
"\n"
"#endif // SLANG_LLVM_H\n"
"\n"
"\n"
"\n"
"#else // SLANG_LLVM\n"
"#   if SLANG_GCC_FAMILY && __GNUC__ < 6\n"
"#       include <cmath>\n"
"#       define SLANG_PRELUDE_STD std::\n"
"#   else\n"
"#       include <math.h>\n"
"#       define SLANG_PRELUDE_STD\n"
"#   endif\n"
"\n"
"#   include <assert.h>\n"
"#   include <stdlib.h>\n"
"#   include <string.h>\n"
"#   include <stdint.h>\n"
"#endif // SLANG_LLVM\n"
"\n"
"#ifndef SLANG_CORE_STRING_H\n"
"#define SLANG_CORE_STRING_H\n"
"\n"
"#include <string.h>\n"
"#include <cstdlib>\n"
"#include <stdio.h>\n"
"#include <iostream>\n"
"\n"
"#ifndef SLANG_CORE_SMART_POINTER_H\n"
"#define SLANG_CORE_SMART_POINTER_H\n"
"\n"
"#ifndef SLANG_CORE_COMMON_H\n"
"#define SLANG_CORE_COMMON_H\n"
"\n"
"#ifndef SLANG_H\n"
"#define SLANG_H\n"
"\n"
"/** \\file slang.h\n"
"\n"
"The Slang API provides services to compile, reflect, and specialize code\n"
"written in the Slang shading language.\n"
"*/\n"
"\n"
"/*\n"
"The following section attempts to detect the compiler and version in use.\n"
"\n"
"If an application defines `SLANG_COMPILER` before including this header,\n"
"they take responsibility for setting any compiler-dependent macros\n"
"used later in the file.\n"
"\n"
"Most applications should not need to touch this section.\n"
"*/\n"
"#ifndef SLANG_COMPILER\n"
"#    define SLANG_COMPILER\n"
"\n"
"/*\n"
"Compiler defines, see http://sourceforge.net/p/predef/wiki/Compilers/\n"
"NOTE that SLANG_VC holds the compiler version - not just 1 or 0\n"
"*/\n"
"#    if defined(_MSC_VER)\n"
"#        if _MSC_VER >= 1900\n"
"#            define SLANG_VC 14\n"
"#        elif _MSC_VER >= 1800\n"
"#            define SLANG_VC 12\n"
"#        elif _MSC_VER >= 1700\n"
"#            define SLANG_VC 11\n"
"#        elif _MSC_VER >= 1600\n"
"#            define SLANG_VC 10\n"
"#        elif _MSC_VER >= 1500\n"
"#            define SLANG_VC 9\n"
"#        else\n"
"#            error \"unknown version of Visual C++ compiler\"\n"
"#        endif\n"
"#    elif defined(__GNUC__) /* note: __clang__, __SNC__, or __ghs__ imply __GNUC__ */\n"
"#        define SLANG_GCC 1\n"
"#    elif defined(__clang__)\n"
"#        define SLANG_CLANG 1\n"
"#    elif defined(__SNC__)\n"
"#        define SLANG_SNC 1\n"
"#    elif defined(__ghs__)\n"
"#        define SLANG_GHS 1\n"
"#    else\n"
"#        error \"unknown compiler\"\n"
"#    endif\n"
"/*\n"
"Any compilers not detected by the above logic are now now explicitly zeroed out.\n"
"*/\n"
"#    ifndef SLANG_VC\n"
"#        define SLANG_VC 0\n"
"#    endif\n"
"#    ifndef SLANG_CLANG\n"
"#        define SLANG_CLANG 0\n"
"#    endif\n"
"#    ifndef SLANG_SNC\n"
"#        define SLANG_SNC 0\n"
"#    endif\n"
"#    ifndef SLANG_GHS\n"
"#        define SLANG_GHS 0\n"
"#    endif\n"
"#    ifndef SLANG_GCC\n"
"#        define SLANG_GCC 0\n"
"#    endif\n"
"#endif /* SLANG_COMPILER */\n"
"\n"
"/*\n"
"The following section attempts to detect the target platform being compiled for.\n"
"\n"
"If an application defines `SLANG_PLATFORM` before including this header,\n"
"they take responsibility for setting any compiler-dependent macros\n"
"used later in the file.\n"
"\n"
"Most applications should not need to touch this section.\n"
"*/\n"
"#ifndef SLANG_PLATFORM\n"
"#    define SLANG_PLATFORM\n"
"/**\n"
"Operating system defines, see http://sourceforge.net/p/predef/wiki/OperatingSystems/\n"
"*/\n"
"#    if defined(WINAPI_FAMILY) && WINAPI_FAMILY == WINAPI_PARTITION_APP\n"
"#        define SLANG_WINRT 1 /* Windows Runtime, either on Windows RT or Windows 8 */\n"
"#    elif defined(XBOXONE)\n"
"#        define SLANG_XBOXONE 1\n"
"#    elif defined(_WIN64) /* note: XBOXONE implies _WIN64 */\n"
"#        define SLANG_WIN64 1\n"
"#    elif defined(_M_PPC)\n"
"#        define SLANG_X360 1\n"
"#    elif defined(_WIN32) /* note: _M_PPC implies _WIN32 */\n"
"#        define SLANG_WIN32 1\n"
"#    elif defined(__ANDROID__)\n"
"#        define SLANG_ANDROID 1\n"
"#    elif defined(__linux__) || defined(__CYGWIN__) /* note: __ANDROID__ implies __linux__ */\n"
"#        define SLANG_LINUX 1\n"
"#    elif defined(__APPLE__)\n"
"#        include \"TargetConditionals.h\"\n"
"#        if TARGET_OS_MAC\n"
"#            define SLANG_OSX 1\n"
"#        else\n"
"#            define SLANG_IOS 1\n"
"#        endif\n"
"#    elif defined(__CELLOS_LV2__)\n"
"#        define SLANG_PS3 1\n"
"#    elif defined(__ORBIS__)\n"
"#        define SLANG_PS4 1\n"
"#    elif defined(__SNC__) && defined(__arm__)\n"
"#        define SLANG_PSP2 1\n"
"#    elif defined(__ghs__)\n"
"#        define SLANG_WIIU 1\n"
"#    else\n"
"#        error \"unknown target platform\"\n"
"#    endif\n"
"/*\n"
"Any platforms not detected by the above logic are now now explicitly zeroed out.\n"
"*/\n"
"#    ifndef SLANG_WINRT\n"
"#        define SLANG_WINRT 0\n"
"#    endif\n"
"#    ifndef SLANG_XBOXONE\n"
"#        define SLANG_XBOXONE 0\n"
"#    endif\n"
"#    ifndef SLANG_WIN64\n"
"#        define SLANG_WIN64 0\n"
"#    endif\n"
"#    ifndef SLANG_X360\n"
"#        define SLANG_X360 0\n"
"#    endif\n"
"#    ifndef SLANG_WIN32\n"
;
sb << 
"#        define SLANG_WIN32 0\n"
"#    endif\n"
"#    ifndef SLANG_ANDROID\n"
"#        define SLANG_ANDROID 0\n"
"#    endif\n"
"#    ifndef SLANG_LINUX\n"
"#        define SLANG_LINUX 0\n"
"#    endif\n"
"#    ifndef SLANG_IOS\n"
"#        define SLANG_IOS 0\n"
"#    endif\n"
"#    ifndef SLANG_OSX\n"
"#        define SLANG_OSX 0\n"
"#    endif\n"
"#    ifndef SLANG_PS3\n"
"#        define SLANG_PS3 0\n"
"#    endif\n"
"#    ifndef SLANG_PS4\n"
"#        define SLANG_PS4 0\n"
"#    endif\n"
"#    ifndef SLANG_PSP2\n"
"#        define SLANG_PSP2 0\n"
"#    endif\n"
"#    ifndef SLANG_WIIU\n"
"#        define SLANG_WIIU 0\n"
"#    endif\n"
"#endif /* SLANG_PLATFORM */\n"
"\n"
"/* Shorthands for \"families\" of compilers/platforms */\n"
"#define SLANG_GCC_FAMILY (SLANG_CLANG || SLANG_SNC || SLANG_GHS || SLANG_GCC)\n"
"#define SLANG_WINDOWS_FAMILY (SLANG_WINRT || SLANG_WIN32 || SLANG_WIN64)\n"
"#define SLANG_MICROSOFT_FAMILY (SLANG_XBOXONE || SLANG_X360 || (SLANG_WINDOWS_FAMILY && SLANG_VC))\n"
"#define SLANG_LINUX_FAMILY (SLANG_LINUX || SLANG_ANDROID)\n"
"#define SLANG_APPLE_FAMILY (SLANG_IOS || SLANG_OSX)                  /* equivalent to #if __APPLE__ */\n"
"#define SLANG_UNIX_FAMILY (SLANG_LINUX_FAMILY || SLANG_APPLE_FAMILY) /* shortcut for unix/posix platforms */\n"
"\n"
"/* Macros concerning DirectX */\n"
"#if !defined(SLANG_CONFIG_DX_ON_VK) || !SLANG_CONFIG_DX_ON_VK\n"
"#    define SLANG_ENABLE_DXVK 0\n"
"#    define SLANG_ENABLE_VKD3D 0\n"
"#else\n"
"#    define SLANG_ENABLE_DXVK 1\n"
"#    define SLANG_ENABLE_VKD3D 1\n"
"#endif\n"
"\n"
"#if SLANG_WINDOWS_FAMILY\n"
"#    define SLANG_ENABLE_DIRECTX 1\n"
"#    define SLANG_ENABLE_DXGI_DEBUG 1\n"
"#    define SLANG_ENABLE_DXBC_SUPPORT 1\n"
"#    define SLANG_ENABLE_PIX 1\n"
"#elif SLANG_LINUX_FAMILY\n"
"#    define SLANG_ENABLE_DIRECTX (SLANG_ENABLE_DXVK || SLANG_ENABLE_VKD3D)\n"
"#    define SLANG_ENABLE_DXGI_DEBUG 0\n"
"#    define SLANG_ENABLE_DXBC_SUPPORT 0\n"
"#    define SLANG_ENABLE_PIX 0\n"
"#else\n"
"#    define SLANG_ENABLE_DIRECTX 0\n"
"#    define SLANG_ENABLE_DXGI_DEBUG 0\n"
"#    define SLANG_ENABLE_DXBC_SUPPORT 0\n"
"#    define SLANG_ENABLE_PIX 0\n"
"#endif\n"
"\n"
"/* Macro for declaring if a method is no throw. Should be set before the return parameter. */\n"
"#ifndef SLANG_NO_THROW\n"
"#   if SLANG_WINDOWS_FAMILY && !defined(SLANG_DISABLE_EXCEPTIONS)\n"
"#       define SLANG_NO_THROW __declspec(nothrow)\n"
"#   endif\n"
"#endif\n"
"#ifndef SLANG_NO_THROW\n"
"#   define SLANG_NO_THROW\n"
"#endif\n"
"\n"
"/* The `SLANG_STDCALL` and `SLANG_MCALL` defines are used to set the calling\n"
"convention for interface methods.\n"
"*/\n"
"#ifndef SLANG_STDCALL\n"
"#   if SLANG_MICROSOFT_FAMILY\n"
"#       define SLANG_STDCALL __stdcall\n"
"#   else\n"
"#       define SLANG_STDCALL\n"
"#   endif\n"
"#endif\n"
"#ifndef SLANG_MCALL\n"
"#   define SLANG_MCALL SLANG_STDCALL\n"
"#endif\n"
"\n"
"\n"
"#if !defined(SLANG_STATIC) && !defined(SLANG_DYNAMIC)\n"
"    #define SLANG_DYNAMIC\n"
"#endif\n"
"\n"
"#if defined(_MSC_VER)\n"
"#   define SLANG_DLL_EXPORT __declspec(dllexport)\n"
"#else\n"
"#   if 0 && __GNUC__ >= 4\n"
"// Didn't work on latest gcc on linux.. so disable for now\n"
"// https://gcc.gnu.org/wiki/Visibility\n"
"#       define SLANG_DLL_EXPORT __attribute__ ((dllexport))\n"
"#   else\n"
"#       define SLANG_DLL_EXPORT __attribute__((__visibility__(\"default\")))\n"
"#   endif\n"
"#endif\n"
"\n"
"#if defined(SLANG_DYNAMIC)\n"
"#   if defined(_MSC_VER)\n"
"#       ifdef SLANG_DYNAMIC_EXPORT\n"
"#           define SLANG_API SLANG_DLL_EXPORT\n"
"#       else\n"
"#           define SLANG_API __declspec(dllimport)\n"
"#       endif\n"
"#   else\n"
"        // TODO: need to consider compiler capabilities\n"
"//#     ifdef SLANG_DYNAMIC_EXPORT\n"
"#       define SLANG_API SLANG_DLL_EXPORT \n"
"//#     endif\n"
"#   endif\n"
"#endif\n"
"\n"
"#ifndef SLANG_API\n"
"#   define SLANG_API\n"
"#endif\n"
"\n"
"// GCC Specific\n"
"#if SLANG_GCC_FAMILY\n"
"\n"
"#\tdefine SLANG_NO_INLINE __attribute__((noinline))\n"
"#\tdefine SLANG_FORCE_INLINE inline __attribute__((always_inline))\n"
"#   define SLANG_BREAKPOINT(id) __builtin_trap();\n"
"#\tdefine SLANG_ALIGN_OF(T)\t__alignof__(T)\n"
"\n"
"// Use the builtin directly so we don't need to have an include of stddef.h\n"
"#   define SLANG_OFFSET_OF(T, ELEMENT) __builtin_offsetof(T, ELEMENT) \n"
"#endif // SLANG_GCC_FAMILY\n"
"\n"
"#ifndef SLANG_OFFSET_OF\n"
"#   define SLANG_OFFSET_OF(T, ELEMENT) (size_t(&((T*)1)->ELEMENT) - 1)\n"
"#endif\n"
"\n"
"// Microsoft VC specific\n"
"#if SLANG_MICROSOFT_FAMILY\n"
"#\tdefine SLANG_NO_INLINE __declspec(noinline)\n"
"#\tdefine SLANG_FORCE_INLINE __forceinline\n"
"#\tdefine SLANG_BREAKPOINT(id) __debugbreak();\n"
"#\tdefine SLANG_ALIGN_OF(T) __alignof(T)\n"
"\n"
"#   define SLANG_INT64(x) (x##i64)\n"
"#   define SLANG_UINT64(x) (x##ui64)\n"
"#endif // SLANG_MICROSOFT_FAMILY\n"
"\n"
"#ifndef SLANG_FORCE_INLINE\n"
"#\tdefine SLANG_FORCE_INLINE inline\n"
"#endif\n"
"#ifndef SLANG_NO_INLINE\n"
"#\tdefine SLANG_NO_INLINE\n"
"#endif\n"
"\n"
"#ifndef SLANG_COMPILE_TIME_ASSERT\n"
"#   define SLANG_COMPILE_TIME_ASSERT(x) static_assert(x)\n"
"#endif\n"
"\n"
"#ifndef SLANG_OFFSET_OF\n"
"#\tdefine SLANG_OFFSET_OF(X, Y) offsetof(X, Y)\n"
"#endif\n"
"\n"
"#ifndef SLANG_BREAKPOINT\n"
"// Make it crash with a write to 0!\n"
"#   define SLANG_BREAKPOINT(id) (*((int*)0) = int(id));\n"
"#endif\n"
"\n"
"// Use for getting the amount of members of a standard C array.\n"
"// Use 0[x] here to catch the case where x has an overloaded subscript operator\n"
"#define SLANG_COUNT_OF(x) (SlangSSizeT(sizeof(x)/sizeof(0[x])))\n"
"/// SLANG_INLINE exists to have a way to inline consistent with SLANG_ALWAYS_INLINE\n"
"#define SLANG_INLINE inline\n"
"\n"
"// If explicilty disabled and not set, set to not available\n"
"#if !defined(SLANG_HAS_EXCEPTIONS) && defined(SLANG_DISABLE_EXCEPTIONS)\n"
"#   define SLANG_HAS_EXCEPTIONS 0\n"
"#endif\n"
"\n"
"// If not set, the default is exceptions are available\n"
"#ifndef SLANG_HAS_EXCEPTIONS\n"
"#   define SLANG_HAS_EXCEPTIONS 1\n"
"#endif\n"
"\n"
"// Other defines\n"
"#define SLANG_STRINGIZE_HELPER(X) #X\n"
"#define SLANG_STRINGIZE(X) SLANG_STRINGIZE_HELPER(X)\n"
"\n"
"#define SLANG_CONCAT_HELPER(X, Y) X##Y\n"
"#define SLANG_CONCAT(X, Y) SLANG_CONCAT_HELPER(X, Y)\n"
"\n"
"#ifndef SLANG_UNUSED\n"
"#\tdefine SLANG_UNUSED(v) (void)v;\n"
"#endif\n"
"\n"
"// Used for doing constant literals\n"
"#ifndef SLANG_INT64\n"
"#\tdefine SLANG_INT64(x) (x##ll)\n"
"#endif\n"
"#ifndef SLANG_UINT64\n"
"#\tdefine SLANG_UINT64(x) (x##ull)\n"
"#endif\n"
"\n"
"\n"
"#ifdef __cplusplus\n"
"#   define SLANG_EXTERN_C extern \"C\"\n"
"#else\n"
"#   define SLANG_EXTERN_C\n"
"#endif\n"
"\n"
"#ifdef __cplusplus\n"
"// C++ specific macros\n"
"// Clang\n"
"#if SLANG_CLANG\n"
"#    if (__clang_major__*10 + __clang_minor__) >= 33\n"
"#       define SLANG_HAS_MOVE_SEMANTICS 1\n"
"#       define SLANG_HAS_ENUM_CLASS 1\n"
"#       define SLANG_OVERRIDE override\n"
"#    endif\n"
"\n"
"// Gcc\n"
"#elif SLANG_GCC_FAMILY\n"
"// Check for C++11\n"
"#\t\tif (__cplusplus >= 201103L)\n"
"#\t\t\tif (__GNUC__ * 100 + __GNUC_MINOR__) >= 405\n"
"#\t\t\t\tdefine SLANG_HAS_MOVE_SEMANTICS 1\n"
"#\t\t\tendif\n"
"#\t\t\tif (__GNUC__ * 100 + __GNUC_MINOR__) >= 406\n"
"#\t\t\t\tdefine SLANG_HAS_ENUM_CLASS 1\n"
"#\t\t\tendif\n"
"#\t\t\tif (__GNUC__ * 100 + __GNUC_MINOR__) >= 407\n"
"#\t\t\t\tdefine SLANG_OVERRIDE override\n"
"#\t\t\tendif\n"
"#\t\tendif\n"
"\n"
"// TODO(JS): Not used in previous code. Left here as may be useful on some other version. \n"
"// #define SLANG_RETURN_NEVER __attribute__((__noreturn__))\n"
"\n"
"#       define SLANG_RETURN_NEVER [[noreturn]]\n"
"\n"
"#\tendif // SLANG_GCC_FAMILY\n"
"\n"
"// Visual Studio\n"
"\n"
"#\tif SLANG_VC\n"
"// C4481: nonstandard extension used: override specifier 'override'\n"
"#\t\tif _MSC_VER < 1700\n"
"#\t\t\tpragma warning(disable : 4481)\n"
"#\t\tendif\n"
"#\t\tdefine SLANG_OVERRIDE\toverride\n"
"#\t\tif _MSC_VER >= 1600\n"
"#\t\t\tdefine SLANG_HAS_MOVE_SEMANTICS 1\n"
"#\t\tendif\n"
"#\t    if _MSC_VER >= 1700\n"
"#\t\t    define SLANG_HAS_ENUM_CLASS 1\n"
"#       endif\n"
"\n"
"#   define SLANG_RETURN_NEVER __declspec(noreturn)\n"
"\n"
"#   endif // SLANG_VC\n"
"\n"
"// Set non set\n"
"#   ifndef SLANG_OVERRIDE\n"
"#\t    define SLANG_OVERRIDE\n"
"#   endif\n"
"#   ifndef SLANG_HAS_ENUM_CLASS\n"
"#\t    define SLANG_HAS_ENUM_CLASS 0\n"
"#   endif\n"
"#   ifndef SLANG_HAS_MOVE_SEMANTICS\n"
"#\t    define SLANG_HAS_MOVE_SEMANTICS 0\n"
"#   endif\n"
"\n"
"#endif // __cplusplus\n"
"\n"
"#ifndef SLANG_RETURN_NEVER\n"
"#   define SLANG_RETURN_NEVER [[noreturn]]\n"
"#endif // SLANG_RETURN_NEVER\n"
"\n"
"/* Macros for detecting processor */\n"
"#if defined(_M_ARM) || defined(__ARM_EABI__)\n"
"// This is special case for nVidia tegra\n"
"#   define SLANG_PROCESSOR_ARM 1\n"
"#elif defined(__i386__) || defined(_M_IX86)\n"
"#   define SLANG_PROCESSOR_X86 1\n"
"#elif defined(_M_AMD64) || defined(_M_X64) || defined(__amd64) || defined(__x86_64)\n"
"#   define SLANG_PROCESSOR_X86_64 1\n"
"#elif defined(_PPC_) || defined(__ppc__) || defined(__POWERPC__) || defined(_M_PPC)\n"
"#   if defined(__powerpc64__) || defined(__ppc64__) || defined(__PPC64__) || defined(__64BIT__) || defined(_LP64) || defined(__LP64__)\n"
"#       define SLANG_PROCESSOR_POWER_PC_64 1\n"
"#   else\n"
"#       define SLANG_PROCESSOR_POWER_PC 1\n"
"#   endif\n"
"#elif defined(__arm__)\n"
"#   define SLANG_PROCESSOR_ARM 1\n"
"#elif defined(_M_ARM64) || defined(__aarch64__)\n"
"#   define SLANG_PROCESSOR_ARM_64 1\n"
"#endif \n"
"\n"
"#ifndef SLANG_PROCESSOR_ARM\n"
"#   define SLANG_PROCESSOR_ARM 0\n"
"#endif\n"
"\n"
"#ifndef SLANG_PROCESSOR_ARM_64\n"
"#   define SLANG_PROCESSOR_ARM_64 0\n"
"#endif\n"
"\n"
"#ifndef SLANG_PROCESSOR_X86\n"
"#   define SLANG_PROCESSOR_X86 0\n"
"#endif\n"
"\n"
"#ifndef SLANG_PROCESSOR_X86_64\n"
"#   define SLANG_PROCESSOR_X86_64 0\n"
"#endif\n"
"\n"
"#ifndef SLANG_PROCESSOR_POWER_PC\n"
"#   define SLANG_PROCESSOR_POWER_PC 0\n"
"#endif\n"
"\n"
"#ifndef SLANG_PROCESSOR_POWER_PC_64\n"
"#   define SLANG_PROCESSOR_POWER_PC_64 0\n"
"#endif\n"
"\n"
"// Processor families\n"
"\n"
"#define SLANG_PROCESSOR_FAMILY_X86 (SLANG_PROCESSOR_X86_64 | SLANG_PROCESSOR_X86)\n"
"#define SLANG_PROCESSOR_FAMILY_ARM (SLANG_PROCESSOR_ARM | SLANG_PROCESSOR_ARM_64)\n"
"#define SLANG_PROCESSOR_FAMILY_POWER_PC (SLANG_PROCESSOR_POWER_PC_64 | SLANG_PROCESSOR_POWER_PC)\n"
"\n"
"// Pointer size\n"
"#define SLANG_PTR_IS_64 (SLANG_PROCESSOR_ARM_64 | SLANG_PROCESSOR_X86_64 | SLANG_PROCESSOR_POWER_PC_64)\n"
"#define SLANG_PTR_IS_32 (SLANG_PTR_IS_64 ^ 1)\n"
"\n"
"// Processor features\n"
"#if SLANG_PROCESSOR_FAMILY_X86\n"
"#   define SLANG_LITTLE_ENDIAN 1\n"
"#   define SLANG_UNALIGNED_ACCESS 1\n"
"#elif SLANG_PROCESSOR_FAMILY_ARM\n"
"#   if defined(__ARMEB__)\n"
"#       define SLANG_BIG_ENDIAN 1\n"
"#   else\n"
"#       define SLANG_LITTLE_ENDIAN 1\n"
"#   endif\n"
"#elif SLANG_PROCESSOR_FAMILY_POWER_PC\n"
"#       define SLANG_BIG_ENDIAN 1\n"
"#endif\n"
"\n"
"#ifndef SLANG_LITTLE_ENDIAN\n"
"#   define SLANG_LITTLE_ENDIAN 0\n"
"#endif\n"
"\n"
"#ifndef SLANG_BIG_ENDIAN\n"
"#   define SLANG_BIG_ENDIAN 0\n"
"#endif\n"
"\n"
"#ifndef SLANG_UNALIGNED_ACCESS\n"
"#   define SLANG_UNALIGNED_ACCESS 0\n"
"#endif\n"
"\n"
"// One endianess must be set\n"
"#if ((SLANG_BIG_ENDIAN | SLANG_LITTLE_ENDIAN) == 0)\n"
"#   error \"Couldn't determine endianess\"\n"
"#endif\n"
"\n"
"#ifndef  SLANG_NO_INTTYPES\n"
"#include <inttypes.h>\n"
"#endif // ! SLANG_NO_INTTYPES\n"
"\n"
"#ifndef  SLANG_NO_STDDEF\n"
"#include <stddef.h>\n"
"#endif // ! SLANG_NO_STDDEF\n"
"\n"
"#ifdef __cplusplus\n"
"extern \"C\"\n"
"{\n"
"#endif\n"
"    /*!\n"
"    @mainpage Introduction\n"
"\n"
"    API Reference: slang.h\n"
"\n"
"    @file slang.h\n"
"    */\n"
"\n"
"    typedef uint32_t    SlangUInt32;\n"
"    typedef int32_t     SlangInt32;\n"
"\n"
"    // Use SLANG_PTR_ macros to determine SlangInt/SlangUInt types.\n"
"    // This is used over say using size_t/ptrdiff_t/intptr_t/uintptr_t, because on some targets, these types are distinct from\n"
"    // their uint_t/int_t equivalents and so produce ambiguity with function overloading.\n"
"    //\n"
"    // SlangSizeT is helpful as on some compilers size_t is distinct from a regular integer type and so overloading doesn't work.\n"
"    // Casting to SlangSizeT works around this.\n"
"#if SLANG_PTR_IS_64\n"
"    typedef int64_t    SlangInt;\n"
"    typedef uint64_t   SlangUInt;\n"
"\n"
"    typedef int64_t    SlangSSizeT;\n"
"    typedef uint64_t   SlangSizeT;\n"
"#else\n"
"    typedef int32_t    SlangInt;\n"
"    typedef uint32_t   SlangUInt;\n"
"\n"
"    typedef int32_t    SlangSSizeT;\n"
"    typedef uint32_t   SlangSizeT;\n"
"#endif\n"
"\n"
"    typedef bool SlangBool;\n"
"\n"
"    \n"
"    /*!\n"
"    @brief Severity of a diagnostic generated by the compiler.\n"
"    Values come from the enum below, with higher values representing more severe\n"
"    conditions, and all values >= SLANG_SEVERITY_ERROR indicating compilation\n"
"    failure.\n"
"    */\n"
"    typedef int SlangSeverityIntegral;\n"
"    enum SlangSeverity : SlangSeverityIntegral\n"
"    {\n"
"        SLANG_SEVERITY_DISABLED = 0, /**< A message that is disabled, filtered out. */\n"
"        SLANG_SEVERITY_NOTE,         /**< An informative message. */\n"
"        SLANG_SEVERITY_WARNING,      /**< A warning, which indicates a possible proble. */\n"
"        SLANG_SEVERITY_ERROR,        /**< An error, indicating that compilation failed. */\n"
"        SLANG_SEVERITY_FATAL,        /**< An unrecoverable error, which forced compilation to abort. */\n"
"        SLANG_SEVERITY_INTERNAL,     /**< An internal error, indicating a logic error in the compiler. */\n"
"    };\n"
"\n"
"    typedef int SlangDiagnosticFlags;\n"
"    enum\n"
"    {\n"
"        SLANG_DIAGNOSTIC_FLAG_VERBOSE_PATHS = 0x01,\n"
"        SLANG_DIAGNOSTIC_FLAG_TREAT_WARNINGS_AS_ERRORS = 0x02\n"
"    };\n"
"\n"
"    typedef int SlangBindableResourceIntegral;\n"
"    enum SlangBindableResourceType : SlangBindableResourceIntegral\n"
"    {\n"
"        SLANG_NON_BINDABLE = 0,\n"
"        SLANG_TEXTURE,\n"
"        SLANG_SAMPLER,\n"
"        SLANG_UNIFORM_BUFFER,\n"
"        SLANG_STORAGE_BUFFER,\n"
"    };\n"
"\n"
"    /* NOTE! To keep binary compatibility care is needed with this enum!\n"
"\n"
"    * To add value, only add at the bottom (before COUNT_OF) \n"
"    * To remove a value, add _DEPRECATED as a suffix, but leave in the list\n"
"    \n"
"    This will make the enum values stable, and compatible with libraries that might not use the latest\n"
"    enum values.\n"
"    */\n"
"    typedef int SlangCompileTargetIntegral;\n"
"    enum SlangCompileTarget : SlangCompileTargetIntegral\n"
"    {\n"
"        SLANG_TARGET_UNKNOWN,\n"
"        SLANG_TARGET_NONE,\n"
"        SLANG_GLSL,\n"
"        SLANG_GLSL_VULKAN,              //< deprecated: just use `SLANG_GLSL`\n"
"        SLANG_GLSL_VULKAN_ONE_DESC,     //< deprecated\n"
"        SLANG_HLSL,\n"
"        SLANG_SPIRV,\n"
"        SLANG_SPIRV_ASM,\n"
"        SLANG_DXBC,\n"
"        SLANG_DXBC_ASM,\n"
"        SLANG_DXIL,\n"
"        SLANG_DXIL_ASM,\n"
"        SLANG_C_SOURCE,                 ///< The C language\n"
"        SLANG_CPP_SOURCE,               ///< C++ code for shader kernels.\n"
"        SLANG_HOST_EXECUTABLE,          ///< Standalone binary executable (for hosting CPU/OS)\n"
"        SLANG_SHADER_SHARED_LIBRARY,    ///< A shared library/Dll for shader kernels (for hosting CPU/OS)\n"
"        SLANG_SHADER_HOST_CALLABLE,     ///< A CPU target that makes the compiled shader code available to be run immediately\n"
"        SLANG_CUDA_SOURCE,              ///< Cuda source\n"
"        SLANG_PTX,                      ///< PTX\n"
"        SLANG_CUDA_OBJECT_CODE,         ///< Object code that contains CUDA functions.\n"
"        SLANG_OBJECT_CODE,              ///< Object code that can be used for later linking\n"
"        SLANG_HOST_CPP_SOURCE,          ///< C++ code for host library or executable.\n"
"        SLANG_HOST_HOST_CALLABLE,       ///< Host callable host code (ie non kernel/shader) \n"
"        SLANG_CPP_PYTORCH_BINDING,      ///< C++ PyTorch binding code.\n"
"        SLANG_TARGET_COUNT_OF,\n"
"    };\n"
"\n"
"    /* A \"container format\" describes the way that the outputs\n"
"    for multiple files, entry points, targets, etc. should be\n"
"    combined into a single artifact for output. */\n"
"    typedef int SlangContainerFormatIntegral;\n"
"    enum SlangContainerFormat : SlangContainerFormatIntegral\n"
"    {\n"
"        /* Don't generate a container. */\n"
"        SLANG_CONTAINER_FORMAT_NONE,\n"
"\n"
"        /* Generate a container in the `.slang-module` format,\n"
"        which includes reflection information, compiled kernels, etc. */\n"
"        SLANG_CONTAINER_FORMAT_SLANG_MODULE,\n"
"    };\n"
"\n"
"    typedef int SlangPassThroughIntegral;\n"
"    enum SlangPassThrough : SlangPassThroughIntegral\n"
"    {\n"
"        SLANG_PASS_THROUGH_NONE,\n"
"        SLANG_PASS_THROUGH_FXC,\n"
"        SLANG_PASS_THROUGH_DXC,\n"
"        SLANG_PASS_THROUGH_GLSLANG,\n"
"        SLANG_PASS_THROUGH_SPIRV_DIS,\n"
"        SLANG_PASS_THROUGH_CLANG,                   ///< Clang C/C++ compiler \n"
"        SLANG_PASS_THROUGH_VISUAL_STUDIO,           ///< Visual studio C/C++ compiler\n"
"        SLANG_PASS_THROUGH_GCC,                     ///< GCC C/C++ compiler\n"
"        SLANG_PASS_THROUGH_GENERIC_C_CPP,           ///< Generic C or C++ compiler, which is decided by the source type\n"
"        SLANG_PASS_THROUGH_NVRTC,                   ///< NVRTC Cuda compiler\n"
"        SLANG_PASS_THROUGH_LLVM,                    ///< LLVM 'compiler' - includes LLVM and Clang\n"
"        SLANG_PASS_THROUGH_SPIRV_OPT,               ///< SPIRV-opt\n"
"        SLANG_PASS_THROUGH_COUNT_OF,\n"
"    };\n"
"\n"
"    /* Defines an archive type used to holds a 'file system' type structure. */\n"
"    typedef int SlangArchiveTypeIntegral;\n"
"    enum SlangArchiveType : SlangArchiveTypeIntegral\n"
"    {\n"
"        SLANG_ARCHIVE_TYPE_UNDEFINED,\n"
"        SLANG_ARCHIVE_TYPE_ZIP,\n"
"        SLANG_ARCHIVE_TYPE_RIFF,                ///< Riff container with no compression\n"
"        SLANG_ARCHIVE_TYPE_RIFF_DEFLATE,\n"
"        SLANG_ARCHIVE_TYPE_RIFF_LZ4,\n"
"        SLANG_ARCHIVE_TYPE_COUNT_OF,\n"
"    };\n"
"\n"
"    /*!\n"
"    Flags to control compilation behavior.\n"
"    */\n"
"    typedef unsigned int SlangCompileFlags;\n"
"    enum\n"
"    {\n"
"        /* Do as little mangling of names as possible, to try to preserve original names */\n"
"        SLANG_COMPILE_FLAG_NO_MANGLING          = 1 << 3,\n"
"\n"
"        /* Skip code generation step, just check the code and generate layout */\n"
"        SLANG_COMPILE_FLAG_NO_CODEGEN           = 1 << 4,\n"
"\n"
"        /* Obfuscate shader names on release products */\n"
"        SLANG_COMPILE_FLAG_OBFUSCATE = 1 << 5,\n"
"\n"
"        /* Deprecated flags: kept around to allow existing applications to\n"
"        compile. Note that the relevant features will still be left in\n"
"        their default state. */\n"
;
sb << 
"        SLANG_COMPILE_FLAG_NO_CHECKING          = 0,\n"
"        SLANG_COMPILE_FLAG_SPLIT_MIXED_TYPES    = 0,\n"
"    };\n"
"\n"
"    /*!\n"
"    @brief Flags to control code generation behavior of a compilation target */\n"
"    typedef unsigned int SlangTargetFlags;\n"
"    enum \n"
"    {\n"
"        /* When compiling for a D3D Shader Model 5.1 or higher target, allocate\n"
"           distinct register spaces for parameter blocks.\n"
"\n"
"           @deprecated This behavior is now enabled unconditionally.\n"
"        */\n"
"        SLANG_TARGET_FLAG_PARAMETER_BLOCKS_USE_REGISTER_SPACES = 1 << 4,\n"
"\n"
"        /* When set, will generate target code that contains all entrypoints defined\n"
"           in the input source or specified via the `spAddEntryPoint` function in a\n"
"           single output module (library/source file).\n"
"        */\n"
"        SLANG_TARGET_FLAG_GENERATE_WHOLE_PROGRAM = 1 << 8,\n"
"\n"
"        /* When set, will dump out the IR between intermediate compilation steps.*/\n"
"        SLANG_TARGET_FLAG_DUMP_IR = 1 << 9,\n"
"\n"
"        /* When set, will generate SPIRV directly rather than via glslang. */\n"
"        SLANG_TARGET_FLAG_GENERATE_SPIRV_DIRECTLY = 1 << 10,\n"
"    };\n"
"#if defined(SLANG_CONFIG_DEFAULT_SPIRV_DIRECT)\n"
"    constexpr static SlangTargetFlags kDefaultTargetFlags = SLANG_TARGET_FLAG_GENERATE_SPIRV_DIRECTLY;\n"
"#else\n"
"    constexpr static SlangTargetFlags kDefaultTargetFlags = 0;\n"
"#endif\n"
"\n"
"    /*!\n"
"    @brief Options to control floating-point precision guarantees for a target.\n"
"    */\n"
"    typedef unsigned int SlangFloatingPointModeIntegral;\n"
"    enum SlangFloatingPointMode : SlangFloatingPointModeIntegral\n"
"    {\n"
"        SLANG_FLOATING_POINT_MODE_DEFAULT = 0,\n"
"        SLANG_FLOATING_POINT_MODE_FAST,\n"
"        SLANG_FLOATING_POINT_MODE_PRECISE,\n"
"    };\n"
"\n"
"    /*!\n"
"    @brief Options to control emission of `#line` directives\n"
"    */\n"
"    typedef unsigned int SlangLineDirectiveModeIntegral;\n"
"    enum SlangLineDirectiveMode : SlangLineDirectiveModeIntegral\n"
"    {\n"
"        SLANG_LINE_DIRECTIVE_MODE_DEFAULT = 0,  /**< Default behavior: pick behavior base on target. */\n"
"        SLANG_LINE_DIRECTIVE_MODE_NONE,         /**< Don't emit line directives at all. */\n"
"        SLANG_LINE_DIRECTIVE_MODE_STANDARD,     /**< Emit standard C-style `#line` directives. */\n"
"        SLANG_LINE_DIRECTIVE_MODE_GLSL,         /**< Emit GLSL-style directives with file *number* instead of name */\n"
"        SLANG_LINE_DIRECTIVE_MODE_SOURCE_MAP,   /**< Use a source map to track line mappings (ie no #line will appear in emitting source) */\n"
"    };\n"
"\n"
"    typedef int SlangSourceLanguageIntegral;\n"
"    enum SlangSourceLanguage : SlangSourceLanguageIntegral\n"
"    {\n"
"        SLANG_SOURCE_LANGUAGE_UNKNOWN,\n"
"        SLANG_SOURCE_LANGUAGE_SLANG,\n"
"        SLANG_SOURCE_LANGUAGE_HLSL,\n"
"        SLANG_SOURCE_LANGUAGE_GLSL,\n"
"        SLANG_SOURCE_LANGUAGE_C,\n"
"        SLANG_SOURCE_LANGUAGE_CPP,\n"
"        SLANG_SOURCE_LANGUAGE_CUDA,\n"
"        SLANG_SOURCE_LANGUAGE_SPIRV,\n"
"        SLANG_SOURCE_LANGUAGE_COUNT_OF,\n"
"    };\n"
"\n"
"    typedef unsigned int SlangProfileIDIntegral;\n"
"    enum SlangProfileID : SlangProfileIDIntegral\n"
"    {\n"
"        SLANG_PROFILE_UNKNOWN,\n"
"    };\n"
"\n"
"\n"
"    typedef SlangInt32 SlangCapabilityIDIntegral;\n"
"    enum SlangCapabilityID : SlangCapabilityIDIntegral\n"
"    {\n"
"        SLANG_CAPABILITY_UNKNOWN = 0,\n"
"    };\n"
"\n"
"    typedef unsigned int SlangMatrixLayoutModeIntegral;\n"
"    enum SlangMatrixLayoutMode : SlangMatrixLayoutModeIntegral\n"
"    {\n"
"        SLANG_MATRIX_LAYOUT_MODE_UNKNOWN = 0,\n"
"        SLANG_MATRIX_LAYOUT_ROW_MAJOR,\n"
"        SLANG_MATRIX_LAYOUT_COLUMN_MAJOR,\n"
"    };\n"
"\n"
"    typedef SlangUInt32 SlangStageIntegral;\n"
"    enum SlangStage : SlangStageIntegral\n"
"    {\n"
"        SLANG_STAGE_NONE,\n"
"        SLANG_STAGE_VERTEX,\n"
"        SLANG_STAGE_HULL,\n"
"        SLANG_STAGE_DOMAIN,\n"
"        SLANG_STAGE_GEOMETRY,\n"
"        SLANG_STAGE_FRAGMENT,\n"
"        SLANG_STAGE_COMPUTE,\n"
"        SLANG_STAGE_RAY_GENERATION,\n"
"        SLANG_STAGE_INTERSECTION,\n"
"        SLANG_STAGE_ANY_HIT,\n"
"        SLANG_STAGE_CLOSEST_HIT,\n"
"        SLANG_STAGE_MISS,\n"
"        SLANG_STAGE_CALLABLE,\n"
"        SLANG_STAGE_MESH,\n"
"        SLANG_STAGE_AMPLIFICATION,\n"
"\n"
"        // alias:\n"
"        SLANG_STAGE_PIXEL = SLANG_STAGE_FRAGMENT,\n"
"    };\n"
"\n"
"    typedef SlangUInt32 SlangDebugInfoLevelIntegral;\n"
"    enum SlangDebugInfoLevel : SlangDebugInfoLevelIntegral\n"
"    {\n"
"        SLANG_DEBUG_INFO_LEVEL_NONE = 0,    /**< Don't emit debug information at all. */\n"
"        SLANG_DEBUG_INFO_LEVEL_MINIMAL,     /**< Emit as little debug information as possible, while still supporting stack trackes. */\n"
"        SLANG_DEBUG_INFO_LEVEL_STANDARD,    /**< Emit whatever is the standard level of debug information for each target. */\n"
"        SLANG_DEBUG_INFO_LEVEL_MAXIMAL,     /**< Emit as much debug infromation as possible for each target. */\n"
"        \n"
"    };\n"
"\n"
"    /* Describes the debugging information format produced during a compilation. */\n"
"    typedef SlangUInt32 SlangDebugInfoFormatIntegral;\n"
"    enum SlangDebugInfoFormat : SlangDebugInfoFormatIntegral\n"
"    {\n"
"        SLANG_DEBUG_INFO_FORMAT_DEFAULT,         ///< Use the default debugging format for the target \n"
"        SLANG_DEBUG_INFO_FORMAT_C7,              ///< CodeView C7 format (typically means debugging infomation is embedded in the binary)\n"
"        SLANG_DEBUG_INFO_FORMAT_PDB,             ///< Program database\n"
"        \n"
"        SLANG_DEBUG_INFO_FORMAT_STABS,          ///< Stabs\n"
"        SLANG_DEBUG_INFO_FORMAT_COFF,           ///< COFF debug info\n"
"        SLANG_DEBUG_INFO_FORMAT_DWARF,          ///< DWARF debug info (we may want to support specifying the version)\n"
"\n"
"        SLANG_DEBUG_INFO_FORMAT_COUNT_OF,\n"
"    };\n"
"\n"
"    typedef SlangUInt32 SlangOptimizationLevelIntegral;\n"
"    enum SlangOptimizationLevel : SlangOptimizationLevelIntegral\n"
"    {\n"
"        SLANG_OPTIMIZATION_LEVEL_NONE = 0,  /**< Don't optimize at all. */\n"
"        SLANG_OPTIMIZATION_LEVEL_DEFAULT,   /**< Default optimization level: balance code quality and compilation time. */\n"
"        SLANG_OPTIMIZATION_LEVEL_HIGH,      /**< Optimize aggressively. */\n"
"        SLANG_OPTIMIZATION_LEVEL_MAXIMAL,   /**< Include optimizations that may take a very long time, or may involve severe space-vs-speed tradeoffs */\n"
"    };\n"
"\n"
"    // All compiler option names supported by Slang.\n"
"    namespace slang\n"
"    {\n"
"        enum class CompilerOptionName\n"
"        {\n"
"            MacroDefine,        // stringValue0: macro name;  stringValue1: macro value\n"
"            DepFile,\n"
"            EntryPointName,\n"
"            Specialize,\n"
"            Help,\n"
"            HelpStyle,\n"
"            Include,            // stringValue: additional include path.\n"
"            Language,\n"
"            MatrixLayoutColumn, // bool\n"
"            MatrixLayoutRow,    // bool\n"
"            ModuleName,         // stringValue0: module name.\n"
"            Output,\n"
"            Profile,            // intValue0: profile\n"
"            Stage,              // intValue0: stage\n"
"            Target,             // intValue0: CodeGenTarget\n"
"            Version,\n"
"            WarningsAsErrors,   // stringValue0: \"all\" or comma separated list of warning codes or names.\n"
"            DisableWarnings,    // stringValue0: comma separated list of warning codes or names.\n"
"            EnableWarning,      // stringValue0: warning code or name.\n"
"            DisableWarning,     // stringValue0: warning code or name.\n"
"            DumpWarningDiagnostics,\n"
"            InputFilesRemain,\n"
"            EmitIr,                // bool\n"
"            ReportDownstreamTime,  // bool\n"
"            ReportPerfBenchmark,   // bool\n"
"            SkipSPIRVValidation,   // bool\n"
"            SourceEmbedStyle,\n"
"            SourceEmbedName,\n"
"            SourceEmbedLanguage,\n"
"\n"
"            // Target\n"
"\n"
"            Capability,                 // intValue0: CapabilityName\n"
"            DefaultImageFormatUnknown,  // bool\n"
"            DisableDynamicDispatch,     // bool\n"
"            DisableSpecialization,      // bool\n"
"            FloatingPointMode,          // intValue0: FloatingPointMode\n"
"            DebugInformation,           // intValue0: DebugInfoLevel\n"
"            LineDirectiveMode,\n"
"            Optimization,               // intValue0: OptimizationLevel\n"
"            Obfuscate,                  // bool\n"
"\n"
"            VulkanBindShift,            // intValue0 (higher 8 bits): kind; intValue0(lower bits): set; intValue1: shift\n"
"            VulkanBindGlobals,          // intValue0: index; intValue1: set\n"
"            VulkanInvertY,              // bool\n"
"            VulkanUseEntryPointName,    // bool\n"
"            VulkanUseGLLayout,          // bool\n"
"            VulkanEmitReflection,       // bool\n"
"\n"
"            GLSLForceScalarLayout,      // bool\n"
"            EnableEffectAnnotations,    // bool\n"
"\n"
"            EmitSpirvViaGLSL,           // bool\n"
"            EmitSpirvDirectly,          // bool\n"
"            SPIRVCoreGrammarJSON,       // stringValue0: json path\n"
"            IncompleteLibrary,          // bool, when set, will not issue an error when the linked program has unresolved extern function symbols.\n"
"\n"
"            // Downstream\n"
"\n"
"            CompilerPath,\n"
"            DefaultDownstreamCompiler,\n"
"            DownstreamArgs,             // stringValue0: downstream compiler name. stringValue1: argument list, one per line.\n"
"            PassThrough,\n"
"\n"
"            // Repro\n"
"\n"
"            DumpRepro,\n"
"            DumpReproOnError,\n"
"            ExtractRepro,\n"
"            LoadRepro,\n"
"            LoadReproDirectory,\n"
"            ReproFallbackDirectory,\n"
"\n"
"            // Debugging\n"
"\n"
"            DumpAst,\n"
"            DumpIntermediatePrefix,\n"
"            DumpIntermediates,      // bool\n"
"            DumpIr,                 // bool\n"
"            DumpIrIds,\n"
"            PreprocessorOutput,\n"
"            OutputIncludes,\n"
"            ReproFileSystem,\n"
"            SerialIr,               // bool\n"
"            SkipCodeGen,            // bool\n"
"            ValidateIr,             // bool\n"
"            VerbosePaths,\n"
"            VerifyDebugSerialIr,\n"
"            NoCodeGen,              // Not used.\n"
"\n"
"            // Experimental\n"
"\n"
"            FileSystem,\n"
"            Heterogeneous,\n"
"            NoMangle,\n"
"            ValidateUniformity,\n"
"            AllowGLSL,\n"
"\n"
"            // Internal\n"
"\n"
"            ArchiveType,\n"
"            CompileStdLib,\n"
"            Doc,\n"
"            IrCompression,\n"
"            LoadStdLib,\n"
"            ReferenceModule,\n"
"            SaveStdLib,\n"
"            SaveStdLibBinSource,\n"
"            TrackLiveness,\n"
"\n"
"            // Deprecated\n"
"            ParameterBlocksUseRegisterSpaces,\n"
"\n"
"            CountOfParsableOptions,\n"
"\n"
"            // Used in parsed options only.\n"
"            DebugInformationFormat,     // intValue0: DebugInfoFormat\n"
"            VulkanBindShiftAll,         // intValue0: kind; intValue1: shift\n"
"            GenerateWholeProgram,       // bool\n"
"            UseUpToDateBinaryModule,    // bool, when set, will only load\n"
"                                        // precompiled modules if it is up-to-date with its source.\n"
"\n"
"            CountOf,\n"
"        };\n"
"\n"
"        enum class CompilerOptionValueKind\n"
"        {\n"
"            Int,\n"
"            String\n"
"        };\n"
"\n"
"        struct CompilerOptionValue\n"
"        {\n"
"            CompilerOptionValueKind kind = CompilerOptionValueKind::Int;\n"
"            int32_t intValue0 = 0;\n"
"            int32_t intValue1 = 0;\n"
"            const char* stringValue0 = nullptr;\n"
"            const char* stringValue1 = nullptr;\n"
"        };\n"
"\n"
"        struct CompilerOptionEntry\n"
"        {\n"
"            CompilerOptionName name;\n"
"            CompilerOptionValue value;\n"
"        };\n"
"    }\n"
"\n"
"    /** A result code for a Slang API operation.\n"
"\n"
"    This type is generally compatible with the Windows API `HRESULT` type. In particular, negative values indicate\n"
"    failure results, while zero or positive results indicate success.\n"
"\n"
"    In general, Slang APIs always return a zero result on success, unless documented otherwise. Strictly speaking\n"
"    a negative value indicates an error, a positive (or 0) value indicates success. This can be tested for with the macros\n"
"    SLANG_SUCCEEDED(x) or SLANG_FAILED(x).\n"
"\n"
"    It can represent if the call was successful or not. It can also specify in an extensible manner what facility\n"
"    produced the result (as the integral 'facility') as well as what caused it (as an integral 'code').\n"
"    Under the covers SlangResult is represented as a int32_t.\n"
"\n"
"    SlangResult is designed to be compatible with COM HRESULT.\n"
"\n"
"    It's layout in bits is as follows\n"
"\n"
"    Severity | Facility | Code\n"
"    ---------|----------|-----\n"
"    31       |    30-16 | 15-0\n"
"\n"
"    Severity - 1 fail, 0 is success - as SlangResult is signed 32 bits, means negative number indicates failure.\n"
"    Facility is where the error originated from. Code is the code specific to the facility.\n"
"\n"
"    Result codes have the following styles,\n"
"    1) SLANG_name\n"
"    2) SLANG_s_f_name\n"
"    3) SLANG_s_name\n"
"\n"
"    where s is S for success, E for error\n"
"    f is the short version of the facility name\n"
"\n"
"    Style 1 is reserved for SLANG_OK and SLANG_FAIL as they are so commonly used.\n"
"\n"
"    It is acceptable to expand 'f' to a longer name to differentiate a name or drop if unique without it.\n"
"    ie for a facility 'DRIVER' it might make sense to have an error of the form SLANG_E_DRIVER_OUT_OF_MEMORY\n"
"    */\n"
"\n"
"    typedef int32_t SlangResult;\n"
"\n"
"    //! Use to test if a result was failure. Never use result != SLANG_OK to test for failure, as there may be successful codes != SLANG_OK.\n"
"#define SLANG_FAILED(status) ((status) < 0)\n"
"    //! Use to test if a result succeeded. Never use result == SLANG_OK to test for success, as will detect other successful codes as a failure.\n"
"#define SLANG_SUCCEEDED(status) ((status) >= 0)\n"
"\n"
"    //! Get the facility the result is associated with\n"
"#define SLANG_GET_RESULT_FACILITY(r)    ((int32_t)(((r) >> 16) & 0x7fff))\n"
"    //! Get the result code for the facility\n"
"#define SLANG_GET_RESULT_CODE(r)        ((int32_t)((r) & 0xffff))\n"
"\n"
"#define SLANG_MAKE_ERROR(fac, code)        ((((int32_t)(fac)) << 16) | ((int32_t)(code)) | int32_t(0x80000000))\n"
"#define SLANG_MAKE_SUCCESS(fac, code)    ((((int32_t)(fac)) << 16) | ((int32_t)(code)))\n"
"\n"
"    /*************************** Facilities ************************************/\n"
"\n"
"    //! Facilities compatible with windows COM - only use if known code is compatible\n"
"#define SLANG_FACILITY_WIN_GENERAL      0\n"
"#define SLANG_FACILITY_WIN_INTERFACE    4\n"
"#define SLANG_FACILITY_WIN_API          7\n"
"\n"
"    //! Base facility -> so as to not clash with HRESULT values (values in 0x200 range do not appear used)\n"
"#define SLANG_FACILITY_BASE         0x200\n"
"\n"
"    /*! Facilities numbers must be unique across a project to make the resulting result a unique number.\n"
"    It can be useful to have a consistent short name for a facility, as used in the name prefix */\n"
"#define SLANG_FACILITY_CORE             SLANG_FACILITY_BASE\n"
"    /* Facility for codes, that are not uniquely defined/protected. Can be used to pass back a specific error without requiring system wide facility uniqueness. Codes\n"
"    should never be part of a public API. */\n"
"#define SLANG_FACILITY_INTERNAL         SLANG_FACILITY_BASE + 1\n"
"\n"
"    /// Base for external facilities. Facilities should be unique across modules.\n"
"#define SLANG_FACILITY_EXTERNAL_BASE 0x210\n"
"\n"
"    /* ************************ Win COM compatible Results ******************************/\n"
"    // https://msdn.microsoft.com/en-us/library/windows/desktop/aa378137(v=vs.85).aspx\n"
"\n"
"    //! SLANG_OK indicates success, and is equivalent to SLANG_MAKE_SUCCESS(SLANG_FACILITY_WIN_GENERAL, 0)\n"
"#define SLANG_OK                          0\n"
"    //! SLANG_FAIL is the generic failure code - meaning a serious error occurred and the call couldn't complete\n"
"#define SLANG_FAIL                          SLANG_MAKE_ERROR(SLANG_FACILITY_WIN_GENERAL, 0x4005)\n"
"\n"
"#define SLANG_MAKE_WIN_GENERAL_ERROR(code)  SLANG_MAKE_ERROR(SLANG_FACILITY_WIN_GENERAL, code)\n"
"\n"
"    //! Functionality is not implemented\n"
"#define SLANG_E_NOT_IMPLEMENTED             SLANG_MAKE_WIN_GENERAL_ERROR(0x4001)\n"
"    //! Interface not be found\n"
"#define SLANG_E_NO_INTERFACE                SLANG_MAKE_WIN_GENERAL_ERROR(0x4002)\n"
"    //! Operation was aborted (did not correctly complete)\n"
"#define SLANG_E_ABORT                       SLANG_MAKE_WIN_GENERAL_ERROR(0x4004) \n"
"\n"
"    //! Indicates that a handle passed in as parameter to a method is invalid.\n"
"#define SLANG_E_INVALID_HANDLE              SLANG_MAKE_ERROR(SLANG_FACILITY_WIN_API, 6)\n"
"    //! Indicates that an argument passed in as parameter to a method is invalid.\n"
"#define SLANG_E_INVALID_ARG                 SLANG_MAKE_ERROR(SLANG_FACILITY_WIN_API, 0x57)\n"
"    //! Operation could not complete - ran out of memory\n"
"#define SLANG_E_OUT_OF_MEMORY               SLANG_MAKE_ERROR(SLANG_FACILITY_WIN_API, 0xe)\n"
"\n"
"    /* *************************** other Results **************************************/\n"
"\n"
"#define SLANG_MAKE_CORE_ERROR(code)         SLANG_MAKE_ERROR(SLANG_FACILITY_CORE, code)\n"
"\n"
"    // Supplied buffer is too small to be able to complete\n"
;
sb << 
"#define SLANG_E_BUFFER_TOO_SMALL            SLANG_MAKE_CORE_ERROR(1)\n"
"    //! Used to identify a Result that has yet to be initialized.\n"
"    //! It defaults to failure such that if used incorrectly will fail, as similar in concept to using an uninitialized variable.\n"
"#define SLANG_E_UNINITIALIZED               SLANG_MAKE_CORE_ERROR(2)\n"
"    //! Returned from an async method meaning the output is invalid (thus an error), but a result for the request is pending, and will be returned on a subsequent call with the async handle.\n"
"#define SLANG_E_PENDING                     SLANG_MAKE_CORE_ERROR(3)\n"
"    //! Indicates a file/resource could not be opened\n"
"#define SLANG_E_CANNOT_OPEN                 SLANG_MAKE_CORE_ERROR(4)\n"
"    //! Indicates a file/resource could not be found\n"
"#define SLANG_E_NOT_FOUND                   SLANG_MAKE_CORE_ERROR(5)\n"
"    //! An unhandled internal failure (typically from unhandled exception)\n"
"#define SLANG_E_INTERNAL_FAIL               SLANG_MAKE_CORE_ERROR(6)\n"
"    //! Could not complete because some underlying feature (hardware or software) was not available \n"
"#define SLANG_E_NOT_AVAILABLE               SLANG_MAKE_CORE_ERROR(7)\n"
"        //! Could not complete because the operation times out. \n"
"#define SLANG_E_TIME_OUT                    SLANG_MAKE_CORE_ERROR(8)\n"
"\n"
"    /** A \"Universally Unique Identifier\" (UUID)\n"
"\n"
"    The Slang API uses UUIDs to identify interfaces when\n"
"    using `queryInterface`.\n"
"\n"
"    This type is compatible with the `GUID` type defined\n"
"    by the Component Object Model (COM), but Slang is\n"
"    not dependent on COM.\n"
"    */\n"
"    struct SlangUUID\n"
"    {\n"
"        uint32_t data1;\n"
"        uint16_t data2;\n"
"        uint16_t data3;\n"
"        uint8_t  data4[8];\n"
"    };\n"
"\n"
"// Place at the start of an interface with the guid.\n"
"// Guid should be specified as SLANG_COM_INTERFACE(0x00000000, 0x0000, 0x0000, { 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46 })\n"
"// NOTE: it's the typical guid struct definition, without the surrounding {}\n"
"// It is not necessary to use the multiple parameters (we can wrap in parens), but this is simple.\n"
"#define SLANG_COM_INTERFACE(a, b, c, d0, d1, d2, d3, d4, d5, d6, d7) \\\n"
"    public: \\\n"
"    SLANG_FORCE_INLINE constexpr static SlangUUID getTypeGuid() \\\n"
"    { \\\n"
"        return { a, b, c, d0, d1, d2, d3, d4, d5, d6, d7 }; \\\n"
"    }\n"
"\n"
"// Sometimes it's useful to associate a guid with a class to identify it. This macro can used for this,\n"
"// and the guid extracted via the getTypeGuid() function defined in the type\n"
"#define SLANG_CLASS_GUID(a, b, c, d0, d1, d2, d3, d4, d5, d6, d7) \\\n"
"    SLANG_FORCE_INLINE constexpr static SlangUUID getTypeGuid() \\\n"
"    { \\\n"
"        return { a, b, c, d0, d1, d2, d3, d4, d5, d6, d7 }; \\\n"
"    }\n"
"\n"
"// Helper to fill in pairs of GUIDs and return pointers. This ensures that the\n"
"// type of the GUID passed matches the pointer type, and that it is derived\n"
"// from ISlangUnknown,\n"
"// TODO(c++20): would is_derived_from be more appropriate here for private inheritance of ISlangUnknown?\n"
"//\n"
"// with     : void createFoo(SlangUUID, void**);\n"
"//            Slang::ComPtr<Bar> myBar;\n"
"// call with: createFoo(SLANG_IID_PPV_ARGS(myBar.writeRef()))\n"
"// to call  : createFoo(Bar::getTypeGuid(), (void**)(myBar.writeRef()))\n"
"#define SLANG_IID_PPV_ARGS(ppType) \\\n"
"    std::decay_t<decltype(**(ppType))>::getTypeGuid(), \\\n"
"    ((void)[]{static_assert(std::is_base_of_v<ISlangUnknown, std::decay_t<decltype(**(ppType))>>);}, reinterpret_cast<void**>(ppType))\n"
"\n"
"\n"
"    /** Base interface for components exchanged through the API.\n"
"\n"
"    This interface definition is compatible with the COM `IUnknown`,\n"
"    and uses the same UUID, but Slang does not require applications\n"
"    to use or initialize COM.\n"
"    */\n"
"    struct ISlangUnknown\n"
"    {\n"
"        SLANG_COM_INTERFACE(0x00000000, 0x0000, 0x0000, { 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46 })\n"
"\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL queryInterface(SlangUUID const& uuid, void** outObject) = 0;\n"
"        virtual SLANG_NO_THROW uint32_t SLANG_MCALL addRef() = 0;\n"
"        virtual SLANG_NO_THROW uint32_t SLANG_MCALL release() = 0;\n"
"\n"
"        /*\n"
"        Inline methods are provided to allow the above operations to be called\n"
"        using their traditional COM names/signatures:\n"
"        */\n"
"        SlangResult QueryInterface(struct _GUID const& uuid, void** outObject) { return queryInterface(*(SlangUUID const*)&uuid, outObject); }\n"
"        uint32_t AddRef() { return addRef(); }\n"
"        uint32_t Release() { return release(); }\n"
"    };\n"
"    #define SLANG_UUID_ISlangUnknown ISlangUnknown::getTypeGuid()\n"
"\n"
"\n"
"    /* An interface to provide a mechanism to cast, that doesn't require ref counting\n"
"    and doesn't have to return a pointer to a ISlangUnknown derived class */\n"
"    class ISlangCastable : public ISlangUnknown\n"
"    {\n"
"        SLANG_COM_INTERFACE(0x87ede0e1, 0x4852, 0x44b0, { 0x8b, 0xf2, 0xcb, 0x31, 0x87, 0x4d, 0xe2, 0x39 });\n"
"\n"
"            /// Can be used to cast to interfaces without reference counting. \n"
"            /// Also provides access to internal implementations, when they provide a guid\n"
"            /// Can simulate a 'generated' interface as long as kept in scope by cast from. \n"
"        virtual SLANG_NO_THROW void* SLANG_MCALL castAs(const SlangUUID& guid) = 0;\n"
"    };\n"
"\n"
"    class ISlangClonable : public ISlangCastable\n"
"    {\n"
"        SLANG_COM_INTERFACE(0x1ec36168, 0xe9f4, 0x430d, { 0xbb, 0x17, 0x4, 0x8a, 0x80, 0x46, 0xb3, 0x1f });\n"
"\n"
"            /// Note the use of guid is for the desired interface/object.\n"
"            /// The object is returned *not* ref counted. Any type that can implements the interface, \n"
"            /// derives from ICastable, and so (not withstanding some other issue) will always return\n"
"            /// an ICastable interface which other interfaces/types are accessible from via castAs\n"
"        SLANG_NO_THROW virtual void* SLANG_MCALL clone(const SlangUUID& guid) = 0;\n"
"    };\n"
"\n"
"    /** A \"blob\" of binary data.\n"
"\n"
"    This interface definition is compatible with the `ID3DBlob` and `ID3D10Blob` interfaces.\n"
"    */\n"
"    struct ISlangBlob : public ISlangUnknown\n"
"    {\n"
"        SLANG_COM_INTERFACE(0x8BA5FB08, 0x5195, 0x40e2, { 0xAC, 0x58, 0x0D, 0x98, 0x9C, 0x3A, 0x01, 0x02 })\n"
"\n"
"        virtual SLANG_NO_THROW void const* SLANG_MCALL getBufferPointer() = 0;\n"
"        virtual SLANG_NO_THROW size_t SLANG_MCALL getBufferSize() = 0;\n"
"    };\n"
"    #define SLANG_UUID_ISlangBlob ISlangBlob::getTypeGuid()\n"
"\n"
"    /* Can be requested from ISlangCastable cast to indicate the contained chars are null terminated.  \n"
"    */\n"
"    struct SlangTerminatedChars\n"
"    {\n"
"        SLANG_CLASS_GUID(0xbe0db1a8, 0x3594, 0x4603, { 0xa7, 0x8b, 0xc4, 0x86, 0x84, 0x30, 0xdf, 0xbb });\n"
"        operator const char*() const { return chars; }\n"
"        char chars[1];\n"
"    };\n"
"\n"
"    /** A (real or virtual) file system.\n"
"\n"
"    Slang can make use of this interface whenever it would otherwise try to load files\n"
"    from disk, allowing applications to hook and/or override filesystem access from\n"
"    the compiler.\n"
"\n"
"    It is the responsibility of \n"
"    the caller of any method that returns a ISlangBlob to release the blob when it is no \n"
"    longer used (using 'release').\n"
"    */\n"
"\n"
"    struct ISlangFileSystem : public ISlangCastable\n"
"    {\n"
"        SLANG_COM_INTERFACE(0x003A09FC, 0x3A4D, 0x4BA0, { 0xAD, 0x60, 0x1F, 0xD8, 0x63, 0xA9, 0x15, 0xAB })\n"
"\n"
"        /** Load a file from `path` and return a blob of its contents\n"
"        @param path The path to load from, as a null-terminated UTF-8 string.\n"
"        @param outBlob A destination pointer to receive the blob of the file contents.\n"
"        @returns A `SlangResult` to indicate success or failure in loading the file.\n"
"\n"
"        NOTE! This is a *binary* load - the blob should contain the exact same bytes\n"
"        as are found in the backing file. \n"
"\n"
"        If load is successful, the implementation should create a blob to hold\n"
"        the file's content, store it to `outBlob`, and return 0.\n"
"        If the load fails, the implementation should return a failure status\n"
"        (any negative value will do).\n"
"        */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL loadFile(\n"
"            char const*     path,\n"
"            ISlangBlob** outBlob) = 0;\n"
"    };\n"
"    #define SLANG_UUID_ISlangFileSystem ISlangFileSystem::getTypeGuid()\n"
"\n"
"\n"
"    typedef void(*SlangFuncPtr)(void);\n"
"\n"
"    /** \n"
"    (DEPRECATED) ISlangSharedLibrary\n"
"    */\n"
"    struct ISlangSharedLibrary_Dep1: public ISlangUnknown\n"
"    {\n"
"        SLANG_COM_INTERFACE( 0x9c9d5bc5, 0xeb61, 0x496f,{ 0x80, 0xd7, 0xd1, 0x47, 0xc4, 0xa2, 0x37, 0x30 })\n"
"\n"
"        virtual SLANG_NO_THROW void* SLANG_MCALL findSymbolAddressByName(char const* name) = 0;\n"
"    };\n"
"    #define SLANG_UUID_ISlangSharedLibrary_Dep1 ISlangSharedLibrary_Dep1::getTypeGuid()\n"
"\n"
"    /** An interface that can be used to encapsulate access to a shared library. An implementation\n"
"    does not have to implement the library as a shared library\n"
"    */\n"
"    struct ISlangSharedLibrary : public ISlangCastable\n"
"    {\n"
"        SLANG_COM_INTERFACE(0x70dbc7c4, 0xdc3b, 0x4a07, { 0xae, 0x7e, 0x75, 0x2a, 0xf6, 0xa8, 0x15, 0x55 })\n"
"\n"
"        /** Get a function by name. If the library is unloaded will only return nullptr.\n"
"        @param name The name of the function\n"
"        @return The function pointer related to the name or nullptr if not found\n"
"        */\n"
"        SLANG_FORCE_INLINE SlangFuncPtr findFuncByName(char const* name) { return (SlangFuncPtr)findSymbolAddressByName(name); }\n"
"\n"
"        /** Get a symbol by name. If the library is unloaded will only return nullptr.\n"
"        @param name The name of the symbol\n"
"        @return The pointer related to the name or nullptr if not found\n"
"        */\n"
"        virtual SLANG_NO_THROW void* SLANG_MCALL findSymbolAddressByName(char const* name) = 0;\n"
"    };\n"
"    #define SLANG_UUID_ISlangSharedLibrary ISlangSharedLibrary::getTypeGuid()\n"
"\n"
"    struct ISlangSharedLibraryLoader: public ISlangUnknown\n"
"    {\n"
"        SLANG_COM_INTERFACE(0x6264ab2b, 0xa3e8, 0x4a06, { 0x97, 0xf1, 0x49, 0xbc, 0x2d, 0x2a, 0xb1, 0x4d })\n"
"\n"
"            /** Load a shared library. In typical usage the library name should *not* contain any platform\n"
"            specific elements. For example on windows a dll name should *not* be passed with a '.dll' extension,\n"
"            and similarly on linux a shared library should *not* be passed with the 'lib' prefix and '.so' extension\n"
"            @path path The unadorned filename and/or path for the shared library\n"
"            @ param sharedLibraryOut Holds the shared library if successfully loaded */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL loadSharedLibrary(\n"
"            const char*     path,\n"
"            ISlangSharedLibrary** sharedLibraryOut) = 0;\n"
"    };\n"
"    #define SLANG_UUID_ISlangSharedLibraryLoader ISlangSharedLibraryLoader::getTypeGuid()\n"
"    \n"
"    /* Type that identifies how a path should be interpreted */\n"
"    typedef unsigned int SlangPathTypeIntegral;\n"
"    enum SlangPathType : SlangPathTypeIntegral\n"
"    {\n"
"        SLANG_PATH_TYPE_DIRECTORY,      /**< Path specified specifies a directory. */\n"
"        SLANG_PATH_TYPE_FILE,           /**< Path specified is to a file. */\n"
"    };\n"
"\n"
"    /* Callback to enumerate the contents of of a directory in a ISlangFileSystemExt.\n"
"    The name is the name of a file system object (directory/file) in the specified path (ie it is without a path) */\n"
"    typedef void (*FileSystemContentsCallBack)(SlangPathType pathType, const char* name, void* userData);\n"
"\n"
"    /* Determines how paths map to files on the OS file system */\n"
"    enum class OSPathKind : uint8_t\n"
"    {\n"
"        None,                ///< Paths do not map to the file system\n"
"        Direct,              ///< Paths map directly to the file system\n"
"        OperatingSystem,     ///< Only paths gained via PathKind::OperatingSystem map to the operating system file system\n"
"    };\n"
"\n"
"    /* Used to determine what kind of path is required from an input path */\n"
"    enum class PathKind\n"
"    {\n"
"            /// Given a path, returns a simplified version of that path.  \n"
"            /// This typically means removing '..' and/or '.' from the path.\n"
"            /// A simplified path must point to the same object as the original.\n"
"        Simplified,             \n"
"\n"
"            /// Given a path, returns a 'canonical path' to the item. \n"
"            /// This may be the operating system 'canonical path' that is the unique path to the item.\n"
"            /// \n"
"            /// If the item exists the returned canonical path should always be usable to access the item.\n"
"            /// \n"
"            /// If the item the path specifies doesn't exist, the canonical path may not be returnable\n"
"            /// or be a path simplification.             \n"
"            /// Not all file systems support canonical paths.\n"
"        Canonical,\n"
"\n"
"            /// Given a path returns a path such that it is suitable to be displayed to the user.\n"
"            /// \n"
"            /// For example if the file system is a zip file - it might include the path to the zip\n"
"            /// container as well as the path to the specific file.\n"
"            /// \n"
"            /// NOTE! The display path won't necessarily work on the file system to access the item\n"
"        Display,\n"
"\n"
"            /// Get the path to the item on the *operating system* file system, if available.\n"
"        OperatingSystem,\n"
"\n"
"        CountOf,\n"
"    };\n"
"\n"
"    /** An extended file system abstraction.\n"
"    \n"
"    Implementing and using this interface over ISlangFileSystem gives much more control over how paths\n"
"    are managed, as well as how it is determined if two files 'are the same'.\n"
"\n"
"    All paths as input char*, or output as ISlangBlobs are always encoded as UTF-8 strings.\n"
"    Blobs that contain strings are always zero terminated.\n"
"    */\n"
"    struct ISlangFileSystemExt : public ISlangFileSystem\n"
"    {\n"
"        SLANG_COM_INTERFACE(0x5fb632d2, 0x979d, 0x4481, { 0x9f, 0xee, 0x66, 0x3c, 0x3f, 0x14, 0x49, 0xe1 })\n"
"\n"
"        /** Get a uniqueIdentity which uniquely identifies an object of the file system.\n"
"           \n"
"        Given a path, returns a 'uniqueIdentity' which ideally is the same value for the same object on the file system.\n"
"\n"
"        The uniqueIdentity is used to compare if two paths are the same - which amongst other things allows Slang to\n"
"        cache source contents internally. It is also used for #pragma once functionality.\n"
"\n"
"        A *requirement* is for any implementation is that two paths can only return the same uniqueIdentity if the\n"
"        contents of the two files are *identical*. If an implementation breaks this constraint it can produce incorrect compilation.\n"
"        If an implementation cannot *strictly* identify *the same* files, this will only have an effect on #pragma once behavior.\n"
"\n"
"        The string for the uniqueIdentity is held zero terminated in the ISlangBlob of outUniqueIdentity.\n"
"   \n"
"        Note that there are many ways a uniqueIdentity may be generated for a file. For example it could be the\n"
"        'canonical path' - assuming it is available and unambiguous for a file system. Another possible mechanism\n"
"        could be to store the filename combined with the file date time to uniquely identify it.\n"
"     \n"
"        The client must ensure the blob be released when no longer used, otherwise memory will leak.\n"
"\n"
"        NOTE! Ideally this method would be called 'getPathUniqueIdentity' but for historical reasons and\n"
"        backward compatibility it's name remains with 'File' even though an implementation should be made to work\n"
"        with directories too.\n"
"\n"
"        @param path\n"
"        @param outUniqueIdentity\n"
"        @returns A `SlangResult` to indicate success or failure getting the uniqueIdentity.\n"
"        */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL getFileUniqueIdentity(\n"
"            const char* path,\n"
"            ISlangBlob** outUniqueIdentity) = 0;\n"
"\n"
"        /** Calculate a path combining the 'fromPath' with 'path'\n"
"\n"
"        The client must ensure the blob be released when no longer used, otherwise memory will leak.\n"
"\n"
"        @param fromPathType How to interpret the from path - as a file or a directory.\n"
"        @param fromPath The from path. \n"
"        @param path Path to be determined relative to the fromPath\n"
"        @param pathOut Holds the string which is the relative path. The string is held in the blob zero terminated.  \n"
"        @returns A `SlangResult` to indicate success or failure in loading the file.\n"
"        */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL calcCombinedPath(\n"
"            SlangPathType fromPathType,\n"
"            const char* fromPath,\n"
"            const char* path,\n"
"            ISlangBlob** pathOut) = 0;          \n"
"            \n"
"        /** Gets the type of path that path is on the file system. \n"
"        @param path\n"
"        @param pathTypeOut\n"
"        @returns SLANG_OK if located and type is known, else an error. SLANG_E_NOT_FOUND if not found.\n"
;
sb << 
"        */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL getPathType(\n"
"            const char* path, \n"
"            SlangPathType* pathTypeOut) = 0;\n"
"\n"
"        /** Get a path based on the kind.\n"
"\n"
"        @param kind The kind of path wanted\n"
"        @param path The input path\n"
"        @param outPath The output path held in a blob\n"
"        @returns SLANG_OK if successfully simplified the path (SLANG_E_NOT_IMPLEMENTED if not implemented, or some other error code)\n"
"        */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL getPath(\n"
"            PathKind kind,\n"
"            const char* path,\n"
"            ISlangBlob** outPath) = 0;\n"
"\n"
"        /** Clears any cached information */\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL clearCache() = 0;\n"
"\n"
"        /** Enumerate the contents of the path\n"
"        \n"
"        Note that for normal Slang operation it isn't necessary to enumerate contents this can return SLANG_E_NOT_IMPLEMENTED.\n"
"        \n"
"        @param The path to enumerate\n"
"        @param callback This callback is called for each entry in the path. \n"
"        @param userData This is passed to the callback\n"
"        @returns SLANG_OK if successful \n"
"        */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL enumeratePathContents(\n"
"            const char* path,\n"
"            FileSystemContentsCallBack callback,\n"
"            void* userData) = 0;\n"
"\n"
"        /** Returns how paths map to the OS file system\n"
"        \n"
"        @returns OSPathKind that describes how paths map to the Operating System file system\n"
"        */\n"
"        virtual SLANG_NO_THROW OSPathKind SLANG_MCALL getOSPathKind() = 0;\n"
"    };\n"
"\n"
"    #define SLANG_UUID_ISlangFileSystemExt ISlangFileSystemExt::getTypeGuid()\n"
"\n"
"    struct ISlangMutableFileSystem : public ISlangFileSystemExt\n"
"    {\n"
"        SLANG_COM_INTERFACE(0xa058675c, 0x1d65, 0x452a, { 0x84, 0x58, 0xcc, 0xde, 0xd1, 0x42, 0x71, 0x5 })\n"
"\n"
"        /** Write data to the specified path.\n"
"\n"
"        @param path The path for data to be saved to\n"
"        @param data The data to be saved\n"
"        @param size The size of the data in bytes\n"
"        @returns SLANG_OK if successful (SLANG_E_NOT_IMPLEMENTED if not implemented, or some other error code)\n"
"        */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL saveFile(\n"
"            const char* path,\n"
"            const void* data,\n"
"            size_t size) = 0;\n"
"\n"
"        /** Write data in the form of a blob to the specified path.\n"
"\n"
"        Depending on the implementation writing a blob might be faster/use less memory. It is assumed the \n"
"        blob is *immutable* and that an implementation can reference count it.\n"
"\n"
"        It is not guaranteed loading the same file will return the *same* blob - just a blob with same \n"
"        contents.\n"
"\n"
"        @param path The path for data to be saved to\n"
"        @param dataBlob The data to be saved\n"
"        @returns SLANG_OK if successful (SLANG_E_NOT_IMPLEMENTED if not implemented, or some other error code)\n"
"        */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL saveFileBlob(\n"
"            const char* path,\n"
"            ISlangBlob* dataBlob) = 0;\n"
"\n"
"        /** Remove the entry in the path (directory of file). Will only delete an empty directory, if not empty\n"
"        will return an error.\n"
"\n"
"        @param path The path to remove \n"
"        @returns SLANG_OK if successful \n"
"        */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL remove(\n"
"            const char* path) = 0;\n"
"\n"
"        /** Create a directory.\n"
"\n"
"        The path to the directory must exist\n"
"\n"
"        @param path To the directory to create. The parent path *must* exist otherwise will return an error.\n"
"        @returns SLANG_OK if successful \n"
"        */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL createDirectory(\n"
"            const char* path) = 0;\n"
"    };\n"
"\n"
"    #define SLANG_UUID_ISlangMutableFileSystem ISlangMutableFileSystem::getTypeGuid()\n"
"\n"
"    /* Identifies different types of writer target*/\n"
"    typedef unsigned int SlangWriterChannelIntegral;\n"
"    enum SlangWriterChannel : SlangWriterChannelIntegral\n"
"    {\n"
"        SLANG_WRITER_CHANNEL_DIAGNOSTIC,\n"
"        SLANG_WRITER_CHANNEL_STD_OUTPUT,\n"
"        SLANG_WRITER_CHANNEL_STD_ERROR,\n"
"        SLANG_WRITER_CHANNEL_COUNT_OF,\n"
"    };\n"
"\n"
"    typedef unsigned int SlangWriterModeIntegral;\n"
"    enum SlangWriterMode : SlangWriterModeIntegral\n"
"    {\n"
"        SLANG_WRITER_MODE_TEXT,\n"
"        SLANG_WRITER_MODE_BINARY,\n"
"    };\n"
"\n"
"    /** A stream typically of text, used for outputting diagnostic as well as other information.\n"
"    */\n"
"    struct ISlangWriter : public ISlangUnknown\n"
"    {\n"
"        SLANG_COM_INTERFACE(0xec457f0e, 0x9add, 0x4e6b,{ 0x85, 0x1c, 0xd7, 0xfa, 0x71, 0x6d, 0x15, 0xfd })\n"
"\n"
"            /** Begin an append buffer.\n"
"            NOTE! Only one append buffer can be active at any time.\n"
"            @param maxNumChars The maximum of chars that will be appended\n"
"            @returns The start of the buffer for appending to. */    \n"
"        virtual SLANG_NO_THROW char* SLANG_MCALL beginAppendBuffer(size_t maxNumChars) = 0;\n"
"            /** Ends the append buffer, and is equivalent to a write of the append buffer.\n"
"            NOTE! That an endAppendBuffer is not necessary if there are no characters to write.\n"
"            @param buffer is the start of the data to append and must be identical to last value returned from beginAppendBuffer\n"
"            @param numChars must be a value less than or equal to what was returned from last call to beginAppendBuffer\n"
"            @returns Result, will be SLANG_OK on success */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL endAppendBuffer(char* buffer, size_t numChars) = 0;\n"
"            /** Write text to the writer\n"
"            @param chars The characters to write out\n"
"            @param numChars The amount of characters\n"
"            @returns SLANG_OK on success */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL write(const char* chars, size_t numChars) = 0;\n"
"            /** Flushes any content to the output */\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL flush() = 0;\n"
"            /** Determines if the writer stream is to the console, and can be used to alter the output \n"
"            @returns Returns true if is a console writer */\n"
"        virtual SLANG_NO_THROW SlangBool SLANG_MCALL isConsole() = 0;\n"
"            /** Set the mode for the writer to use\n"
"            @param mode The mode to use\n"
"            @returns SLANG_OK on success */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL setMode(SlangWriterMode mode) = 0;\n"
"    };\n"
"    \n"
"    #define SLANG_UUID_ISlangWriter ISlangWriter::getTypeGuid()\n"
"\n"
"    namespace slang {\n"
"    struct IGlobalSession;\n"
"    struct ICompileRequest;\n"
"\n"
"    } // namespace slang\n"
"\n"
"    /*!\n"
"    @brief An instance of the Slang library.\n"
"    */\n"
"    typedef slang::IGlobalSession SlangSession;\n"
"    \n"
"\n"
"    typedef struct SlangProgramLayout SlangProgramLayout;\n"
"\n"
"    /*!\n"
"    @brief A request for one or more compilation actions to be performed.\n"
"    */\n"
"    typedef struct slang::ICompileRequest SlangCompileRequest;\n"
"\n"
"\n"
"    /*!\n"
"    @brief Initialize an instance of the Slang library.\n"
"    */\n"
"    SLANG_API SlangSession* spCreateSession(const char* deprecated = 0);\n"
"\n"
"    /*!\n"
"    @brief Clean up after an instance of the Slang library.\n"
"    */\n"
"    SLANG_API void spDestroySession(\n"
"        SlangSession*   session);\n"
"\n"
"    /** @see slang::IGlobalSession::setSharedLibraryLoader\n"
"    */\n"
"    SLANG_API void spSessionSetSharedLibraryLoader(\n"
"        SlangSession*               session,\n"
"        ISlangSharedLibraryLoader*  loader);\n"
"\n"
"    /** @see slang::IGlobalSession::getSharedLibraryLoader\n"
"    */\n"
"    SLANG_API ISlangSharedLibraryLoader* spSessionGetSharedLibraryLoader(\n"
"        SlangSession*   session);\n"
"\n"
"    /** @see slang::IGlobalSession::checkCompileTargetSupport\n"
"    */\n"
"    SLANG_API SlangResult spSessionCheckCompileTargetSupport(\n"
"        SlangSession*       session,\n"
"        SlangCompileTarget  target);\n"
"\n"
"    /** @see slang::IGlobalSession::checkPassThroughSupport\n"
"    */\n"
"    SLANG_API SlangResult spSessionCheckPassThroughSupport(\n"
"        SlangSession*       session,\n"
"        SlangPassThrough    passThrough\n"
"    );\n"
"\n"
"    /** @see slang::IGlobalSession::addBuiltins\n"
"    */\n"
"    SLANG_API void spAddBuiltins(\n"
"        SlangSession*   session,\n"
"        char const*     sourcePath,\n"
"        char const*     sourceString);\n"
"\n"
"        /*!\n"
"    @brief Callback type used for diagnostic output. \n"
"    */\n"
"    typedef void(*SlangDiagnosticCallback)(\n"
"        char const* message,\n"
"        void*       userData);\n"
"\n"
"    /*!\n"
"    @brief Get the build version 'tag' string. The string is the same as produced via `git describe --tags`\n"
"    for the project. If Slang is built separately from the automated build scripts\n"
"    the contents will by default be 'unknown'. Any string can be set by changing the\n"
"    contents of 'slang-tag-version.h' file and recompiling the project.\n"
"\n"
"    This function will return exactly the same result as the method getBuildTag string on IGlobalSession.\n"
"\n"
"    An advantage of using this function over the method is that doing so does not require the creation of\n"
"    a session, which can be a fairly costly operation.\n"
"\n"
"    @return The build tag string\n"
"    */\n"
"    SLANG_API const char* spGetBuildTagString();\n"
"\n"
"    /* @see slang::IGlobalSession::createCompileRequest\n"
"    */\n"
"    SLANG_API SlangCompileRequest* spCreateCompileRequest(\n"
"        SlangSession* session);\n"
"\n"
"    /*!\n"
"    @brief Destroy a compile request.\n"
"    Note a request is a COM object and can be destroyed via 'Release'.\n"
"    */\n"
"    SLANG_API void spDestroyCompileRequest(\n"
"        SlangCompileRequest*    request);\n"
"\n"
"    /*! @see slang::ICompileRequest::setFileSystem */\n"
"    SLANG_API void spSetFileSystem(\n"
"        SlangCompileRequest*    request,\n"
"        ISlangFileSystem*       fileSystem);\n"
"\n"
"    /*! @see slang::ICompileRequest::setCompileFlags */\n"
"    SLANG_API void spSetCompileFlags(\n"
"        SlangCompileRequest*    request,\n"
"        SlangCompileFlags       flags);\n"
"\n"
"    /*! @see slang::ICompileRequest::getCompileFlags */\n"
"    SLANG_API SlangCompileFlags spGetCompileFlags(\n"
"        SlangCompileRequest*    request);\n"
"\n"
"    /*! @see slang::ICompileRequest::setDumpIntermediates */\n"
"    SLANG_API void spSetDumpIntermediates(\n"
"        SlangCompileRequest*    request,\n"
"        int                     enable);\n"
"\n"
"    /*! @see slang::ICompileRequest::setDumpIntermediatePrefix */\n"
"    SLANG_API void spSetDumpIntermediatePrefix(\n"
"        SlangCompileRequest*    request,\n"
"        const char* prefix);\n"
"\n"
"    /*! DEPRECATED: use `spSetTargetLineDirectiveMode` instead.\n"
"        @see slang::ICompileRequest::setLineDirectiveMode */\n"
"    SLANG_API void spSetLineDirectiveMode(\n"
"        SlangCompileRequest*    request,\n"
"        SlangLineDirectiveMode  mode);\n"
"        \n"
"    /*! @see slang::ICompileRequest::setTargetLineDirectiveMode */\n"
"    SLANG_API void spSetTargetLineDirectiveMode(\n"
"        SlangCompileRequest*    request,\n"
"        int targetIndex,\n"
"        SlangLineDirectiveMode  mode);\n"
"\n"
"    /*! @see slang::ICompileRequest::setTargetLineDirectiveMode */\n"
"    SLANG_API void spSetTargetForceGLSLScalarBufferLayout(\n"
"        SlangCompileRequest*    request,\n"
"        int targetIndex,\n"
"        bool forceScalarLayout);\n"
"\n"
"    /*! @see slang::ICompileRequest::setCodeGenTarget */\n"
"    SLANG_API void spSetCodeGenTarget(\n"
"        SlangCompileRequest*    request,\n"
"        SlangCompileTarget target);\n"
"\n"
"    /*! @see slang::ICompileRequest::addCodeGenTarget */\n"
"    SLANG_API int spAddCodeGenTarget(\n"
"        SlangCompileRequest*    request,\n"
"        SlangCompileTarget      target);\n"
"\n"
"    /*! @see slang::ICompileRequest::setTargetProfile */\n"
"    SLANG_API void spSetTargetProfile(\n"
"        SlangCompileRequest*    request,\n"
"        int                     targetIndex,\n"
"        SlangProfileID          profile);\n"
"\n"
"    /*! @see slang::ICompileRequest::setTargetFlags */\n"
"    SLANG_API void spSetTargetFlags(\n"
"        SlangCompileRequest*    request,\n"
"        int                     targetIndex,\n"
"        SlangTargetFlags        flags);\n"
"\n"
"\n"
"\n"
"    /*! @see slang::ICompileRequest::setTargetFloatingPointMode */\n"
"    SLANG_API void spSetTargetFloatingPointMode(\n"
"        SlangCompileRequest*    request,\n"
"        int                     targetIndex,\n"
"        SlangFloatingPointMode  mode);\n"
"\n"
"    /*! @see slang::ICompileRequest::addTargetCapability */\n"
"    SLANG_API void spAddTargetCapability(\n"
"        slang::ICompileRequest* request,\n"
"        int                     targetIndex,\n"
"        SlangCapabilityID       capability);\n"
"\n"
"    /* DEPRECATED: use `spSetMatrixLayoutMode` instead. */\n"
"    SLANG_API void spSetTargetMatrixLayoutMode(\n"
"        SlangCompileRequest*    request,\n"
"        int                     targetIndex,\n"
"        SlangMatrixLayoutMode   mode);\n"
"\n"
"    /*! @see slang::ICompileRequest::setMatrixLayoutMode */\n"
"    SLANG_API void spSetMatrixLayoutMode(\n"
"        SlangCompileRequest*    request,\n"
"        SlangMatrixLayoutMode   mode);\n"
"\n"
"    /*! @see slang::ICompileRequest::setDebugInfoLevel */\n"
"    SLANG_API void spSetDebugInfoLevel(\n"
"        SlangCompileRequest*    request,\n"
"        SlangDebugInfoLevel     level);\n"
"\n"
"    /*! @see slang::ICompileRequest::setDebugInfoFormat */\n"
"    SLANG_API void spSetDebugInfoFormat(\n"
"        SlangCompileRequest*    request,\n"
"        SlangDebugInfoFormat        format);\n"
"\n"
"    /*! @see slang::ICompileRequest::setOptimizationLevel */\n"
"    SLANG_API void spSetOptimizationLevel(\n"
"        SlangCompileRequest*    request,\n"
"        SlangOptimizationLevel  level);\n"
"\n"
"\n"
"    \n"
"    /*! @see slang::ICompileRequest::setOutputContainerFormat */\n"
"    SLANG_API void spSetOutputContainerFormat(\n"
"        SlangCompileRequest*    request,\n"
"        SlangContainerFormat    format);\n"
"\n"
"    /*! @see slang::ICompileRequest::setPassThrough */\n"
"    SLANG_API void spSetPassThrough(\n"
"        SlangCompileRequest*    request,\n"
"        SlangPassThrough        passThrough);\n"
"\n"
"     /*! @see slang::ICompileRequest::setDiagnosticCallback */\n"
"    SLANG_API void spSetDiagnosticCallback(\n"
"        SlangCompileRequest*    request,\n"
"        SlangDiagnosticCallback callback,\n"
"        void const*             userData);\n"
"\n"
"    /*! @see slang::ICompileRequest::setWriter */\n"
"    SLANG_API void spSetWriter(\n"
"        SlangCompileRequest*    request,\n"
"        SlangWriterChannel      channel, \n"
"        ISlangWriter*           writer);\n"
"\n"
"    /*! @see slang::ICompileRequest::getWriter */\n"
"    SLANG_API ISlangWriter* spGetWriter(\n"
"        SlangCompileRequest*    request,\n"
"        SlangWriterChannel      channel);\n"
"\n"
"    /*! @see slang::ICompileRequest::addSearchPath */\n"
"    SLANG_API void spAddSearchPath(\n"
"        SlangCompileRequest*    request,\n"
"        const char*             searchDir);\n"
"\n"
"   /*! @see slang::ICompileRequest::addPreprocessorDefine */\n"
"    SLANG_API void spAddPreprocessorDefine(\n"
"        SlangCompileRequest*    request,\n"
"        const char*             key,\n"
"        const char*             value);\n"
"\n"
"    /*! @see slang::ICompileRequest::processCommandLineArguments */\n"
"    SLANG_API SlangResult spProcessCommandLineArguments(\n"
"        SlangCompileRequest*    request,\n"
"        char const* const*      args,\n"
"        int                     argCount);\n"
"\n"
"    /*! @see slang::ICompileRequest::addTranslationUnit */\n"
"    SLANG_API int spAddTranslationUnit(\n"
"        SlangCompileRequest*    request,\n"
"        SlangSourceLanguage     language,\n"
"        char const*             name);\n"
"\n"
"    \n"
"    /*! @see slang::ICompileRequest::setDefaultModuleName */\n"
"    SLANG_API void spSetDefaultModuleName(\n"
"        SlangCompileRequest*    request,\n"
"        const char* defaultModuleName);\n"
"\n"
"    /*! @see slang::ICompileRequest::addPreprocessorDefine */\n"
"    SLANG_API void spTranslationUnit_addPreprocessorDefine(\n"
"        SlangCompileRequest*    request,\n"
"        int                     translationUnitIndex,\n"
"        const char*             key,\n"
"        const char*             value);\n"
"\n"
"\n"
"    /*! @see slang::ICompileRequest::addTranslationUnitSourceFile */\n"
"    SLANG_API void spAddTranslationUnitSourceFile(\n"
"        SlangCompileRequest*    request,\n"
"        int                     translationUnitIndex,\n"
"        char const*             path);\n"
"\n"
"    /*! @see slang::ICompileRequest::addTranslationUnitSourceString */\n"
"    SLANG_API void spAddTranslationUnitSourceString(\n"
"        SlangCompileRequest*    request,\n"
"        int                     translationUnitIndex,\n"
"        char const*             path,\n"
"        char const*             source);\n"
"\n"
"\n"
"    /*! @see slang::ICompileRequest::addLibraryReference */\n"
"    SLANG_API SlangResult spAddLibraryReference(\n"
"        SlangCompileRequest*    request,\n"
"        const char* basePath,\n"
"        const void* libData,\n"
"        size_t libDataSize);\n"
"\n"
"    /*! @see slang::ICompileRequest::addTranslationUnitSourceStringSpan */\n"
"    SLANG_API void spAddTranslationUnitSourceStringSpan(\n"
"        SlangCompileRequest*    request,\n"
"        int                     translationUnitIndex,\n"
"        char const*             path,\n"
"        char const*             sourceBegin,\n"
"        char const*             sourceEnd);\n"
"\n"
;
sb << 
"    /*! @see slang::ICompileRequest::addTranslationUnitSourceBlob */\n"
"    SLANG_API void spAddTranslationUnitSourceBlob(\n"
"        SlangCompileRequest*    request,\n"
"        int                     translationUnitIndex,\n"
"        char const*             path,\n"
"        ISlangBlob*             sourceBlob);\n"
"\n"
"    /*! @see slang::IGlobalSession::findProfile */\n"
"    SLANG_API SlangProfileID spFindProfile(\n"
"        SlangSession*   session,\n"
"        char const*     name);\n"
"\n"
"    /*! @see slang::IGlobalSession::findCapability */\n"
"    SLANG_API SlangCapabilityID spFindCapability(\n"
"        SlangSession*   session,\n"
"        char const*     name);\n"
"\n"
"    /*! @see slang::ICompileRequest::addEntryPoint */\n"
"    SLANG_API int spAddEntryPoint(\n"
"        SlangCompileRequest*    request,\n"
"        int                     translationUnitIndex,\n"
"        char const*             name,\n"
"        SlangStage              stage);\n"
"\n"
"    /*! @see slang::ICompileRequest::addEntryPointEx */\n"
"    SLANG_API int spAddEntryPointEx(\n"
"        SlangCompileRequest*    request,\n"
"        int                     translationUnitIndex,\n"
"        char const*             name,\n"
"        SlangStage              stage,\n"
"        int                     genericArgCount,\n"
"        char const**            genericArgs);\n"
"\n"
"    /*! @see slang::ICompileRequest::setGlobalGenericArgs */\n"
"    SLANG_API SlangResult spSetGlobalGenericArgs(\n"
"        SlangCompileRequest*    request,\n"
"        int                     genericArgCount,\n"
"        char const**            genericArgs);\n"
"\n"
"    /*! @see slang::ICompileRequest::setTypeNameForGlobalExistentialTypeParam */\n"
"    SLANG_API SlangResult spSetTypeNameForGlobalExistentialTypeParam(\n"
"        SlangCompileRequest*    request,\n"
"        int                     slotIndex,\n"
"        char const*             typeName);\n"
"\n"
"    /*! @see slang::ICompileRequest::setTypeNameForEntryPointExistentialTypeParam */\n"
"    SLANG_API SlangResult spSetTypeNameForEntryPointExistentialTypeParam(\n"
"        SlangCompileRequest*    request,\n"
"        int                     entryPointIndex,\n"
"        int                     slotIndex,\n"
"        char const*             typeName);\n"
"\n"
"    /*! @see slang::ICompileRequest::compile */\n"
"    SLANG_API SlangResult spCompile(\n"
"        SlangCompileRequest*    request);\n"
"\n"
"\n"
"    /*! @see slang::ICompileRequest::getDiagnosticOutput */\n"
"    SLANG_API char const* spGetDiagnosticOutput(\n"
"        SlangCompileRequest*    request);\n"
"\n"
"    /*! @see slang::ICompileRequest::getDiagnosticOutputBlob */\n"
"    SLANG_API SlangResult spGetDiagnosticOutputBlob(\n"
"        SlangCompileRequest*    request,\n"
"        ISlangBlob**            outBlob);\n"
"\n"
"\n"
"    /*! @see slang::ICompileRequest::getDependencyFileCount */\n"
"    SLANG_API int\n"
"    spGetDependencyFileCount(\n"
"        SlangCompileRequest*    request);\n"
"\n"
"    /*! @see slang::ICompileRequest::getDependencyFilePath */\n"
"    SLANG_API char const*\n"
"    spGetDependencyFilePath(\n"
"        SlangCompileRequest*    request,\n"
"        int                     index);\n"
"\n"
"    /*! @see slang::ICompileRequest::getTranslationUnitCount */\n"
"    SLANG_API int\n"
"    spGetTranslationUnitCount(\n"
"        SlangCompileRequest*    request);\n"
"\n"
"    /*! @see slang::ICompileRequest::getEntryPointSource */\n"
"    SLANG_API char const* spGetEntryPointSource(\n"
"        SlangCompileRequest*    request,\n"
"        int                     entryPointIndex);\n"
"\n"
"    /*! @see slang::ICompileRequest::getEntryPointCode */\n"
"    SLANG_API void const* spGetEntryPointCode(\n"
"        SlangCompileRequest*    request,\n"
"        int                     entryPointIndex,\n"
"        size_t*                 outSize);\n"
"\n"
"    /*! @see slang::ICompileRequest::getEntryPointCodeBlob */\n"
"    SLANG_API SlangResult spGetEntryPointCodeBlob(\n"
"        SlangCompileRequest*    request,\n"
"        int                     entryPointIndex,\n"
"        int                     targetIndex,\n"
"        ISlangBlob**            outBlob);\n"
"\n"
"    /*! @see slang::ICompileRequest::getEntryPointHostCallable */\n"
"    SLANG_API SlangResult spGetEntryPointHostCallable(\n"
"        SlangCompileRequest*    request,\n"
"        int                     entryPointIndex,\n"
"        int                     targetIndex,\n"
"        ISlangSharedLibrary**   outSharedLibrary);\n"
"\n"
"    /*! @see slang::ICompileRequest::getTargetCodeBlob */\n"
"    SLANG_API SlangResult spGetTargetCodeBlob(\n"
"        SlangCompileRequest*    request,\n"
"        int                     targetIndex,\n"
"        ISlangBlob**            outBlob);\n"
"\n"
"    /*! @see slang::ICompileRequest::getTargetHostCallable */\n"
"    SLANG_API SlangResult spGetTargetHostCallable(\n"
"        SlangCompileRequest*    request,\n"
"        int                     targetIndex,\n"
"        ISlangSharedLibrary**   outSharedLibrary);\n"
"\n"
"    /*! @see slang::ICompileRequest::getCompileRequestCode */\n"
"    SLANG_API void const* spGetCompileRequestCode(\n"
"        SlangCompileRequest*    request,\n"
"        size_t*                 outSize);\n"
"\n"
"    /*! @see slang::ICompileRequest::getContainerCode */\n"
"    SLANG_API SlangResult spGetContainerCode(\n"
"        SlangCompileRequest*    request,\n"
"        ISlangBlob**            outBlob);\n"
"\n"
"    /*! @see slang::ICompileRequest::loadRepro */\n"
"    SLANG_API SlangResult spLoadRepro(\n"
"        SlangCompileRequest* request,\n"
"        ISlangFileSystem* fileSystem,\n"
"        const void* data,\n"
"        size_t size);\n"
"\n"
"    /*! @see slang::ICompileRequest::saveRepro */\n"
"    SLANG_API SlangResult spSaveRepro(\n"
"        SlangCompileRequest* request,\n"
"        ISlangBlob** outBlob\n"
"    );\n"
"\n"
"    /*! @see slang::ICompileRequest::enableReproCapture */\n"
"    SLANG_API SlangResult spEnableReproCapture(\n"
"        SlangCompileRequest* request);\n"
"\n"
"\n"
"    /** Extract contents of a repro.\n"
"\n"
"    Writes the contained files and manifest with their 'unique' names into fileSystem. For more details read the\n"
"    docs/repro.md documentation. \n"
"\n"
"    @param session          The slang session\n"
"    @param reproData        Holds the repro data\n"
"    @param reproDataSize    The size of the repro data\n"
"    @param fileSystem       File system that the contents of the repro will be written to\n"
"    @returns                A `SlangResult` to indicate success or failure.\n"
"    */\n"
"    SLANG_API SlangResult spExtractRepro(\n"
"        SlangSession* session,\n"
"        const void* reproData,\n"
"        size_t reproDataSize,\n"
"        ISlangMutableFileSystem* fileSystem);\n"
"\n"
"    /* Turns a repro into a file system.\n"
"\n"
"    Makes the contents of the repro available as a file system - that is able to access the files with the same\n"
"    paths as were used on the original repro file system. \n"
"\n"
"    @param session          The slang session\n"
"    @param reproData        The repro data\n"
"    @param reproDataSize    The size of the repro data\n"
"    @param replaceFileSystem  Will attempt to load by unique names from this file system before using contents of the repro. Optional.\n"
"    @param outFileSystem    The file system that can be used to access contents\n"
"    @returns                A `SlangResult` to indicate success or failure.\n"
"    */\n"
"    SLANG_API SlangResult spLoadReproAsFileSystem(\n"
"        SlangSession* session,\n"
"        const void* reproData,\n"
"        size_t reproDataSize,\n"
"        ISlangFileSystem* replaceFileSystem,\n"
"        ISlangFileSystemExt** outFileSystem);\n"
"\n"
"    /*! @see slang::ICompileRequest::overrideDiagnosticSeverity */\n"
"    SLANG_API void spOverrideDiagnosticSeverity(\n"
"        SlangCompileRequest* request,\n"
"        SlangInt messageID,\n"
"        SlangSeverity overrideSeverity);\n"
"\n"
"    /*! @see slang::ICompileRequest::getDiagnosticFlags */\n"
"    SLANG_API SlangDiagnosticFlags spGetDiagnosticFlags(SlangCompileRequest* request);\n"
"\n"
"    /*! @see slang::ICompileRequest::setDiagnosticFlags */\n"
"    SLANG_API void spSetDiagnosticFlags(SlangCompileRequest* request, SlangDiagnosticFlags flags);\n"
"\n"
"    /*\n"
"    Forward declarations of types used in the reflection interface;\n"
"    */\n"
"\n"
"    typedef struct SlangProgramLayout SlangProgramLayout;\n"
"    typedef struct SlangEntryPoint SlangEntryPoint;\n"
"    typedef struct SlangEntryPointLayout SlangEntryPointLayout;\n"
"\n"
"    typedef struct SlangReflectionModifier          SlangReflectionModifier;\n"
"    typedef struct SlangReflectionType              SlangReflectionType;\n"
"    typedef struct SlangReflectionTypeLayout        SlangReflectionTypeLayout;\n"
"    typedef struct SlangReflectionVariable          SlangReflectionVariable;\n"
"    typedef struct SlangReflectionVariableLayout    SlangReflectionVariableLayout;\n"
"    typedef struct SlangReflectionTypeParameter     SlangReflectionTypeParameter;\n"
"    typedef struct SlangReflectionUserAttribute     SlangReflectionUserAttribute;\n"
"\n"
"    /*\n"
"    Type aliases to maintain backward compatibility.\n"
"    */\n"
"    typedef SlangProgramLayout SlangReflection;\n"
"    typedef SlangEntryPointLayout SlangReflectionEntryPoint;\n"
"\n"
"    // get reflection data from a compilation request\n"
"    SLANG_API SlangReflection* spGetReflection(\n"
"        SlangCompileRequest*    request);\n"
"\n"
"    // type reflection\n"
"\n"
"    typedef unsigned int SlangTypeKindIntegral;\n"
"    enum SlangTypeKind : SlangTypeKindIntegral\n"
"    {\n"
"        SLANG_TYPE_KIND_NONE,\n"
"        SLANG_TYPE_KIND_STRUCT,\n"
"        SLANG_TYPE_KIND_ARRAY,\n"
"        SLANG_TYPE_KIND_MATRIX,\n"
"        SLANG_TYPE_KIND_VECTOR,\n"
"        SLANG_TYPE_KIND_SCALAR,\n"
"        SLANG_TYPE_KIND_CONSTANT_BUFFER,\n"
"        SLANG_TYPE_KIND_RESOURCE,\n"
"        SLANG_TYPE_KIND_SAMPLER_STATE,\n"
"        SLANG_TYPE_KIND_TEXTURE_BUFFER,\n"
"        SLANG_TYPE_KIND_SHADER_STORAGE_BUFFER,\n"
"        SLANG_TYPE_KIND_PARAMETER_BLOCK,\n"
"        SLANG_TYPE_KIND_GENERIC_TYPE_PARAMETER,\n"
"        SLANG_TYPE_KIND_INTERFACE,\n"
"        SLANG_TYPE_KIND_OUTPUT_STREAM,\n"
"        SLANG_TYPE_KIND_MESH_OUTPUT,\n"
"        SLANG_TYPE_KIND_SPECIALIZED,\n"
"        SLANG_TYPE_KIND_FEEDBACK,\n"
"        SLANG_TYPE_KIND_POINTER,\n"
"        SLANG_TYPE_KIND_COUNT,\n"
"    };\n"
"\n"
"    typedef unsigned int SlangScalarTypeIntegral;\n"
"    enum SlangScalarType : SlangScalarTypeIntegral\n"
"    {\n"
"        SLANG_SCALAR_TYPE_NONE,\n"
"        SLANG_SCALAR_TYPE_VOID,\n"
"        SLANG_SCALAR_TYPE_BOOL,\n"
"        SLANG_SCALAR_TYPE_INT32,\n"
"        SLANG_SCALAR_TYPE_UINT32,\n"
"        SLANG_SCALAR_TYPE_INT64,\n"
"        SLANG_SCALAR_TYPE_UINT64,\n"
"        SLANG_SCALAR_TYPE_FLOAT16,\n"
"        SLANG_SCALAR_TYPE_FLOAT32,\n"
"        SLANG_SCALAR_TYPE_FLOAT64,\n"
"        SLANG_SCALAR_TYPE_INT8,\n"
"        SLANG_SCALAR_TYPE_UINT8,\n"
"        SLANG_SCALAR_TYPE_INT16,\n"
"        SLANG_SCALAR_TYPE_UINT16,\n"
"        SLANG_SCALAR_TYPE_INTPTR,\n"
"        SLANG_SCALAR_TYPE_UINTPTR\n"
"    };\n"
"\n"
"#ifndef SLANG_RESOURCE_SHAPE\n"
"#    define SLANG_RESOURCE_SHAPE\n"
"    typedef unsigned int SlangResourceShapeIntegral;\n"
"    enum SlangResourceShape : SlangResourceShapeIntegral\n"
"    {\n"
"        SLANG_RESOURCE_BASE_SHAPE_MASK      = 0x0F,\n"
"\n"
"        SLANG_RESOURCE_NONE                 = 0x00,\n"
"\n"
"        SLANG_TEXTURE_1D                    = 0x01,\n"
"        SLANG_TEXTURE_2D                    = 0x02,\n"
"        SLANG_TEXTURE_3D                    = 0x03,\n"
"        SLANG_TEXTURE_CUBE                  = 0x04,\n"
"        SLANG_TEXTURE_BUFFER                = 0x05,\n"
"\n"
"        SLANG_STRUCTURED_BUFFER             = 0x06,\n"
"        SLANG_BYTE_ADDRESS_BUFFER           = 0x07,\n"
"        SLANG_RESOURCE_UNKNOWN              = 0x08,\n"
"        SLANG_ACCELERATION_STRUCTURE        = 0x09,\n"
"\n"
"        SLANG_RESOURCE_EXT_SHAPE_MASK       = 0xF0,\n"
"\n"
"        SLANG_TEXTURE_FEEDBACK_FLAG         = 0x10,\n"
"        SLANG_TEXTURE_SHADOW_FLAG           = 0x20,\n"
"        SLANG_TEXTURE_ARRAY_FLAG            = 0x40,\n"
"        SLANG_TEXTURE_MULTISAMPLE_FLAG      = 0x80,\n"
"\n"
"        SLANG_TEXTURE_1D_ARRAY              = SLANG_TEXTURE_1D   | SLANG_TEXTURE_ARRAY_FLAG,\n"
"        SLANG_TEXTURE_2D_ARRAY              = SLANG_TEXTURE_2D   | SLANG_TEXTURE_ARRAY_FLAG,\n"
"        SLANG_TEXTURE_CUBE_ARRAY            = SLANG_TEXTURE_CUBE | SLANG_TEXTURE_ARRAY_FLAG,\n"
"\n"
"        SLANG_TEXTURE_2D_MULTISAMPLE        = SLANG_TEXTURE_2D | SLANG_TEXTURE_MULTISAMPLE_FLAG,\n"
"        SLANG_TEXTURE_2D_MULTISAMPLE_ARRAY  = SLANG_TEXTURE_2D | SLANG_TEXTURE_MULTISAMPLE_FLAG | SLANG_TEXTURE_ARRAY_FLAG,\n"
"    };\n"
"#endif\n"
"    typedef unsigned int SlangResourceAccessIntegral;\n"
"    enum SlangResourceAccess : SlangResourceAccessIntegral\n"
"    {\n"
"        SLANG_RESOURCE_ACCESS_NONE,\n"
"        SLANG_RESOURCE_ACCESS_READ,\n"
"        SLANG_RESOURCE_ACCESS_READ_WRITE,\n"
"        SLANG_RESOURCE_ACCESS_RASTER_ORDERED,\n"
"        SLANG_RESOURCE_ACCESS_APPEND,\n"
"        SLANG_RESOURCE_ACCESS_CONSUME,\n"
"        SLANG_RESOURCE_ACCESS_WRITE,\n"
"        SLANG_RESOURCE_ACCESS_FEEDBACK,\n"
"        SLANG_RESOURCE_ACCESS_UNKNOWN = 0x7FFFFFFF,\n"
"    };\n"
"\n"
"    typedef unsigned int SlangParameterCategoryIntegral;\n"
"    enum SlangParameterCategory : SlangParameterCategoryIntegral\n"
"    {\n"
"        SLANG_PARAMETER_CATEGORY_NONE,\n"
"        SLANG_PARAMETER_CATEGORY_MIXED,\n"
"        SLANG_PARAMETER_CATEGORY_CONSTANT_BUFFER,\n"
"        SLANG_PARAMETER_CATEGORY_SHADER_RESOURCE,\n"
"        SLANG_PARAMETER_CATEGORY_UNORDERED_ACCESS,\n"
"        SLANG_PARAMETER_CATEGORY_VARYING_INPUT,\n"
"        SLANG_PARAMETER_CATEGORY_VARYING_OUTPUT,\n"
"        SLANG_PARAMETER_CATEGORY_SAMPLER_STATE,\n"
"        SLANG_PARAMETER_CATEGORY_UNIFORM,\n"
"        SLANG_PARAMETER_CATEGORY_DESCRIPTOR_TABLE_SLOT,\n"
"        SLANG_PARAMETER_CATEGORY_SPECIALIZATION_CONSTANT,\n"
"        SLANG_PARAMETER_CATEGORY_PUSH_CONSTANT_BUFFER,\n"
"\n"
"        // HLSL register `space`, Vulkan GLSL `set`\n"
"        SLANG_PARAMETER_CATEGORY_REGISTER_SPACE,\n"
"\n"
"        // TODO: Ellie, Both APIs treat mesh outputs as more or less varying output,\n"
"        // Does it deserve to be represented here??\n"
"\n"
"        // A parameter whose type is to be specialized by a global generic type argument\n"
"        SLANG_PARAMETER_CATEGORY_GENERIC,\n"
"\n"
"        SLANG_PARAMETER_CATEGORY_RAY_PAYLOAD,\n"
"        SLANG_PARAMETER_CATEGORY_HIT_ATTRIBUTES,\n"
"        SLANG_PARAMETER_CATEGORY_CALLABLE_PAYLOAD,\n"
"        SLANG_PARAMETER_CATEGORY_SHADER_RECORD,\n"
"\n"
"        // An existential type parameter represents a \"hole\" that\n"
"        // needs to be filled with a concrete type to enable\n"
"        // generation of specialized code.\n"
"        //\n"
"        // Consider this example:\n"
"        //\n"
"        //      struct MyParams\n"
"        //      {\n"
"        //          IMaterial material;\n"
"        //          ILight lights[3];\n"
"        //      };\n"
"        //\n"
"        // This `MyParams` type introduces two existential type parameters:\n"
"        // one for `material` and one for `lights`. Even though `lights`\n"
"        // is an array, it only introduces one type parameter, because\n"
"        // we need to hae a *single* concrete type for all the array\n"
"        // elements to be able to generate specialized code.\n"
"        //\n"
"        SLANG_PARAMETER_CATEGORY_EXISTENTIAL_TYPE_PARAM,\n"
"\n"
"        // An existential object parameter represents a value\n"
"        // that needs to be passed in to provide data for some\n"
"        // interface-type shader paameter.\n"
"        //\n"
"        // Consider this example:\n"
"        //\n"
"        //      struct MyParams\n"
"        //      {\n"
"        //          IMaterial material;\n"
"        //          ILight lights[3];\n"
"        //      };\n"
"        //\n"
"        // This `MyParams` type introduces four existential object parameters:\n"
"        // one for `material` and three for `lights` (one for each array\n"
"        // element). This is consistent with the number of interface-type\n"
"        // \"objects\" that are being passed through to the shader.\n"
"        //\n"
"        SLANG_PARAMETER_CATEGORY_EXISTENTIAL_OBJECT_PARAM,\n"
"\n"
"        // The register space offset for the sub-elements that occupies register spaces.\n"
"        SLANG_PARAMETER_CATEGORY_SUB_ELEMENT_REGISTER_SPACE,\n"
"\n"
"        //\n"
"        SLANG_PARAMETER_CATEGORY_COUNT,\n"
"\n"
"\n"
"        // DEPRECATED:\n"
"        SLANG_PARAMETER_CATEGORY_VERTEX_INPUT = SLANG_PARAMETER_CATEGORY_VARYING_INPUT,\n"
"        SLANG_PARAMETER_CATEGORY_FRAGMENT_OUTPUT = SLANG_PARAMETER_CATEGORY_VARYING_OUTPUT,\n"
"    };\n"
"\n"
"    /** Types of API-managed bindings that a parameter might use.\n"
"    \n"
"    `SlangBindingType` represents the distinct types of binding ranges that might be\n"
"    understood by an underlying graphics API or cross-API abstraction layer.\n"
"    Several of the enumeration cases here correspond to cases of `VkDescriptorType`\n"
"    defined by the Vulkan API. Note however that the values of this enumeration\n"
"    are not the same as those of any particular API.\n"
"\n"
"    The `SlangBindingType` enumeration is distinct from `SlangParameterCategory`\n"
"    because `SlangParameterCategory` differentiates the types of parameters for\n"
"    the purposes of layout, where the layout rules of some targets will treat\n"
"    parameters of different types as occupying the same binding space for layout\n"
"    (e.g., in SPIR-V both a `Texture2D` and `SamplerState` use the same space of\n"
"    `binding` indices, and are not allowed to overlap), while those same types\n"
"    map to different types of bindingsin the API (e.g., both textures and samplers\n"
"    use different `VkDescriptorType` values).\n"
"\n"
"    When you want to answer \"what register/binding did this parameter use?\" you\n"
"    should use `SlangParameterCategory`.\n"
"\n"
;
sb << 
"    When you wnat to answer \"what type of descriptor range should this parameter use?\"\n"
"    you should use `SlangBindingType`.\n"
"    */\n"
"    typedef SlangUInt32 SlangBindingTypeIntegral;\n"
"    enum SlangBindingType : SlangBindingTypeIntegral\n"
"    {\n"
"        SLANG_BINDING_TYPE_UNKNOWN = 0,\n"
"\n"
"        SLANG_BINDING_TYPE_SAMPLER,\n"
"        SLANG_BINDING_TYPE_TEXTURE,\n"
"        SLANG_BINDING_TYPE_CONSTANT_BUFFER,\n"
"        SLANG_BINDING_TYPE_PARAMETER_BLOCK,\n"
"        SLANG_BINDING_TYPE_TYPED_BUFFER,\n"
"        SLANG_BINDING_TYPE_RAW_BUFFER,\n"
"        SLANG_BINDING_TYPE_COMBINED_TEXTURE_SAMPLER,\n"
"        SLANG_BINDING_TYPE_INPUT_RENDER_TARGET,\n"
"        SLANG_BINDING_TYPE_INLINE_UNIFORM_DATA,\n"
"        SLANG_BINDING_TYPE_RAY_TRACING_ACCELERATION_STRUCTURE,\n"
"\n"
"        SLANG_BINDING_TYPE_VARYING_INPUT,\n"
"        SLANG_BINDING_TYPE_VARYING_OUTPUT,\n"
"\n"
"        SLANG_BINDING_TYPE_EXISTENTIAL_VALUE,\n"
"        SLANG_BINDING_TYPE_PUSH_CONSTANT,\n"
"\n"
"        SLANG_BINDING_TYPE_MUTABLE_FLAG = 0x100,\n"
"\n"
"        SLANG_BINDING_TYPE_MUTABLE_TETURE = SLANG_BINDING_TYPE_TEXTURE | SLANG_BINDING_TYPE_MUTABLE_FLAG,\n"
"        SLANG_BINDING_TYPE_MUTABLE_TYPED_BUFFER = SLANG_BINDING_TYPE_TYPED_BUFFER | SLANG_BINDING_TYPE_MUTABLE_FLAG,\n"
"        SLANG_BINDING_TYPE_MUTABLE_RAW_BUFFER = SLANG_BINDING_TYPE_RAW_BUFFER | SLANG_BINDING_TYPE_MUTABLE_FLAG,\n"
"\n"
"        SLANG_BINDING_TYPE_BASE_MASK = 0x00FF,\n"
"        SLANG_BINDING_TYPE_EXT_MASK  = 0xFF00,\n"
"    };\n"
"\n"
"    typedef SlangUInt32 SlangLayoutRulesIntegral;\n"
"    enum SlangLayoutRules : SlangLayoutRulesIntegral\n"
"    {\n"
"        SLANG_LAYOUT_RULES_DEFAULT,\n"
"    };\n"
"\n"
"    typedef SlangUInt32 SlangModifierIDIntegral;\n"
"    enum SlangModifierID : SlangModifierIDIntegral\n"
"    {\n"
"        SLANG_MODIFIER_SHARED,\n"
"    };\n"
"\n"
"    // User Attribute\n"
"    SLANG_API char const* spReflectionUserAttribute_GetName(SlangReflectionUserAttribute* attrib);\n"
"    SLANG_API unsigned int spReflectionUserAttribute_GetArgumentCount(SlangReflectionUserAttribute* attrib);\n"
"    SLANG_API SlangReflectionType* spReflectionUserAttribute_GetArgumentType(SlangReflectionUserAttribute* attrib, unsigned int index);\n"
"    SLANG_API SlangResult spReflectionUserAttribute_GetArgumentValueInt(SlangReflectionUserAttribute* attrib, unsigned int index, int * rs);\n"
"    SLANG_API SlangResult spReflectionUserAttribute_GetArgumentValueFloat(SlangReflectionUserAttribute* attrib, unsigned int index, float * rs);\n"
"\n"
"    /** Returns the string-typed value of a user attribute argument\n"
"        The string returned is not null-terminated. The length of the string is returned via `outSize`.\n"
"        If index of out of range, or if the specified argument is not a string, the function will return nullptr.\n"
"    */\n"
"    SLANG_API const char* spReflectionUserAttribute_GetArgumentValueString(SlangReflectionUserAttribute* attrib, unsigned int index, size_t * outSize);\n"
"\n"
"    // Type Reflection\n"
"\n"
"    SLANG_API SlangTypeKind spReflectionType_GetKind(SlangReflectionType* type);\n"
"    SLANG_API unsigned int spReflectionType_GetUserAttributeCount(SlangReflectionType* type);\n"
"    SLANG_API SlangReflectionUserAttribute* spReflectionType_GetUserAttribute(SlangReflectionType* type, unsigned int index);\n"
"    SLANG_API SlangReflectionUserAttribute* spReflectionType_FindUserAttributeByName(SlangReflectionType* type, char const* name);\n"
"\n"
"    SLANG_API unsigned int spReflectionType_GetFieldCount(SlangReflectionType* type);\n"
"    SLANG_API SlangReflectionVariable* spReflectionType_GetFieldByIndex(SlangReflectionType* type, unsigned index);\n"
"\n"
"        /** Returns the number of elements in the given type.\n"
"\n"
"        This operation is valid for vector and array types. For other types it returns zero.\n"
"\n"
"        When invoked on an unbounded-size array it will return `SLANG_UNBOUNDED_SIZE`,\n"
"        which is defined to be `~size_t(0)`.\n"
"\n"
"        If the size of a type cannot be statically computed, perhaps because it depends on\n"
"        a generic parameter that has not been bound to a specific value, this function returns zero.\n"
"        */\n"
"    SLANG_API size_t spReflectionType_GetElementCount(SlangReflectionType* type);\n"
"\n"
"    #define SLANG_UNBOUNDED_SIZE (~size_t(0))\n"
"\n"
"    SLANG_API SlangReflectionType* spReflectionType_GetElementType(SlangReflectionType* type);\n"
"\n"
"    SLANG_API unsigned int spReflectionType_GetRowCount(SlangReflectionType* type);\n"
"    SLANG_API unsigned int spReflectionType_GetColumnCount(SlangReflectionType* type);\n"
"    SLANG_API SlangScalarType spReflectionType_GetScalarType(SlangReflectionType* type);\n"
"\n"
"    SLANG_API SlangResourceShape spReflectionType_GetResourceShape(SlangReflectionType* type);\n"
"    SLANG_API SlangResourceAccess spReflectionType_GetResourceAccess(SlangReflectionType* type);\n"
"    SLANG_API SlangReflectionType* spReflectionType_GetResourceResultType(SlangReflectionType* type);\n"
"\n"
"    SLANG_API char const* spReflectionType_GetName(SlangReflectionType* type);\n"
"\n"
"    // Type Layout Reflection\n"
"\n"
"    SLANG_API SlangReflectionType* spReflectionTypeLayout_GetType(SlangReflectionTypeLayout* type);\n"
"    SLANG_API SlangTypeKind spReflectionTypeLayout_getKind(SlangReflectionTypeLayout* type);\n"
"    SLANG_API size_t spReflectionTypeLayout_GetSize(SlangReflectionTypeLayout* type, SlangParameterCategory category);\n"
"    SLANG_API size_t spReflectionTypeLayout_GetStride(SlangReflectionTypeLayout* type, SlangParameterCategory category);\n"
"    SLANG_API int32_t spReflectionTypeLayout_getAlignment(SlangReflectionTypeLayout* type, SlangParameterCategory category);\n"
"\n"
"    SLANG_API SlangReflectionVariableLayout* spReflectionTypeLayout_GetFieldByIndex(SlangReflectionTypeLayout* type, unsigned index);\n"
"\n"
"    SLANG_API SlangInt spReflectionTypeLayout_findFieldIndexByName(SlangReflectionTypeLayout* typeLayout, const char* nameBegin, const char* nameEnd);\n"
"\n"
"    SLANG_API SlangReflectionVariableLayout* spReflectionTypeLayout_GetExplicitCounter(SlangReflectionTypeLayout* typeLayout);\n"
"\n"
"    SLANG_API size_t spReflectionTypeLayout_GetElementStride(SlangReflectionTypeLayout* type, SlangParameterCategory category);\n"
"    SLANG_API SlangReflectionTypeLayout* spReflectionTypeLayout_GetElementTypeLayout(SlangReflectionTypeLayout* type);\n"
"    SLANG_API SlangReflectionVariableLayout* spReflectionTypeLayout_GetElementVarLayout(SlangReflectionTypeLayout* type);\n"
"    SLANG_API SlangReflectionVariableLayout* spReflectionTypeLayout_getContainerVarLayout(SlangReflectionTypeLayout* type);\n"
"\n"
"    SLANG_API SlangParameterCategory spReflectionTypeLayout_GetParameterCategory(SlangReflectionTypeLayout* type);\n"
"\n"
"    SLANG_API unsigned spReflectionTypeLayout_GetCategoryCount(SlangReflectionTypeLayout* type);\n"
"    SLANG_API SlangParameterCategory spReflectionTypeLayout_GetCategoryByIndex(SlangReflectionTypeLayout* type, unsigned index);\n"
"\n"
"    SLANG_API SlangMatrixLayoutMode spReflectionTypeLayout_GetMatrixLayoutMode(SlangReflectionTypeLayout* type);\n"
"\n"
"    SLANG_API int spReflectionTypeLayout_getGenericParamIndex(SlangReflectionTypeLayout* type);\n"
"\n"
"    SLANG_API SlangReflectionTypeLayout* spReflectionTypeLayout_getPendingDataTypeLayout(SlangReflectionTypeLayout* type);\n"
"\n"
"    SLANG_API SlangReflectionVariableLayout* spReflectionTypeLayout_getSpecializedTypePendingDataVarLayout(SlangReflectionTypeLayout* type);\n"
"    SLANG_API SlangInt spReflectionType_getSpecializedTypeArgCount(SlangReflectionType* type);\n"
"    SLANG_API SlangReflectionType* spReflectionType_getSpecializedTypeArgType(SlangReflectionType* type, SlangInt index);\n"
"\n"
"    SLANG_API SlangInt spReflectionTypeLayout_getBindingRangeCount(SlangReflectionTypeLayout* typeLayout);\n"
"    SLANG_API SlangBindingType spReflectionTypeLayout_getBindingRangeType(SlangReflectionTypeLayout* typeLayout, SlangInt index);\n"
"    SLANG_API SlangInt spReflectionTypeLayout_isBindingRangeSpecializable(SlangReflectionTypeLayout* typeLayout, SlangInt index);\n"
"    SLANG_API SlangInt spReflectionTypeLayout_getBindingRangeBindingCount(SlangReflectionTypeLayout* typeLayout, SlangInt index);\n"
"    SLANG_API SlangReflectionTypeLayout* spReflectionTypeLayout_getBindingRangeLeafTypeLayout(SlangReflectionTypeLayout* typeLayout, SlangInt index);\n"
"    SLANG_API SlangReflectionVariable* spReflectionTypeLayout_getBindingRangeLeafVariable(SlangReflectionTypeLayout* typeLayout, SlangInt index);\n"
"    SLANG_API SlangInt spReflectionTypeLayout_getFieldBindingRangeOffset(SlangReflectionTypeLayout* typeLayout, SlangInt fieldIndex);\n"
"    SLANG_API SlangInt spReflectionTypeLayout_getExplicitCounterBindingRangeOffset(SlangReflectionTypeLayout* inTypeLayout);\n"
"\n"
"    SLANG_API SlangInt spReflectionTypeLayout_getBindingRangeDescriptorSetIndex(SlangReflectionTypeLayout* typeLayout, SlangInt index);\n"
"    SLANG_API SlangInt spReflectionTypeLayout_getBindingRangeFirstDescriptorRangeIndex(SlangReflectionTypeLayout* typeLayout, SlangInt index);\n"
"    SLANG_API SlangInt spReflectionTypeLayout_getBindingRangeDescriptorRangeCount(SlangReflectionTypeLayout* typeLayout, SlangInt index);\n"
"\n"
"    SLANG_API SlangInt spReflectionTypeLayout_getDescriptorSetCount(SlangReflectionTypeLayout* typeLayout);\n"
"    SLANG_API SlangInt spReflectionTypeLayout_getDescriptorSetSpaceOffset(SlangReflectionTypeLayout* typeLayout, SlangInt setIndex);\n"
"    SLANG_API SlangInt spReflectionTypeLayout_getDescriptorSetDescriptorRangeCount(SlangReflectionTypeLayout* typeLayout, SlangInt setIndex);\n"
"    SLANG_API SlangInt spReflectionTypeLayout_getDescriptorSetDescriptorRangeIndexOffset(SlangReflectionTypeLayout* typeLayout, SlangInt setIndex, SlangInt rangeIndex);\n"
"    SLANG_API SlangInt spReflectionTypeLayout_getDescriptorSetDescriptorRangeDescriptorCount(SlangReflectionTypeLayout* typeLayout, SlangInt setIndex, SlangInt rangeIndex);\n"
"    SLANG_API SlangBindingType spReflectionTypeLayout_getDescriptorSetDescriptorRangeType(SlangReflectionTypeLayout* typeLayout, SlangInt setIndex, SlangInt rangeIndex);\n"
"    SLANG_API SlangParameterCategory spReflectionTypeLayout_getDescriptorSetDescriptorRangeCategory(SlangReflectionTypeLayout* typeLayout, SlangInt setIndex, SlangInt rangeIndex);\n"
"\n"
"    SLANG_API SlangInt spReflectionTypeLayout_getSubObjectRangeCount(SlangReflectionTypeLayout* typeLayout);\n"
"    SLANG_API SlangInt spReflectionTypeLayout_getSubObjectRangeBindingRangeIndex(SlangReflectionTypeLayout* typeLayout, SlangInt subObjectRangeIndex);\n"
"    SLANG_API SlangInt spReflectionTypeLayout_getSubObjectRangeSpaceOffset(SlangReflectionTypeLayout* typeLayout, SlangInt subObjectRangeIndex);\n"
"    SLANG_API SlangReflectionVariableLayout* spReflectionTypeLayout_getSubObjectRangeOffset(SlangReflectionTypeLayout* typeLayout, SlangInt subObjectRangeIndex);\n"
"\n"
"#if 0\n"
"    SLANG_API SlangInt spReflectionTypeLayout_getSubObjectRangeCount(SlangReflectionTypeLayout* typeLayout);\n"
"    SLANG_API SlangInt spReflectionTypeLayout_getSubObjectRangeObjectCount(SlangReflectionTypeLayout* typeLayout, SlangInt index);\n"
"    SLANG_API SlangInt spReflectionTypeLayout_getSubObjectRangeBindingRangeIndex(SlangReflectionTypeLayout* typeLayout, SlangInt index);\n"
"    SLANG_API SlangReflectionTypeLayout* spReflectionTypeLayout_getSubObjectRangeTypeLayout(SlangReflectionTypeLayout* typeLayout, SlangInt index);\n"
"\n"
"    SLANG_API SlangInt spReflectionTypeLayout_getSubObjectRangeDescriptorRangeCount(SlangReflectionTypeLayout* typeLayout, SlangInt subObjectRangeIndex);\n"
"    SLANG_API SlangBindingType spReflectionTypeLayout_getSubObjectRangeDescriptorRangeBindingType(SlangReflectionTypeLayout* typeLayout, SlangInt subObjectRangeIndex, SlangInt bindingRangeIndexInSubObject);\n"
"    SLANG_API SlangInt spReflectionTypeLayout_getSubObjectRangeDescriptorRangeBindingCount(SlangReflectionTypeLayout* typeLayout, SlangInt subObjectRangeIndex, SlangInt bindingRangeIndexInSubObject);\n"
"    SLANG_API SlangInt spReflectionTypeLayout_getSubObjectRangeDescriptorRangeIndexOffset(SlangReflectionTypeLayout* typeLayout, SlangInt subObjectRangeIndex, SlangInt bindingRangeIndexInSubObject);\n"
"    SLANG_API SlangInt spReflectionTypeLayout_getSubObjectRangeDescriptorRangeSpaceOffset(SlangReflectionTypeLayout* typeLayout, SlangInt subObjectRangeIndex, SlangInt bindingRangeIndexInSubObject);\n"
"#endif\n"
"\n"
"    // Variable Reflection\n"
"\n"
"    SLANG_API char const* spReflectionVariable_GetName(SlangReflectionVariable* var);\n"
"    SLANG_API SlangReflectionType* spReflectionVariable_GetType(SlangReflectionVariable* var);\n"
"    SLANG_API SlangReflectionModifier* spReflectionVariable_FindModifier(SlangReflectionVariable* var, SlangModifierID modifierID);\n"
"    SLANG_API unsigned int spReflectionVariable_GetUserAttributeCount(SlangReflectionVariable* var);\n"
"    SLANG_API SlangReflectionUserAttribute* spReflectionVariable_GetUserAttribute(SlangReflectionVariable* var, unsigned int index);\n"
"    SLANG_API SlangReflectionUserAttribute* spReflectionVariable_FindUserAttributeByName(SlangReflectionVariable* var, SlangSession * session, char const* name);\n"
"\n"
"    // Variable Layout Reflection\n"
"\n"
"    SLANG_API SlangReflectionVariable* spReflectionVariableLayout_GetVariable(SlangReflectionVariableLayout* var);\n"
"\n"
"    SLANG_API SlangReflectionTypeLayout* spReflectionVariableLayout_GetTypeLayout(SlangReflectionVariableLayout* var);\n"
"\n"
"    SLANG_API size_t spReflectionVariableLayout_GetOffset(SlangReflectionVariableLayout* var, SlangParameterCategory category);\n"
"    SLANG_API size_t spReflectionVariableLayout_GetSpace(SlangReflectionVariableLayout* var, SlangParameterCategory category);\n"
"\n"
"    SLANG_API char const* spReflectionVariableLayout_GetSemanticName(SlangReflectionVariableLayout* var);\n"
"    SLANG_API size_t spReflectionVariableLayout_GetSemanticIndex(SlangReflectionVariableLayout* var);\n"
"\n"
"    /** Get the stage that a variable belongs to (if any).\n"
"\n"
"    A variable \"belongs\" to a specific stage when it is a varying input/output\n"
"    parameter either defined as part of the parameter list for an entry\n"
"    point *or* at the global scope of a stage-specific GLSL code file (e.g.,\n"
"    an `in` parameter in a GLSL `.vs` file belongs to the vertex stage).\n"
"    */\n"
"    SLANG_API SlangStage spReflectionVariableLayout_getStage(\n"
"        SlangReflectionVariableLayout* var);\n"
"\n"
"\n"
"    SLANG_API SlangReflectionVariableLayout* spReflectionVariableLayout_getPendingDataLayout(SlangReflectionVariableLayout* var);\n"
"\n"
"    // Shader Parameter Reflection\n"
"\n"
"    typedef SlangReflectionVariableLayout SlangReflectionParameter;\n"
"\n"
"    SLANG_API unsigned spReflectionParameter_GetBindingIndex(SlangReflectionParameter* parameter);\n"
"    SLANG_API unsigned spReflectionParameter_GetBindingSpace(SlangReflectionParameter* parameter);\n"
"\n"
"    SLANG_API SlangResult spIsParameterLocationUsed(\n"
"        SlangCompileRequest* request,\n"
"        SlangInt entryPointIndex,\n"
"        SlangInt targetIndex,\n"
"        SlangParameterCategory category, // is this a `t` register? `s` register?\n"
"        SlangUInt spaceIndex,      // `space` for D3D12, `set` for Vulkan\n"
"        SlangUInt registerIndex,   // `register` for D3D12, `binding` for Vulkan\n"
"        bool& outUsed);\n"
"\n"
"    // Entry Point Reflection\n"
"\n"
"    SLANG_API char const* spReflectionEntryPoint_getName(\n"
"        SlangReflectionEntryPoint* entryPoint);\n"
"\n"
"    SLANG_API char const* spReflectionEntryPoint_getNameOverride(\n"
"        SlangReflectionEntryPoint* entryPoint);\n"
"\n"
"    SLANG_API unsigned spReflectionEntryPoint_getParameterCount(\n"
"        SlangReflectionEntryPoint* entryPoint);\n"
"\n"
"    SLANG_API SlangReflectionVariableLayout* spReflectionEntryPoint_getParameterByIndex(\n"
"        SlangReflectionEntryPoint*  entryPoint,\n"
"        unsigned                    index);\n"
"\n"
"    SLANG_API SlangStage spReflectionEntryPoint_getStage(SlangReflectionEntryPoint* entryPoint);\n"
"\n"
"    SLANG_API void spReflectionEntryPoint_getComputeThreadGroupSize(\n"
"        SlangReflectionEntryPoint*  entryPoint,\n"
"        SlangUInt                   axisCount,\n"
"        SlangUInt*                  outSizeAlongAxis);\n"
"\n"
"    SLANG_API int spReflectionEntryPoint_usesAnySampleRateInput(\n"
"        SlangReflectionEntryPoint* entryPoint);\n"
"\n"
"    SLANG_API SlangReflectionVariableLayout* spReflectionEntryPoint_getVarLayout(\n"
"        SlangReflectionEntryPoint* entryPoint);\n"
"\n"
"    SLANG_API SlangReflectionVariableLayout* spReflectionEntryPoint_getResultVarLayout(\n"
"        SlangReflectionEntryPoint* entryPoint);\n"
"\n"
"    SLANG_API int spReflectionEntryPoint_hasDefaultConstantBuffer(\n"
"        SlangReflectionEntryPoint* entryPoint);\n"
"\n"
"    // SlangReflectionTypeParameter\n"
"    SLANG_API char const* spReflectionTypeParameter_GetName(SlangReflectionTypeParameter* typeParam);\n"
"    SLANG_API unsigned spReflectionTypeParameter_GetIndex(SlangReflectionTypeParameter* typeParam);\n"
"    SLANG_API unsigned spReflectionTypeParameter_GetConstraintCount(SlangReflectionTypeParameter* typeParam);\n"
"    SLANG_API SlangReflectionType* spReflectionTypeParameter_GetConstraintByIndex(SlangReflectionTypeParameter* typeParam, unsigned int index);\n"
"\n"
;
sb << 
"    // Shader Reflection\n"
"\n"
"    SLANG_API unsigned spReflection_GetParameterCount(SlangReflection* reflection);\n"
"    SLANG_API SlangReflectionParameter* spReflection_GetParameterByIndex(SlangReflection* reflection, unsigned index);\n"
"\n"
"    SLANG_API unsigned int spReflection_GetTypeParameterCount(SlangReflection* reflection);\n"
"    SLANG_API SlangReflectionTypeParameter* spReflection_GetTypeParameterByIndex(SlangReflection* reflection, unsigned int index);\n"
"    SLANG_API SlangReflectionTypeParameter* spReflection_FindTypeParameter(SlangReflection* reflection, char const* name);\n"
"\n"
"    SLANG_API SlangReflectionType* spReflection_FindTypeByName(SlangReflection* reflection, char const* name);\n"
"    SLANG_API SlangReflectionTypeLayout* spReflection_GetTypeLayout(SlangReflection* reflection, SlangReflectionType* reflectionType, SlangLayoutRules rules);\n"
"\n"
"    SLANG_API SlangUInt spReflection_getEntryPointCount(SlangReflection* reflection);\n"
"    SLANG_API SlangReflectionEntryPoint* spReflection_getEntryPointByIndex(SlangReflection* reflection, SlangUInt index);\n"
"    SLANG_API SlangReflectionEntryPoint* spReflection_findEntryPointByName(SlangReflection* reflection, char const* name);\n"
"\n"
"    SLANG_API SlangUInt spReflection_getGlobalConstantBufferBinding(SlangReflection* reflection);\n"
"    SLANG_API size_t spReflection_getGlobalConstantBufferSize(SlangReflection* reflection);\n"
"\n"
"    SLANG_API  SlangReflectionType* spReflection_specializeType(\n"
"        SlangReflection*            reflection,\n"
"        SlangReflectionType*        type,\n"
"        SlangInt                    specializationArgCount,\n"
"        SlangReflectionType* const* specializationArgs,\n"
"        ISlangBlob**                outDiagnostics);\n"
"\n"
"        /// Get the number of hashed strings\n"
"    SLANG_API SlangUInt spReflection_getHashedStringCount(\n"
"        SlangReflection*  reflection);\n"
"\n"
"        /// Get a hashed string. The number of chars is written in outCount.\n"
"        /// The count does *NOT* including terminating 0. The returned string will be 0 terminated. \n"
"    SLANG_API const char* spReflection_getHashedString(\n"
"        SlangReflection*  reflection,\n"
"        SlangUInt index,\n"
"        size_t* outCount);\n"
"\n"
"        /// Compute a string hash.\n"
"        /// Count should *NOT* include terminating zero.\n"
"    SLANG_API SlangUInt32 spComputeStringHash(const char* chars, size_t count);\n"
"\n"
"        /// Get a type layout representing reflection information for the global-scope prameters.\n"
"    SLANG_API SlangReflectionTypeLayout* spReflection_getGlobalParamsTypeLayout(\n"
"        SlangReflection* reflection);\n"
"\n"
"        /// Get a variable layout representing reflection information for the global-scope prameters.\n"
"    SLANG_API SlangReflectionVariableLayout* spReflection_getGlobalParamsVarLayout(\n"
"        SlangReflection* reflection);\n"
"\n"
"}\n"
"#ifdef __cplusplus\n"
"\n"
"namespace slang\n"
"{\n"
"    struct ISession;\n"
"}\n"
"\n"
"SLANG_API slang::ISession* spReflection_GetSession(SlangReflection* reflection);\n"
"\n"
"/* Helper interfaces for C++ users */\n"
"namespace slang\n"
"{\n"
"    struct BufferReflection;\n"
"    struct TypeLayoutReflection;\n"
"    struct TypeReflection;\n"
"    struct VariableLayoutReflection;\n"
"    struct VariableReflection;\n"
"    \n"
"    struct UserAttribute\n"
"    {\n"
"        char const* getName()\n"
"        {\n"
"            return spReflectionUserAttribute_GetName((SlangReflectionUserAttribute*)this);\n"
"        }\n"
"        uint32_t getArgumentCount()\n"
"        {\n"
"            return (uint32_t)spReflectionUserAttribute_GetArgumentCount((SlangReflectionUserAttribute*)this);\n"
"        }\n"
"        TypeReflection* getArgumentType(uint32_t index)\n"
"        {\n"
"            return (TypeReflection*)spReflectionUserAttribute_GetArgumentType((SlangReflectionUserAttribute*)this, index);\n"
"        }\n"
"        SlangResult getArgumentValueInt(uint32_t index, int * value)\n"
"        {\n"
"            return spReflectionUserAttribute_GetArgumentValueInt((SlangReflectionUserAttribute*)this, index, value);\n"
"        }\n"
"        SlangResult getArgumentValueFloat(uint32_t index, float * value)\n"
"        {\n"
"            return spReflectionUserAttribute_GetArgumentValueFloat((SlangReflectionUserAttribute*)this, index, value);\n"
"        }\n"
"        const char* getArgumentValueString(uint32_t index, size_t * outSize)\n"
"        {\n"
"            return spReflectionUserAttribute_GetArgumentValueString((SlangReflectionUserAttribute*)this, index, outSize);\n"
"        }\n"
"    };\n"
"\n"
"    struct TypeReflection\n"
"    {\n"
"        enum class Kind\n"
"        {\n"
"            None    = SLANG_TYPE_KIND_NONE,\n"
"            Struct  = SLANG_TYPE_KIND_STRUCT,\n"
"            Array   = SLANG_TYPE_KIND_ARRAY,\n"
"            Matrix  = SLANG_TYPE_KIND_MATRIX,\n"
"            Vector  = SLANG_TYPE_KIND_VECTOR,\n"
"            Scalar  = SLANG_TYPE_KIND_SCALAR,\n"
"            ConstantBuffer = SLANG_TYPE_KIND_CONSTANT_BUFFER,\n"
"            Resource = SLANG_TYPE_KIND_RESOURCE,\n"
"            SamplerState = SLANG_TYPE_KIND_SAMPLER_STATE,\n"
"            TextureBuffer = SLANG_TYPE_KIND_TEXTURE_BUFFER,\n"
"            ShaderStorageBuffer = SLANG_TYPE_KIND_SHADER_STORAGE_BUFFER,\n"
"            ParameterBlock = SLANG_TYPE_KIND_PARAMETER_BLOCK,\n"
"            GenericTypeParameter = SLANG_TYPE_KIND_GENERIC_TYPE_PARAMETER,\n"
"            Interface = SLANG_TYPE_KIND_INTERFACE,\n"
"            OutputStream = SLANG_TYPE_KIND_OUTPUT_STREAM,\n"
"            Specialized = SLANG_TYPE_KIND_SPECIALIZED,\n"
"            Feedback = SLANG_TYPE_KIND_FEEDBACK,\n"
"            Pointer = SLANG_TYPE_KIND_POINTER,\n"
"        };\n"
"\n"
"        enum ScalarType : SlangScalarTypeIntegral\n"
"        {\n"
"            None    = SLANG_SCALAR_TYPE_NONE,\n"
"            Void    = SLANG_SCALAR_TYPE_VOID,\n"
"            Bool    = SLANG_SCALAR_TYPE_BOOL,\n"
"            Int32   = SLANG_SCALAR_TYPE_INT32,\n"
"            UInt32  = SLANG_SCALAR_TYPE_UINT32,\n"
"            Int64   = SLANG_SCALAR_TYPE_INT64,\n"
"            UInt64  = SLANG_SCALAR_TYPE_UINT64,\n"
"            Float16 = SLANG_SCALAR_TYPE_FLOAT16,\n"
"            Float32 = SLANG_SCALAR_TYPE_FLOAT32,\n"
"            Float64 = SLANG_SCALAR_TYPE_FLOAT64,\n"
"            Int8    = SLANG_SCALAR_TYPE_INT8,\n"
"            UInt8   = SLANG_SCALAR_TYPE_UINT8,\n"
"            Int16   = SLANG_SCALAR_TYPE_INT16,\n"
"            UInt16  = SLANG_SCALAR_TYPE_UINT16,\n"
"        };\n"
"\n"
"        Kind getKind()\n"
"        {\n"
"            return (Kind) spReflectionType_GetKind((SlangReflectionType*) this);\n"
"        }\n"
"\n"
"        // only useful if `getKind() == Kind::Struct`\n"
"        unsigned int getFieldCount()\n"
"        {\n"
"            return spReflectionType_GetFieldCount((SlangReflectionType*) this);\n"
"        }\n"
"\n"
"        VariableReflection* getFieldByIndex(unsigned int index)\n"
"        {\n"
"            return (VariableReflection*) spReflectionType_GetFieldByIndex((SlangReflectionType*) this, index);\n"
"        }\n"
"\n"
"        bool isArray() { return getKind() == TypeReflection::Kind::Array; }\n"
"\n"
"        TypeReflection* unwrapArray()\n"
"        {\n"
"            TypeReflection* type = this;\n"
"            while( type->isArray() )\n"
"            {\n"
"                type = type->getElementType();\n"
"            }\n"
"            return type;\n"
"        }\n"
"\n"
"        // only useful if `getKind() == Kind::Array`\n"
"        size_t getElementCount()\n"
"        {\n"
"            return spReflectionType_GetElementCount((SlangReflectionType*) this);\n"
"        }\n"
"\n"
"        size_t getTotalArrayElementCount()\n"
"        {\n"
"            if(!isArray()) return 0;\n"
"            size_t result = 1;\n"
"            TypeReflection* type = this;\n"
"            for(;;)\n"
"            {\n"
"                if(!type->isArray())\n"
"                    return result;\n"
"\n"
"                result *= type->getElementCount();\n"
"                type = type->getElementType();\n"
"            }\n"
"        }\n"
"\n"
"        TypeReflection* getElementType()\n"
"        {\n"
"            return (TypeReflection*) spReflectionType_GetElementType((SlangReflectionType*) this);\n"
"        }\n"
"\n"
"        unsigned getRowCount()\n"
"        {\n"
"            return spReflectionType_GetRowCount((SlangReflectionType*) this);\n"
"        }\n"
"\n"
"        unsigned getColumnCount()\n"
"        {\n"
"            return spReflectionType_GetColumnCount((SlangReflectionType*) this);\n"
"        }\n"
"\n"
"        ScalarType getScalarType()\n"
"        {\n"
"            return (ScalarType) spReflectionType_GetScalarType((SlangReflectionType*) this);\n"
"        }\n"
"\n"
"        TypeReflection* getResourceResultType()\n"
"        {\n"
"            return (TypeReflection*) spReflectionType_GetResourceResultType((SlangReflectionType*) this);\n"
"        }\n"
"\n"
"        SlangResourceShape getResourceShape()\n"
"        {\n"
"            return spReflectionType_GetResourceShape((SlangReflectionType*) this);\n"
"        }\n"
"\n"
"        SlangResourceAccess getResourceAccess()\n"
"        {\n"
"            return spReflectionType_GetResourceAccess((SlangReflectionType*) this);\n"
"        }\n"
"\n"
"        char const* getName()\n"
"        {\n"
"            return spReflectionType_GetName((SlangReflectionType*) this);\n"
"        }\n"
"\n"
"        unsigned int getUserAttributeCount()\n"
"        {\n"
"            return spReflectionType_GetUserAttributeCount((SlangReflectionType*)this);\n"
"        }\n"
"        UserAttribute* getUserAttributeByIndex(unsigned int index)\n"
"        {\n"
"            return (UserAttribute*)spReflectionType_GetUserAttribute((SlangReflectionType*)this, index);\n"
"        }\n"
"        UserAttribute* findUserAttributeByName(char const* name)\n"
"        {\n"
"            return (UserAttribute*)spReflectionType_FindUserAttributeByName((SlangReflectionType*)this, name);\n"
"        }\n"
"    };\n"
"\n"
"    enum ParameterCategory : SlangParameterCategoryIntegral\n"
"    {\n"
"        // TODO: these aren't scoped...\n"
"        None = SLANG_PARAMETER_CATEGORY_NONE,\n"
"        Mixed = SLANG_PARAMETER_CATEGORY_MIXED,\n"
"        ConstantBuffer = SLANG_PARAMETER_CATEGORY_CONSTANT_BUFFER,\n"
"        ShaderResource = SLANG_PARAMETER_CATEGORY_SHADER_RESOURCE,\n"
"        UnorderedAccess = SLANG_PARAMETER_CATEGORY_UNORDERED_ACCESS,\n"
"        VaryingInput = SLANG_PARAMETER_CATEGORY_VARYING_INPUT,\n"
"        VaryingOutput = SLANG_PARAMETER_CATEGORY_VARYING_OUTPUT,\n"
"        SamplerState = SLANG_PARAMETER_CATEGORY_SAMPLER_STATE,\n"
"        Uniform = SLANG_PARAMETER_CATEGORY_UNIFORM,\n"
"        DescriptorTableSlot = SLANG_PARAMETER_CATEGORY_DESCRIPTOR_TABLE_SLOT,\n"
"        SpecializationConstant = SLANG_PARAMETER_CATEGORY_SPECIALIZATION_CONSTANT,\n"
"        PushConstantBuffer = SLANG_PARAMETER_CATEGORY_PUSH_CONSTANT_BUFFER,\n"
"        RegisterSpace = SLANG_PARAMETER_CATEGORY_REGISTER_SPACE,\n"
"        GenericResource = SLANG_PARAMETER_CATEGORY_GENERIC,\n"
"\n"
"        RayPayload = SLANG_PARAMETER_CATEGORY_RAY_PAYLOAD,\n"
"        HitAttributes = SLANG_PARAMETER_CATEGORY_HIT_ATTRIBUTES,\n"
"        CallablePayload = SLANG_PARAMETER_CATEGORY_CALLABLE_PAYLOAD,\n"
"\n"
"        ShaderRecord = SLANG_PARAMETER_CATEGORY_SHADER_RECORD,\n"
"\n"
"        ExistentialTypeParam = SLANG_PARAMETER_CATEGORY_EXISTENTIAL_TYPE_PARAM,\n"
"        ExistentialObjectParam = SLANG_PARAMETER_CATEGORY_EXISTENTIAL_OBJECT_PARAM,\n"
"\n"
"        SubElementRegisterSpace = SLANG_PARAMETER_CATEGORY_SUB_ELEMENT_REGISTER_SPACE,\n"
"\n"
"        // DEPRECATED:\n"
"        VertexInput = SLANG_PARAMETER_CATEGORY_VERTEX_INPUT,\n"
"        FragmentOutput = SLANG_PARAMETER_CATEGORY_FRAGMENT_OUTPUT,\n"
"    };\n"
"\n"
"    enum class BindingType : SlangBindingTypeIntegral\n"
"    {\n"
"        Unknown                             = SLANG_BINDING_TYPE_UNKNOWN,\n"
"\n"
"        Sampler                             = SLANG_BINDING_TYPE_SAMPLER,\n"
"        Texture                             = SLANG_BINDING_TYPE_TEXTURE,\n"
"        ConstantBuffer                      = SLANG_BINDING_TYPE_CONSTANT_BUFFER,\n"
"        ParameterBlock                      = SLANG_BINDING_TYPE_PARAMETER_BLOCK,\n"
"        TypedBuffer                         = SLANG_BINDING_TYPE_TYPED_BUFFER,\n"
"        RawBuffer                           = SLANG_BINDING_TYPE_RAW_BUFFER,\n"
"        CombinedTextureSampler              = SLANG_BINDING_TYPE_COMBINED_TEXTURE_SAMPLER,\n"
"        InputRenderTarget                   = SLANG_BINDING_TYPE_INPUT_RENDER_TARGET,\n"
"        InlineUniformData                   = SLANG_BINDING_TYPE_INLINE_UNIFORM_DATA,\n"
"        RayTracingAccelerationStructure     = SLANG_BINDING_TYPE_RAY_TRACING_ACCELERATION_STRUCTURE,\n"
"        VaryingInput                        = SLANG_BINDING_TYPE_VARYING_INPUT,\n"
"        VaryingOutput                       = SLANG_BINDING_TYPE_VARYING_OUTPUT,\n"
"        ExistentialValue                    = SLANG_BINDING_TYPE_EXISTENTIAL_VALUE,\n"
"        PushConstant                        = SLANG_BINDING_TYPE_PUSH_CONSTANT,\n"
"\n"
"        MutableFlag                         = SLANG_BINDING_TYPE_MUTABLE_FLAG,\n"
"\n"
"        MutableTexture                      = SLANG_BINDING_TYPE_MUTABLE_TETURE,\n"
"        MutableTypedBuffer                  = SLANG_BINDING_TYPE_MUTABLE_TYPED_BUFFER,\n"
"        MutableRawBuffer                    = SLANG_BINDING_TYPE_MUTABLE_RAW_BUFFER,\n"
"\n"
"        BaseMask                            = SLANG_BINDING_TYPE_BASE_MASK,\n"
"        ExtMask                             = SLANG_BINDING_TYPE_EXT_MASK,\n"
"    };\n"
"\n"
"    struct TypeLayoutReflection\n"
"    {\n"
"        TypeReflection* getType()\n"
"        {\n"
"            return (TypeReflection*) spReflectionTypeLayout_GetType((SlangReflectionTypeLayout*) this);\n"
"        }\n"
"\n"
"        TypeReflection::Kind getKind()\n"
"        {\n"
"            return (TypeReflection::Kind) spReflectionTypeLayout_getKind((SlangReflectionTypeLayout*) this);\n"
"        }\n"
"\n"
"        size_t getSize(SlangParameterCategory category = SLANG_PARAMETER_CATEGORY_UNIFORM)\n"
"        {\n"
"            return spReflectionTypeLayout_GetSize((SlangReflectionTypeLayout*) this, category);\n"
"        }\n"
"\n"
"        size_t getStride(SlangParameterCategory category = SLANG_PARAMETER_CATEGORY_UNIFORM)\n"
"        {\n"
"            return spReflectionTypeLayout_GetStride((SlangReflectionTypeLayout*) this, category);\n"
"        }\n"
"\n"
"        int32_t getAlignment(SlangParameterCategory category = SLANG_PARAMETER_CATEGORY_UNIFORM)\n"
"        {\n"
"            return spReflectionTypeLayout_getAlignment((SlangReflectionTypeLayout*) this, category);\n"
"        }\n"
"\n"
"        unsigned int getFieldCount()\n"
"        {\n"
"            return getType()->getFieldCount();\n"
"        }\n"
"\n"
"        VariableLayoutReflection* getFieldByIndex(unsigned int index)\n"
"        {\n"
"            return (VariableLayoutReflection*) spReflectionTypeLayout_GetFieldByIndex((SlangReflectionTypeLayout*) this, index);\n"
"        }\n"
"\n"
"        SlangInt findFieldIndexByName(char const* nameBegin, char const* nameEnd = nullptr)\n"
"        {\n"
"            return spReflectionTypeLayout_findFieldIndexByName((SlangReflectionTypeLayout*) this, nameBegin, nameEnd);\n"
"        }\n"
"\n"
"        VariableLayoutReflection* getExplicitCounter()\n"
"        {\n"
"            return (VariableLayoutReflection*) spReflectionTypeLayout_GetExplicitCounter((SlangReflectionTypeLayout*) this);\n"
"        }\n"
"\n"
"        bool isArray() { return getType()->isArray(); }\n"
"\n"
"        TypeLayoutReflection* unwrapArray()\n"
"        {\n"
"            TypeLayoutReflection* typeLayout = this;\n"
"            while( typeLayout->isArray() )\n"
"            {\n"
"                typeLayout = typeLayout->getElementTypeLayout();\n"
"            }\n"
"            return typeLayout;\n"
"        }\n"
"\n"
"        // only useful if `getKind() == Kind::Array`\n"
"        size_t getElementCount()\n"
"        {\n"
"            return getType()->getElementCount();\n"
"        }\n"
"\n"
"        size_t getTotalArrayElementCount()\n"
"        {\n"
"            return getType()->getTotalArrayElementCount();\n"
"        }\n"
"\n"
"        size_t getElementStride(SlangParameterCategory category)\n"
"        {\n"
"            return spReflectionTypeLayout_GetElementStride((SlangReflectionTypeLayout*) this, category);\n"
"        }\n"
"\n"
"        TypeLayoutReflection* getElementTypeLayout()\n"
"        {\n"
"            return (TypeLayoutReflection*) spReflectionTypeLayout_GetElementTypeLayout((SlangReflectionTypeLayout*) this);\n"
"        }\n"
"\n"
"        VariableLayoutReflection* getElementVarLayout()\n"
"        {\n"
"            return (VariableLayoutReflection*)spReflectionTypeLayout_GetElementVarLayout((SlangReflectionTypeLayout*) this);\n"
"        }\n"
"\n"
"        VariableLayoutReflection* getContainerVarLayout()\n"
"        {\n"
"            return (VariableLayoutReflection*)spReflectionTypeLayout_getContainerVarLayout((SlangReflectionTypeLayout*) this);\n"
"        }\n"
"\n"
"        // How is this type supposed to be bound?\n"
"        ParameterCategory getParameterCategory()\n"
"        {\n"
"            return (ParameterCategory) spReflectionTypeLayout_GetParameterCategory((SlangReflectionTypeLayout*) this);\n"
"        }\n"
"\n"
"        unsigned int getCategoryCount()\n"
"        {\n"
"            return spReflectionTypeLayout_GetCategoryCount((SlangReflectionTypeLayout*) this);\n"
"        }\n"
"\n"
"        ParameterCategory getCategoryByIndex(unsigned int index)\n"
"        {\n"
"            return (ParameterCategory) spReflectionTypeLayout_GetCategoryByIndex((SlangReflectionTypeLayout*) this, index);\n"
"        }\n"
"\n"
"        unsigned getRowCount()\n"
"        {\n"
"            return getType()->getRowCount();\n"
"        }\n"
"\n"
"        unsigned getColumnCount()\n"
"        {\n"
"            return getType()->getColumnCount();\n"
"        }\n"
"\n"
"        TypeReflection::ScalarType getScalarType()\n"
"        {\n"
"            return getType()->getScalarType();\n"
;
sb << 
"        }\n"
"\n"
"        TypeReflection* getResourceResultType()\n"
"        {\n"
"            return getType()->getResourceResultType();\n"
"        }\n"
"\n"
"        SlangResourceShape getResourceShape()\n"
"        {\n"
"            return getType()->getResourceShape();\n"
"        }\n"
"\n"
"        SlangResourceAccess getResourceAccess()\n"
"        {\n"
"            return getType()->getResourceAccess();\n"
"        }\n"
"\n"
"        char const* getName()\n"
"        {\n"
"            return getType()->getName();\n"
"        }\n"
"\n"
"        SlangMatrixLayoutMode getMatrixLayoutMode()\n"
"        {\n"
"            return spReflectionTypeLayout_GetMatrixLayoutMode((SlangReflectionTypeLayout*) this);\n"
"        }\n"
"\n"
"        int getGenericParamIndex()\n"
"        {\n"
"            return spReflectionTypeLayout_getGenericParamIndex(\n"
"                (SlangReflectionTypeLayout*) this);\n"
"        }\n"
"\n"
"        TypeLayoutReflection* getPendingDataTypeLayout()\n"
"        {\n"
"            return (TypeLayoutReflection*) spReflectionTypeLayout_getPendingDataTypeLayout(\n"
"                (SlangReflectionTypeLayout*) this);\n"
"        }\n"
"\n"
"        VariableLayoutReflection* getSpecializedTypePendingDataVarLayout()\n"
"        {\n"
"            return (VariableLayoutReflection*) spReflectionTypeLayout_getSpecializedTypePendingDataVarLayout(\n"
"                (SlangReflectionTypeLayout*) this);\n"
"        }\n"
"\n"
"        SlangInt getBindingRangeCount()\n"
"        {\n"
"            return spReflectionTypeLayout_getBindingRangeCount(\n"
"                (SlangReflectionTypeLayout*) this);\n"
"        }\n"
"\n"
"        BindingType getBindingRangeType(SlangInt index)\n"
"        {\n"
"            return (BindingType) spReflectionTypeLayout_getBindingRangeType(\n"
"                (SlangReflectionTypeLayout*) this,\n"
"                index);\n"
"        }\n"
"\n"
"        bool isBindingRangeSpecializable(SlangInt index)\n"
"        {\n"
"            return (bool)spReflectionTypeLayout_isBindingRangeSpecializable(\n"
"                (SlangReflectionTypeLayout*)this,\n"
"                index);\n"
"\n"
"        }\n"
"\n"
"        SlangInt getBindingRangeBindingCount(SlangInt index)\n"
"        {\n"
"            return spReflectionTypeLayout_getBindingRangeBindingCount(\n"
"                (SlangReflectionTypeLayout*) this,\n"
"                index);\n"
"        }\n"
"\n"
"        /*\n"
"        SlangInt getBindingRangeIndexOffset(SlangInt index)\n"
"        {\n"
"            return spReflectionTypeLayout_getBindingRangeIndexOffset(\n"
"                (SlangReflectionTypeLayout*) this,\n"
"                index);\n"
"        }\n"
"\n"
"        SlangInt getBindingRangeSpaceOffset(SlangInt index)\n"
"        {\n"
"            return spReflectionTypeLayout_getBindingRangeSpaceOffset(\n"
"                (SlangReflectionTypeLayout*) this,\n"
"                index);\n"
"        }\n"
"        */\n"
"\n"
"        SlangInt getFieldBindingRangeOffset(SlangInt fieldIndex)\n"
"        {\n"
"            return spReflectionTypeLayout_getFieldBindingRangeOffset(\n"
"                (SlangReflectionTypeLayout*) this,\n"
"                fieldIndex);\n"
"        }\n"
"\n"
"        SlangInt getExplicitCounterBindingRangeOffset()\n"
"        {\n"
"            return spReflectionTypeLayout_getExplicitCounterBindingRangeOffset(\n"
"                (SlangReflectionTypeLayout*) this);\n"
"        }\n"
"\n"
"        TypeLayoutReflection* getBindingRangeLeafTypeLayout(SlangInt index)\n"
"        {\n"
"            return (TypeLayoutReflection*) spReflectionTypeLayout_getBindingRangeLeafTypeLayout(\n"
"                (SlangReflectionTypeLayout*) this,\n"
"                index);\n"
"        }\n"
"\n"
"        VariableReflection* getBindingRangeLeafVariable(SlangInt index)\n"
"        {\n"
"            return (VariableReflection*)spReflectionTypeLayout_getBindingRangeLeafVariable(\n"
"                (SlangReflectionTypeLayout*)this, index);\n"
"        }\n"
"\n"
"        SlangInt getBindingRangeDescriptorSetIndex(SlangInt index)\n"
"        {\n"
"            return spReflectionTypeLayout_getBindingRangeDescriptorSetIndex(\n"
"                (SlangReflectionTypeLayout*) this,\n"
"                index);\n"
"        }\n"
"\n"
"        SlangInt getBindingRangeFirstDescriptorRangeIndex(SlangInt index)\n"
"        {\n"
"            return spReflectionTypeLayout_getBindingRangeFirstDescriptorRangeIndex(\n"
"                (SlangReflectionTypeLayout*) this,\n"
"                index);\n"
"        }\n"
"\n"
"        SlangInt getBindingRangeDescriptorRangeCount(SlangInt index)\n"
"        {\n"
"            return spReflectionTypeLayout_getBindingRangeDescriptorRangeCount(\n"
"                (SlangReflectionTypeLayout*) this,\n"
"                index);\n"
"        }\n"
"\n"
"        SlangInt getDescriptorSetCount()\n"
"        {\n"
"            return spReflectionTypeLayout_getDescriptorSetCount(\n"
"                (SlangReflectionTypeLayout*) this);\n"
"        }\n"
"\n"
"        SlangInt getDescriptorSetSpaceOffset(SlangInt setIndex)\n"
"        {\n"
"            return spReflectionTypeLayout_getDescriptorSetSpaceOffset(\n"
"                (SlangReflectionTypeLayout*) this,\n"
"                setIndex);\n"
"        }\n"
"\n"
"        SlangInt getDescriptorSetDescriptorRangeCount(SlangInt setIndex)\n"
"        {\n"
"            return spReflectionTypeLayout_getDescriptorSetDescriptorRangeCount(\n"
"                (SlangReflectionTypeLayout*) this,\n"
"                setIndex);\n"
"        }\n"
"\n"
"        SlangInt getDescriptorSetDescriptorRangeIndexOffset(SlangInt setIndex, SlangInt rangeIndex)\n"
"        {\n"
"            return spReflectionTypeLayout_getDescriptorSetDescriptorRangeIndexOffset(\n"
"                (SlangReflectionTypeLayout*) this,\n"
"                setIndex,\n"
"                rangeIndex);\n"
"        }\n"
"\n"
"        SlangInt getDescriptorSetDescriptorRangeDescriptorCount(SlangInt setIndex, SlangInt rangeIndex)\n"
"        {\n"
"            return spReflectionTypeLayout_getDescriptorSetDescriptorRangeDescriptorCount(\n"
"                (SlangReflectionTypeLayout*) this,\n"
"                setIndex,\n"
"                rangeIndex);\n"
"        }\n"
"\n"
"        BindingType getDescriptorSetDescriptorRangeType(SlangInt setIndex, SlangInt rangeIndex)\n"
"        {\n"
"            return (BindingType) spReflectionTypeLayout_getDescriptorSetDescriptorRangeType(\n"
"                (SlangReflectionTypeLayout*) this,\n"
"                setIndex,\n"
"                rangeIndex);\n"
"        }\n"
"\n"
"        ParameterCategory getDescriptorSetDescriptorRangeCategory(SlangInt setIndex, SlangInt rangeIndex)\n"
"        {\n"
"            return (ParameterCategory) spReflectionTypeLayout_getDescriptorSetDescriptorRangeCategory(\n"
"                (SlangReflectionTypeLayout*) this,\n"
"                setIndex,\n"
"                rangeIndex);\n"
"        }\n"
"\n"
"        SlangInt getSubObjectRangeCount()\n"
"        {\n"
"            return spReflectionTypeLayout_getSubObjectRangeCount(\n"
"                (SlangReflectionTypeLayout*) this);\n"
"        }\n"
"\n"
"        SlangInt getSubObjectRangeBindingRangeIndex(SlangInt subObjectRangeIndex)\n"
"        {\n"
"            return spReflectionTypeLayout_getSubObjectRangeBindingRangeIndex(\n"
"                (SlangReflectionTypeLayout*) this,\n"
"                subObjectRangeIndex);\n"
"        }\n"
"\n"
"        SlangInt getSubObjectRangeSpaceOffset(SlangInt subObjectRangeIndex)\n"
"        {\n"
"            return spReflectionTypeLayout_getSubObjectRangeSpaceOffset(\n"
"                (SlangReflectionTypeLayout*) this,\n"
"                subObjectRangeIndex);\n"
"        }\n"
"\n"
"        VariableLayoutReflection* getSubObjectRangeOffset(SlangInt subObjectRangeIndex)\n"
"        {\n"
"            return (VariableLayoutReflection*) spReflectionTypeLayout_getSubObjectRangeOffset(\n"
"                (SlangReflectionTypeLayout*) this,\n"
"                subObjectRangeIndex);\n"
"        }\n"
"    };\n"
"\n"
"    struct Modifier\n"
"    {\n"
"        enum ID : SlangModifierIDIntegral\n"
"        {\n"
"            Shared = SLANG_MODIFIER_SHARED,\n"
"        };\n"
"    };\n"
"\n"
"    struct VariableReflection\n"
"    {\n"
"        char const* getName()\n"
"        {\n"
"            return spReflectionVariable_GetName((SlangReflectionVariable*) this);\n"
"        }\n"
"\n"
"        TypeReflection* getType()\n"
"        {\n"
"            return (TypeReflection*) spReflectionVariable_GetType((SlangReflectionVariable*) this);\n"
"        }\n"
"\n"
"        Modifier* findModifier(Modifier::ID id)\n"
"        {\n"
"            return (Modifier*) spReflectionVariable_FindModifier((SlangReflectionVariable*) this, (SlangModifierID) id);\n"
"        }\n"
"\n"
"        unsigned int getUserAttributeCount()\n"
"        {\n"
"            return spReflectionVariable_GetUserAttributeCount((SlangReflectionVariable*)this);\n"
"        }\n"
"        UserAttribute* getUserAttributeByIndex(unsigned int index)\n"
"        {\n"
"            return (UserAttribute*)spReflectionVariable_GetUserAttribute((SlangReflectionVariable*)this, index);\n"
"        }\n"
"        UserAttribute* findUserAttributeByName(SlangSession* session, char const* name)\n"
"        {\n"
"            return (UserAttribute*)spReflectionVariable_FindUserAttributeByName((SlangReflectionVariable*)this, session, name);\n"
"        }\n"
"    };\n"
"\n"
"    struct VariableLayoutReflection\n"
"    {\n"
"        VariableReflection* getVariable()\n"
"        {\n"
"            return (VariableReflection*) spReflectionVariableLayout_GetVariable((SlangReflectionVariableLayout*) this);\n"
"        }\n"
"\n"
"        char const* getName()\n"
"        {\n"
"            return getVariable()->getName();\n"
"        }\n"
"\n"
"        Modifier* findModifier(Modifier::ID id)\n"
"        {\n"
"            return getVariable()->findModifier(id);\n"
"        }\n"
"\n"
"        TypeLayoutReflection* getTypeLayout()\n"
"        {\n"
"            return (TypeLayoutReflection*) spReflectionVariableLayout_GetTypeLayout((SlangReflectionVariableLayout*) this);\n"
"        }\n"
"\n"
"        ParameterCategory getCategory()\n"
"        {\n"
"            return getTypeLayout()->getParameterCategory();\n"
"        }\n"
"\n"
"        unsigned int getCategoryCount()\n"
"        {\n"
"            return getTypeLayout()->getCategoryCount();\n"
"        }\n"
"\n"
"        ParameterCategory getCategoryByIndex(unsigned int index)\n"
"        {\n"
"            return getTypeLayout()->getCategoryByIndex(index);\n"
"        }\n"
"\n"
"\n"
"        size_t getOffset(SlangParameterCategory category = SLANG_PARAMETER_CATEGORY_UNIFORM)\n"
"        {\n"
"            return spReflectionVariableLayout_GetOffset((SlangReflectionVariableLayout*) this, category);\n"
"        }\n"
"\n"
"        TypeReflection* getType()\n"
"        {\n"
"            return getVariable()->getType();\n"
"        }\n"
"\n"
"        unsigned getBindingIndex()\n"
"        {\n"
"            return spReflectionParameter_GetBindingIndex((SlangReflectionVariableLayout*) this);\n"
"        }\n"
"\n"
"        unsigned getBindingSpace()\n"
"        {\n"
"            return spReflectionParameter_GetBindingSpace((SlangReflectionVariableLayout*) this);\n"
"        }\n"
"\n"
"        size_t getBindingSpace(SlangParameterCategory category)\n"
"        {\n"
"            return spReflectionVariableLayout_GetSpace((SlangReflectionVariableLayout*) this, category);\n"
"        }\n"
"\n"
"        char const* getSemanticName()\n"
"        {\n"
"            return spReflectionVariableLayout_GetSemanticName((SlangReflectionVariableLayout*) this);\n"
"        }\n"
"\n"
"        size_t getSemanticIndex()\n"
"        {\n"
"            return spReflectionVariableLayout_GetSemanticIndex((SlangReflectionVariableLayout*) this);\n"
"        }\n"
"\n"
"        SlangStage getStage()\n"
"        {\n"
"            return spReflectionVariableLayout_getStage((SlangReflectionVariableLayout*) this);\n"
"        }\n"
"\n"
"        VariableLayoutReflection* getPendingDataLayout()\n"
"        {\n"
"            return (VariableLayoutReflection*) spReflectionVariableLayout_getPendingDataLayout((SlangReflectionVariableLayout*) this);\n"
"        }\n"
"    };\n"
"\n"
"    struct EntryPointReflection\n"
"    {\n"
"        char const* getName()\n"
"        {\n"
"            return spReflectionEntryPoint_getName((SlangReflectionEntryPoint*) this);\n"
"        }\n"
"\n"
"        char const* getNameOverride()\n"
"        {\n"
"            return spReflectionEntryPoint_getNameOverride((SlangReflectionEntryPoint*)this);\n"
"        }\n"
"\n"
"        unsigned getParameterCount()\n"
"        {\n"
"            return spReflectionEntryPoint_getParameterCount((SlangReflectionEntryPoint*) this);\n"
"        }\n"
"\n"
"        VariableLayoutReflection* getParameterByIndex(unsigned index)\n"
"        {\n"
"            return (VariableLayoutReflection*) spReflectionEntryPoint_getParameterByIndex((SlangReflectionEntryPoint*) this, index);\n"
"        }\n"
"\n"
"        SlangStage getStage()\n"
"        {\n"
"            return spReflectionEntryPoint_getStage((SlangReflectionEntryPoint*) this);\n"
"        }\n"
"\n"
"        void getComputeThreadGroupSize(\n"
"            SlangUInt   axisCount,\n"
"            SlangUInt*  outSizeAlongAxis)\n"
"        {\n"
"            return spReflectionEntryPoint_getComputeThreadGroupSize((SlangReflectionEntryPoint*) this, axisCount, outSizeAlongAxis);\n"
"        }\n"
"\n"
"        bool usesAnySampleRateInput()\n"
"        {\n"
"            return 0 != spReflectionEntryPoint_usesAnySampleRateInput((SlangReflectionEntryPoint*) this);\n"
"        }\n"
"\n"
"        VariableLayoutReflection* getVarLayout()\n"
"        {\n"
"            return (VariableLayoutReflection*) spReflectionEntryPoint_getVarLayout((SlangReflectionEntryPoint*) this);\n"
"        }\n"
"\n"
"        TypeLayoutReflection* getTypeLayout()\n"
"        {\n"
"            return getVarLayout()->getTypeLayout();\n"
"        }\n"
"\n"
"        VariableLayoutReflection* getResultVarLayout()\n"
"        {\n"
"            return (VariableLayoutReflection*) spReflectionEntryPoint_getResultVarLayout((SlangReflectionEntryPoint*) this);\n"
"        }\n"
"\n"
"        bool hasDefaultConstantBuffer()\n"
"        {\n"
"            return spReflectionEntryPoint_hasDefaultConstantBuffer((SlangReflectionEntryPoint*) this) != 0;\n"
"        }\n"
"    };\n"
"    typedef EntryPointReflection EntryPointLayout;\n"
"\n"
"    struct TypeParameterReflection\n"
"    {\n"
"        char const* getName()\n"
"        {\n"
"            return spReflectionTypeParameter_GetName((SlangReflectionTypeParameter*) this);\n"
"        }\n"
"        unsigned getIndex()\n"
"        {\n"
"            return spReflectionTypeParameter_GetIndex((SlangReflectionTypeParameter*) this);\n"
"        }\n"
"        unsigned getConstraintCount()\n"
"        {\n"
"            return spReflectionTypeParameter_GetConstraintCount((SlangReflectionTypeParameter*) this);\n"
"        }\n"
"        TypeReflection* getConstraintByIndex(int index)\n"
"        {\n"
"            return (TypeReflection*)spReflectionTypeParameter_GetConstraintByIndex((SlangReflectionTypeParameter*) this, index);\n"
"        }\n"
"    };\n"
"\n"
"    enum class LayoutRules : SlangLayoutRulesIntegral\n"
"    {\n"
"        Default = SLANG_LAYOUT_RULES_DEFAULT,\n"
"    };\n"
"\n"
"    typedef struct ShaderReflection ProgramLayout;\n"
"\n"
"    struct ShaderReflection\n"
"    {\n"
"        unsigned getParameterCount()\n"
"        {\n"
"            return spReflection_GetParameterCount((SlangReflection*) this);\n"
"        }\n"
"\n"
"        unsigned getTypeParameterCount()\n"
"        {\n"
"            return spReflection_GetTypeParameterCount((SlangReflection*) this);\n"
"        }\n"
"\n"
"        slang::ISession* getSession()\n"
"        {\n"
"            return spReflection_GetSession((SlangReflection*)this);\n"
"        }\n"
"\n"
"        TypeParameterReflection* getTypeParameterByIndex(unsigned index)\n"
"        {\n"
"            return (TypeParameterReflection*)spReflection_GetTypeParameterByIndex((SlangReflection*) this, index);\n"
"        }\n"
"\n"
"        TypeParameterReflection* findTypeParameter(char const* name)\n"
"        {\n"
"            return (TypeParameterReflection*)spReflection_FindTypeParameter((SlangReflection*)this, name);\n"
"        }\n"
"\n"
"        VariableLayoutReflection* getParameterByIndex(unsigned index)\n"
"        {\n"
"            return (VariableLayoutReflection*) spReflection_GetParameterByIndex((SlangReflection*) this, index);\n"
"        }\n"
"\n"
"        static ProgramLayout* get(SlangCompileRequest* request)\n"
"        {\n"
"            return (ProgramLayout*) spGetReflection(request);\n"
"        }\n"
"\n"
"        SlangUInt getEntryPointCount()\n"
"        {\n"
"            return spReflection_getEntryPointCount((SlangReflection*) this);\n"
"        }\n"
"\n"
"        EntryPointReflection* getEntryPointByIndex(SlangUInt index)\n"
"        {\n"
"            return (EntryPointReflection*) spReflection_getEntryPointByIndex((SlangReflection*) this, index);\n"
"        }\n"
"\n"
"        SlangUInt getGlobalConstantBufferBinding()\n"
"        {\n"
"            return spReflection_getGlobalConstantBufferBinding((SlangReflection*)this);\n"
"        }\n"
"\n"
"        size_t getGlobalConstantBufferSize()\n"
"        {\n"
"            return spReflection_getGlobalConstantBufferSize((SlangReflection*)this);\n"
"        }\n"
"\n"
"        TypeReflection* findTypeByName(const char* name)\n"
"        {\n"
"            return (TypeReflection*)spReflection_FindTypeByName(\n"
"                (SlangReflection*) this,\n"
"                name);\n"
"        }\n"
"\n"
"        TypeLayoutReflection* getTypeLayout(\n"
"            TypeReflection* type,\n"
"            LayoutRules     rules = LayoutRules::Default)\n"
"        {\n"
"            return (TypeLayoutReflection*)spReflection_GetTypeLayout(\n"
"                (SlangReflection*) this,\n"
"                (SlangReflectionType*)type,\n"
"                SlangLayoutRules(rules));\n"
"        }\n"
"\n"
"        EntryPointReflection* findEntryPointByName(const char* name)\n"
"        {\n"
"            return (EntryPointReflection*)spReflection_findEntryPointByName(\n"
"                (SlangReflection*) this,\n"
"                name);\n"
"        }\n"
"\n"
"        TypeReflection* specializeType(\n"
"            TypeReflection*         type,\n"
"            SlangInt                specializationArgCount,\n"
"            TypeReflection* const*  specializationArgs,\n"
"            ISlangBlob**            outDiagnostics)\n"
"        {\n"
;
sb << 
"            return (TypeReflection*) spReflection_specializeType(\n"
"                (SlangReflection*) this,\n"
"                (SlangReflectionType*) type,\n"
"                specializationArgCount,\n"
"                (SlangReflectionType* const*) specializationArgs,\n"
"                outDiagnostics);\n"
"        }\n"
"\n"
"        SlangUInt getHashedStringCount() const { return spReflection_getHashedStringCount((SlangReflection*)this); }\n"
"\n"
"        const char* getHashedString(SlangUInt index, size_t* outCount) const\n"
"        {\n"
"            return spReflection_getHashedString((SlangReflection*)this, index, outCount);\n"
"        }\n"
"\n"
"        TypeLayoutReflection* getGlobalParamsTypeLayout()\n"
"        {\n"
"            return (TypeLayoutReflection*) spReflection_getGlobalParamsTypeLayout((SlangReflection*) this);\n"
"        }\n"
"\n"
"        VariableLayoutReflection* getGlobalParamsVarLayout()\n"
"        {\n"
"            return (VariableLayoutReflection*) spReflection_getGlobalParamsVarLayout((SlangReflection*) this);\n"
"        }\n"
"    };\n"
"\n"
"    typedef uint32_t CompileStdLibFlags;\n"
"    struct CompileStdLibFlag\n"
"    {\n"
"        enum Enum : CompileStdLibFlags\n"
"        {\n"
"            WriteDocumentation = 0x1,\n"
"        };\n"
"    };\n"
"\n"
"    typedef ISlangBlob IBlob;\n"
"\n"
"    struct IComponentType;\n"
"    struct ITypeConformance;\n"
"    struct IGlobalSession;\n"
"    struct IModule;\n"
"\n"
"    struct SessionDesc;\n"
"    struct SpecializationArg;\n"
"    struct TargetDesc;\n"
"\n"
"        /** A global session for interaction with the Slang library.\n"
"\n"
"        An application may create and re-use a single global session across\n"
"        multiple sessions, in order to amortize startups costs (in current\n"
"        Slang this is mostly the cost of loading the Slang standard library).\n"
"\n"
"        The global session is currently *not* thread-safe and objects created from\n"
"        a single global session should only be used from a single thread at\n"
"        a time.\n"
"        */\n"
"    struct IGlobalSession : public ISlangUnknown\n"
"    {\n"
"        SLANG_COM_INTERFACE(0xc140b5fd, 0xc78, 0x452e, { 0xba, 0x7c, 0x1a, 0x1e, 0x70, 0xc7, 0xf7, 0x1c })\n"
"\n"
"            /** Create a new session for loading and compiling code.\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL createSession(\n"
"            SessionDesc const&  desc,\n"
"            ISession**          outSession) = 0;\n"
"\n"
"            /** Look up the internal ID of a profile by its `name`.\n"
"\n"
"            Profile IDs are *not* guaranteed to be stable across versions\n"
"            of the Slang library, so clients are expected to look up\n"
"            profiles by name at runtime.\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangProfileID SLANG_MCALL findProfile(\n"
"            char const*     name) = 0;\n"
"\n"
"            /** Set the path that downstream compilers (aka back end compilers) will\n"
"            be looked from.\n"
"            @param passThrough Identifies the downstream compiler\n"
"            @param path The path to find the downstream compiler (shared library/dll/executable)\n"
"\n"
"            For back ends that are dlls/shared libraries, it will mean the path will\n"
"            be prefixed with the path when calls are made out to ISlangSharedLibraryLoader.\n"
"            For executables - it will look for executables along the path */\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL setDownstreamCompilerPath(\n"
"            SlangPassThrough passThrough,\n"
"            char const* path) = 0;\n"
"\n"
"            /** DEPRECATED: Use setLanguagePrelude\n"
"\n"
"            Set the 'prelude' for generated code for a 'downstream compiler'.\n"
"            @param passThrough The downstream compiler for generated code that will have the prelude applied to it. \n"
"            @param preludeText The text added pre-pended verbatim before the generated source\n"
"\n"
"            That for pass-through usage, prelude is not pre-pended, preludes are for code generation only. \n"
"            */\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL setDownstreamCompilerPrelude(\n"
"            SlangPassThrough passThrough,\n"
"            const char* preludeText) = 0;\n"
"\n"
"            /** DEPRECATED: Use getLanguagePrelude\n"
"\n"
"            Get the 'prelude' for generated code for a 'downstream compiler'.\n"
"            @param passThrough The downstream compiler for generated code that will have the prelude applied to it. \n"
"            @param outPrelude  On exit holds a blob that holds the string of the prelude.\n"
"            */\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL getDownstreamCompilerPrelude(\n"
"            SlangPassThrough passThrough,\n"
"            ISlangBlob** outPrelude) = 0;\n"
"\n"
"            /** Get the build version 'tag' string. The string is the same as produced via `git describe --tags`\n"
"            for the project. If Slang is built separately from the automated build scripts\n"
"            the contents will by default be 'unknown'. Any string can be set by changing the\n"
"            contents of 'slang-tag-version.h' file and recompiling the project.\n"
"\n"
"            This method will return exactly the same result as the free function spGetBuildTagString.\n"
"\n"
"            @return The build tag string\n"
"            */\n"
"        virtual SLANG_NO_THROW const char* SLANG_MCALL getBuildTagString() = 0;\n"
"\n"
"            /* For a given source language set the default compiler.\n"
"            If a default cannot be chosen (for example the target cannot be achieved by the default),\n"
"            the default will not be used. \n"
"\n"
"            @param sourceLanguage the source language \n"
"            @param defaultCompiler the default compiler for that language\n"
"            @return \n"
"            */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL setDefaultDownstreamCompiler(\n"
"            SlangSourceLanguage sourceLanguage,\n"
"            SlangPassThrough defaultCompiler) = 0;\n"
"\n"
"            /* For a source type get the default compiler \n"
"\n"
"            @param sourceLanguage the source language \n"
"            @return The downstream compiler for that source language */\n"
"        virtual SlangPassThrough SLANG_MCALL getDefaultDownstreamCompiler(\n"
"            SlangSourceLanguage sourceLanguage) = 0;\n"
"\n"
"            /* Set the 'prelude' placed before generated code for a specific language type.\n"
"            \n"
"            @param sourceLanguage The language the prelude should be inserted on.\n"
"            @param preludeText The text added pre-pended verbatim before the generated source\n"
"\n"
"            Note! That for pass-through usage, prelude is not pre-pended, preludes are for code generation only. \n"
"            */\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL setLanguagePrelude(\n"
"            SlangSourceLanguage sourceLanguage,\n"
"            const char* preludeText) = 0;\n"
"\n"
"            /** Get the 'prelude' associated with a specific source language. \n"
"            @param sourceLanguage The language the prelude should be inserted on.\n"
"            @param outPrelude  On exit holds a blob that holds the string of the prelude.\n"
"            */\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL getLanguagePrelude(\n"
"            SlangSourceLanguage sourceLanguage,\n"
"            ISlangBlob** outPrelude) = 0;\n"
"\n"
"            /** Create a compile request.\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL createCompileRequest(\n"
"            slang::ICompileRequest** outCompileRequest) = 0;\n"
"\n"
"            /** Add new builtin declarations to be used in subsequent compiles.\n"
"            */\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL addBuiltins(\n"
"            char const*     sourcePath,\n"
"            char const*     sourceString) = 0;\n"
"\n"
"            /** Set the session shared library loader. If this changes the loader, it may cause shared libraries to be unloaded\n"
"            @param loader The loader to set. Setting nullptr sets the default loader. \n"
"            */\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL setSharedLibraryLoader(\n"
"            ISlangSharedLibraryLoader* loader) = 0;\n"
"\n"
"            /** Gets the currently set shared library loader\n"
"            @return Gets the currently set loader. If returns nullptr, it's the default loader\n"
"            */\n"
"        virtual SLANG_NO_THROW ISlangSharedLibraryLoader* SLANG_MCALL getSharedLibraryLoader() = 0;\n"
"\n"
"            /** Returns SLANG_OK if a the compilation target is supported for this session\n"
"            \n"
"            @param target The compilation target to test\n"
"            @return SLANG_OK if the target is available\n"
"            SLANG_E_NOT_IMPLEMENTED if not implemented in this build\n"
"            SLANG_E_NOT_FOUND if other resources (such as shared libraries) required to make target work could not be found\n"
"            SLANG_FAIL other kinds of failures */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL checkCompileTargetSupport(\n"
"            SlangCompileTarget  target) = 0;\n"
"\n"
"            /** Returns SLANG_OK if a the pass through support is supported for this session\n"
"            @param session Session\n"
"            @param target The compilation target to test\n"
"            @return SLANG_OK if the target is available\n"
"            SLANG_E_NOT_IMPLEMENTED if not implemented in this build\n"
"            SLANG_E_NOT_FOUND if other resources (such as shared libraries) required to make target work could not be found\n"
"            SLANG_FAIL other kinds of failures */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL checkPassThroughSupport(\n"
"            SlangPassThrough    passThrough) = 0;\n"
"\n"
"            /** Compile from (embedded source) the StdLib on the session.\n"
"            Will return a failure if there is already a StdLib available\n"
"            NOTE! API is experimental and not ready for production code\n"
"            @param flags to control compilation\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL compileStdLib(CompileStdLibFlags flags) = 0;\n"
"\n"
"            /** Load the StdLib. Currently loads modules from the file system. \n"
"            @param stdLib Start address of the serialized stdlib\n"
"            @param stdLibSizeInBytes The size in bytes of the serialized stdlib\n"
"\n"
"            NOTE! API is experimental and not ready for production code\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL loadStdLib(const void* stdLib, size_t stdLibSizeInBytes) = 0;\n"
"\n"
"            /** Save the StdLib modules to the file system\n"
"            @param archiveType The type of archive used to hold the stdlib\n"
"            @param outBlob The serialized blob containing the standard library\n"
"\n"
"            NOTE! API is experimental and not ready for production code  */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL saveStdLib(SlangArchiveType archiveType, ISlangBlob** outBlob) = 0;\n"
"\n"
"            /** Look up the internal ID of a capability by its `name`.\n"
"\n"
"            Capability IDs are *not* guaranteed to be stable across versions\n"
"            of the Slang library, so clients are expected to look up\n"
"            capabilities by name at runtime.\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangCapabilityID SLANG_MCALL findCapability(\n"
"            char const*     name) = 0;\n"
"\n"
"            /** Set the downstream/pass through compiler to be used for a transition from the source type to the target type\n"
"            @param source The source 'code gen target'\n"
"            @param target The target 'code gen target'\n"
"            @param compiler The compiler/pass through to use for the transition from source to target\n"
"            */\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL setDownstreamCompilerForTransition(SlangCompileTarget source, SlangCompileTarget target, SlangPassThrough compiler) = 0;\n"
"\n"
"            /** Get the downstream/pass through compiler for a transition specified by source and target\n"
"            @param source The source 'code gen target'\n"
"            @param target The target 'code gen target'\n"
"            @return The compiler that is used for the transition. Returns SLANG_PASS_THROUGH_NONE it is not defined\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangPassThrough SLANG_MCALL getDownstreamCompilerForTransition(SlangCompileTarget source, SlangCompileTarget target) = 0;\n"
"\n"
"            /** Get the time in seconds spent in the slang and downstream compiler.\n"
"            */\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL getCompilerElapsedTime(double* outTotalTime, double* outDownstreamTime) = 0;\n"
"\n"
"            /** Specify a spirv.core.grammar.json file to load and use when\n"
"             * parsing and checking any SPIR-V code\n"
"             */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL setSPIRVCoreGrammar(\n"
"            char const* jsonPath) = 0;\n"
"\n"
"            /** Parse slangc command line options into a SessionDesc that can be used to create a session\n"
"            *   with all the compiler options specified in the command line.\n"
"            *   @param argc The number of command line arguments.\n"
"            *   @param argv An input array of command line arguments to parse.\n"
"            *   @param outSessionDesc A pointer to a SessionDesc struct to receive parsed session desc.\n"
"            *   @param outAuxAllocation Auxillary memory allocated to hold data used in the sesion desc.\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL parseCommandLineArguments(\n"
"            int argc, const char* const* argv, SessionDesc* outSessionDesc, ISlangUnknown** outAuxAllocation) = 0;\n"
"\n"
"            /** Computes a digest that uniquely identifies the session description.\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL getSessionDescDigest(SessionDesc* sessionDesc, ISlangBlob** outBlob) = 0;\n"
"    };\n"
"\n"
"    #define SLANG_UUID_IGlobalSession IGlobalSession::getTypeGuid()\n"
"\n"
"    /*!\n"
"    @brief A request for one or more compilation actions to be performed.\n"
"    */\n"
"    struct ICompileRequest : public ISlangUnknown\n"
"    {\n"
"        SLANG_COM_INTERFACE( 0x96d33993, 0x317c, 0x4db5, { 0xaf, 0xd8, 0x66, 0x6e, 0xe7, 0x72, 0x48, 0xe2 } )\n"
"   \n"
"            /** Set the filesystem hook to use for a compile request\n"
"\n"
"            The provided `fileSystem` will be used to load any files that\n"
"            need to be loaded during processing of the compile `request`.\n"
"            This includes:\n"
"\n"
"              - Source files loaded via `spAddTranslationUnitSourceFile`\n"
"              - Files referenced via `#include`\n"
"              - Files loaded to resolve `#import` operations\n"
"                */\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL setFileSystem(\n"
"            ISlangFileSystem*       fileSystem) = 0;\n"
"\n"
"            /*!\n"
"            @brief Set flags to be used for compilation.\n"
"            */\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL setCompileFlags(\n"
"            SlangCompileFlags       flags) = 0;\n"
"\n"
"            /*!\n"
"            @brief Returns the compilation flags previously set with `setCompileFlags`\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangCompileFlags SLANG_MCALL getCompileFlags() = 0;\n"
"\n"
"            /*!\n"
"            @brief Set whether to dump intermediate results (for debugging) or not.\n"
"            */\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL setDumpIntermediates(\n"
"            int                     enable) = 0;\n"
"\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL setDumpIntermediatePrefix(\n"
"            const char* prefix) = 0;\n"
"\n"
"            /*!\n"
"            @brief Set whether (and how) `#line` directives should be output.\n"
"            */\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL setLineDirectiveMode(\n"
"            SlangLineDirectiveMode  mode) = 0;\n"
"\n"
"            /*!\n"
"            @brief Sets the target for code generation.\n"
"            @param target The code generation target. Possible values are:\n"
"            - SLANG_GLSL. Generates GLSL code.\n"
"            - SLANG_HLSL. Generates HLSL code.\n"
"            - SLANG_SPIRV. Generates SPIR-V code.\n"
"            */\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL setCodeGenTarget(\n"
"            SlangCompileTarget target) = 0;\n"
"\n"
"            /*!\n"
"            @brief Add a code-generation target to be used.\n"
"            */\n"
"        virtual SLANG_NO_THROW int SLANG_MCALL addCodeGenTarget(\n"
"            SlangCompileTarget      target) = 0;\n"
"\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL setTargetProfile(\n"
"            int                     targetIndex,\n"
"            SlangProfileID          profile) = 0;\n"
"\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL setTargetFlags(\n"
"            int                     targetIndex,\n"
"            SlangTargetFlags        flags) = 0;\n"
"\n"
"\n"
"            /*!\n"
"            @brief Set the floating point mode (e.g., precise or fast) to use a target.\n"
"            */\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL setTargetFloatingPointMode(\n"
"            int                     targetIndex,\n"
"            SlangFloatingPointMode  mode) = 0;\n"
"\n"
"            /* DEPRECATED: use `spSetMatrixLayoutMode` instead. */\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL setTargetMatrixLayoutMode(\n"
"            int                     targetIndex,\n"
"            SlangMatrixLayoutMode   mode) = 0;\n"
"\n"
;
sb << 
"        virtual SLANG_NO_THROW void SLANG_MCALL setMatrixLayoutMode(\n"
"            SlangMatrixLayoutMode   mode) = 0;\n"
"\n"
"            /*!\n"
"            @brief Set the level of debug information to produce.\n"
"            */\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL setDebugInfoLevel(\n"
"            SlangDebugInfoLevel     level) = 0;\n"
"\n"
"            /*!\n"
"            @brief Set the level of optimization to perform.\n"
"            */\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL setOptimizationLevel(\n"
"            SlangOptimizationLevel  level) = 0;\n"
"\n"
"\n"
"    \n"
"            /*!\n"
"            @brief Set the container format to be used for binary output.\n"
"            */\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL setOutputContainerFormat(\n"
"            SlangContainerFormat    format) = 0;\n"
"\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL setPassThrough(\n"
"            SlangPassThrough        passThrough) = 0;\n"
"\n"
"    \n"
"        virtual SLANG_NO_THROW void SLANG_MCALL setDiagnosticCallback(\n"
"            SlangDiagnosticCallback callback,\n"
"            void const*             userData) = 0;\n"
"\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL setWriter(\n"
"            SlangWriterChannel      channel, \n"
"            ISlangWriter*           writer) = 0;\n"
"\n"
"        virtual SLANG_NO_THROW ISlangWriter* SLANG_MCALL getWriter(\n"
"            SlangWriterChannel      channel) = 0;\n"
"\n"
"            /*!\n"
"            @brief Add a path to use when searching for referenced files.\n"
"            This will be used for both `#include` directives and also for explicit `__import` declarations.\n"
"            @param ctx The compilation context.\n"
"            @param searchDir The additional search directory.\n"
"            */\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL addSearchPath(\n"
"            const char*             searchDir) = 0;\n"
"\n"
"            /*!\n"
"            @brief Add a macro definition to be used during preprocessing.\n"
"            @param key The name of the macro to define.\n"
"            @param value The value of the macro to define.\n"
"            */\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL addPreprocessorDefine(\n"
"            const char*             key,\n"
"            const char*             value) = 0;\n"
"\n"
"            /*!\n"
"            @brief Set options using arguments as if specified via command line.\n"
"            @return Returns SlangResult. On success SLANG_SUCCEEDED(result) is true.\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL processCommandLineArguments(\n"
"            char const* const*      args,\n"
"            int                     argCount) = 0;\n"
"\n"
"            /** Add a distinct translation unit to the compilation request\n"
"\n"
"            `name` is optional. \n"
"            Returns the zero-based index of the translation unit created.\n"
"            */\n"
"        virtual SLANG_NO_THROW int SLANG_MCALL addTranslationUnit(\n"
"            SlangSourceLanguage     language,\n"
"            char const*             name) = 0;\n"
"\n"
"    \n"
"            /** Set a default module name. Translation units will default to this module name if one is not\n"
"            passed. If not set each translation unit will get a unique name. \n"
"            */\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL setDefaultModuleName(\n"
"            const char* defaultModuleName) = 0;\n"
"\n"
"            /** Add a preprocessor definition that is scoped to a single translation unit.\n"
"\n"
"            @param translationUnitIndex The index of the translation unit to get the definition.\n"
"            @param key The name of the macro to define.\n"
"            @param value The value of the macro to define.\n"
"            */\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL addTranslationUnitPreprocessorDefine(\n"
"            int                     translationUnitIndex,\n"
"            const char*             key,\n"
"            const char*             value) = 0;\n"
"\n"
"\n"
"            /** Add a source file to the given translation unit.\n"
"\n"
"            If a user-defined file system has been specified via\n"
"            `spSetFileSystem`, then it will be used to load the\n"
"            file at `path`. Otherwise, Slang will use the OS\n"
"            file system.\n"
"\n"
"            This function does *not* search for a file using\n"
"            the registered search paths (`spAddSearchPath`),\n"
"            and instead using the given `path` as-is.\n"
"            */\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL addTranslationUnitSourceFile(\n"
"            int                     translationUnitIndex,\n"
"            char const*             path) = 0;\n"
"\n"
"            /** Add a source string to the given translation unit.\n"
"\n"
"            @param translationUnitIndex The index of the translation unit to add source to.\n"
"            @param path The file-system path that should be assumed for the source code.\n"
"            @param source A null-terminated UTF-8 encoded string of source code.\n"
"\n"
"            The implementation will make a copy of the source code data.\n"
"            An application may free the buffer immediately after this call returns.\n"
"\n"
"            The `path` will be used in any diagnostic output, as well\n"
"            as to determine the base path when resolving relative\n"
"            `#include`s.\n"
"            */\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL addTranslationUnitSourceString(\n"
"            int                     translationUnitIndex,\n"
"            char const*             path,\n"
"            char const*             source) = 0;\n"
"\n"
"\n"
"            /** Add a slang library - such that its contents can be referenced during linking.\n"
"            This is equivalent to the -r command line option.\n"
"\n"
"            @param basePath The base path used to lookup referenced modules.\n"
"            @param libData The library data\n"
"            @param libDataSize The size of the library data\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL addLibraryReference(\n"
"            const char* basePath,\n"
"            const void* libData,\n"
"            size_t libDataSize) = 0;\n"
"\n"
"            /** Add a source string to the given translation unit.\n"
"\n"
"            @param translationUnitIndex The index of the translation unit to add source to.\n"
"            @param path The file-system path that should be assumed for the source code.\n"
"            @param sourceBegin A pointer to a buffer of UTF-8 encoded source code.\n"
"            @param sourceEnd A pointer to to the end of the buffer specified in `sourceBegin`\n"
"\n"
"            The implementation will make a copy of the source code data.\n"
"            An application may free the buffer immediately after this call returns.\n"
"\n"
"            The `path` will be used in any diagnostic output, as well\n"
"            as to determine the base path when resolving relative\n"
"            `#include`s.\n"
"            */\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL addTranslationUnitSourceStringSpan(\n"
"            int                     translationUnitIndex,\n"
"            char const*             path,\n"
"            char const*             sourceBegin,\n"
"            char const*             sourceEnd) = 0;\n"
"\n"
"            /** Add a blob of source code to the given translation unit.\n"
"\n"
"            @param translationUnitIndex The index of the translation unit to add source to.\n"
"            @param path The file-system path that should be assumed for the source code.\n"
"            @param sourceBlob A blob containing UTF-8 encoded source code.\n"
"            @param sourceEnd A pointer to to the end of the buffer specified in `sourceBegin`\n"
"\n"
"            The compile request will retain a reference to the blob.\n"
"\n"
"            The `path` will be used in any diagnostic output, as well\n"
"            as to determine the base path when resolving relative\n"
"            `#include`s.\n"
"            */\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL addTranslationUnitSourceBlob(\n"
"            int                     translationUnitIndex,\n"
"            char const*             path,\n"
"            ISlangBlob*             sourceBlob) = 0;\n"
"\n"
"            /** Add an entry point in a particular translation unit\n"
"            */\n"
"        virtual SLANG_NO_THROW int SLANG_MCALL addEntryPoint(\n"
"            int                     translationUnitIndex,\n"
"            char const*             name,\n"
"            SlangStage              stage) = 0;\n"
"\n"
"            /** Add an entry point in a particular translation unit,\n"
"                with additional arguments that specify the concrete\n"
"                type names for entry-point generic type parameters.\n"
"            */\n"
"        virtual SLANG_NO_THROW int SLANG_MCALL addEntryPointEx(\n"
"            int                     translationUnitIndex,\n"
"            char const*             name,\n"
"            SlangStage              stage,\n"
"            int                     genericArgCount,\n"
"            char const**            genericArgs) = 0;\n"
"\n"
"            /** Specify the arguments to use for global generic parameters.\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL setGlobalGenericArgs(\n"
"            int                     genericArgCount,\n"
"            char const**            genericArgs) = 0;\n"
"\n"
"            /** Specify the concrete type to be used for a global \"existential slot.\"\n"
"\n"
"            Every shader parameter (or leaf field of a `struct`-type shader parameter)\n"
"            that has an interface or array-of-interface type introduces an existential\n"
"            slot. The number of slots consumed by a shader parameter, and the starting\n"
"            slot of each parameter can be queried via the reflection API using\n"
"            `SLANG_PARAMETER_CATEGORY_EXISTENTIAL_TYPE_PARAM`.\n"
"\n"
"            In order to generate specialized code, a concrete type needs to be specified\n"
"            for each existential slot. This function specifies the name of the type\n"
"            (or in general a type *expression*) to use for a specific slot at the\n"
"            global scope.\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL setTypeNameForGlobalExistentialTypeParam(\n"
"            int                     slotIndex,\n"
"            char const*             typeName) = 0;\n"
"\n"
"            /** Specify the concrete type to be used for an entry-point \"existential slot.\"\n"
"\n"
"            Every shader parameter (or leaf field of a `struct`-type shader parameter)\n"
"            that has an interface or array-of-interface type introduces an existential\n"
"            slot. The number of slots consumed by a shader parameter, and the starting\n"
"            slot of each parameter can be queried via the reflection API using\n"
"            `SLANG_PARAMETER_CATEGORY_EXISTENTIAL_TYPE_PARAM`.\n"
"\n"
"            In order to generate specialized code, a concrete type needs to be specified\n"
"            for each existential slot. This function specifies the name of the type\n"
"            (or in general a type *expression*) to use for a specific slot at the\n"
"            entry-point scope.\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL setTypeNameForEntryPointExistentialTypeParam(\n"
"            int                     entryPointIndex,\n"
"            int                     slotIndex,\n"
"            char const*             typeName) = 0;\n"
"\n"
"            /** Enable or disable an experimental, best-effort GLSL frontend\n"
"             */\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL setAllowGLSLInput(\n"
"            bool                    value) = 0;\n"
"\n"
"            /** Execute the compilation request.\n"
"\n"
"            @returns  SlangResult, SLANG_OK on success. Use SLANG_SUCCEEDED() and SLANG_FAILED() to test SlangResult.\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL compile() = 0;\n"
"\n"
"\n"
"            /** Get any diagnostic messages reported by the compiler.\n"
"\n"
"            @returns A null-terminated UTF-8 encoded string of diagnostic messages.\n"
"\n"
"            The returned pointer is only guaranteed to be valid\n"
"            until `request` is destroyed. Applications that wish to\n"
"            hold on to the diagnostic output for longer should use\n"
"            `getDiagnosticOutputBlob`.\n"
"            */\n"
"        virtual SLANG_NO_THROW char const* SLANG_MCALL getDiagnosticOutput() = 0;\n"
"\n"
"            /** Get diagnostic messages reported by the compiler.\n"
"\n"
"            @param outBlob A pointer to receive a blob holding a nul-terminated UTF-8 encoded string of diagnostic messages.\n"
"            @returns A `SlangResult` indicating success or failure.\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL getDiagnosticOutputBlob(\n"
"            ISlangBlob**            outBlob) = 0;\n"
"\n"
"\n"
"            /** Get the number of files that this compilation depended on.\n"
"\n"
"            This includes both the explicit source files, as well as any\n"
"            additional files that were transitively referenced (e.g., via\n"
"            a `#include` directive).\n"
"            */\n"
"        virtual SLANG_NO_THROW int SLANG_MCALL getDependencyFileCount() = 0;\n"
"\n"
"            /** Get the path to a file this compilation depended on.\n"
"            */\n"
"        virtual SLANG_NO_THROW char const* SLANG_MCALL getDependencyFilePath(\n"
"            int                     index) = 0;\n"
"\n"
"            /** Get the number of translation units associated with the compilation request\n"
"            */\n"
"        virtual SLANG_NO_THROW int SLANG_MCALL getTranslationUnitCount() = 0;\n"
"\n"
"            /** Get the output source code associated with a specific entry point.\n"
"\n"
"            The lifetime of the output pointer is the same as `request`.\n"
"            */\n"
"        virtual SLANG_NO_THROW char const* SLANG_MCALL getEntryPointSource(\n"
"            int                     entryPointIndex) = 0;\n"
"\n"
"            /** Get the output bytecode associated with a specific entry point.\n"
"\n"
"            The lifetime of the output pointer is the same as `request`.\n"
"            */\n"
"        virtual SLANG_NO_THROW void const* SLANG_MCALL getEntryPointCode(\n"
"            int                     entryPointIndex,\n"
"            size_t*                 outSize) = 0;\n"
"\n"
"            /** Get the output code associated with a specific entry point.\n"
"\n"
"            @param entryPointIndex The index of the entry point to get code for.\n"
"            @param targetIndex The index of the target to get code for (default: zero).\n"
"            @param outBlob A pointer that will receive the blob of code\n"
"            @returns A `SlangResult` to indicate success or failure.\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL getEntryPointCodeBlob(\n"
"            int                     entryPointIndex,\n"
"            int                     targetIndex,\n"
"            ISlangBlob**            outBlob) = 0;\n"
"\n"
"            /** Get entry point 'callable' functions accessible through the ISlangSharedLibrary interface.\n"
"\n"
"            That the functions remain in scope as long as the ISlangSharedLibrary interface is in scope.\n"
"\n"
"            NOTE! Requires a compilation target of SLANG_HOST_CALLABLE.\n"
"    \n"
"            @param entryPointIndex  The index of the entry point to get code for.\n"
"            @param targetIndex      The index of the target to get code for (default: zero).\n"
"            @param outSharedLibrary A pointer to a ISharedLibrary interface which functions can be queried on.\n"
"            @returns                A `SlangResult` to indicate success or failure.\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL getEntryPointHostCallable(\n"
"            int                     entryPointIndex,\n"
"            int                     targetIndex,\n"
"            ISlangSharedLibrary**   outSharedLibrary) = 0;\n"
"\n"
"            /** Get the output code associated with a specific target.\n"
"\n"
"            @param targetIndex The index of the target to get code for (default: zero).\n"
"            @param outBlob A pointer that will receive the blob of code\n"
"            @returns A `SlangResult` to indicate success or failure.\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL getTargetCodeBlob(\n"
"            int                     targetIndex,\n"
"            ISlangBlob**            outBlob) = 0;\n"
"\n"
"            /** Get 'callable' functions for a target accessible through the ISlangSharedLibrary interface.\n"
"\n"
"            That the functions remain in scope as long as the ISlangSharedLibrary interface is in scope.\n"
"\n"
"            NOTE! Requires a compilation target of SLANG_HOST_CALLABLE.\n"
"    \n"
"            @param targetIndex      The index of the target to get code for (default: zero).\n"
"            @param outSharedLibrary A pointer to a ISharedLibrary interface which functions can be queried on.\n"
"            @returns                A `SlangResult` to indicate success or failure.\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL getTargetHostCallable(\n"
"            int                     targetIndex,\n"
"            ISlangSharedLibrary**   outSharedLibrary) = 0;\n"
"\n"
"            /** Get the output bytecode associated with an entire compile request.\n"
"\n"
"            The lifetime of the output pointer is the same as `request` and the last spCompile.\n"
"\n"
;
sb << 
"            @param outSize          The size of the containers contents in bytes. Will be zero if there is no code available.\n"
"            @returns                Pointer to start of the contained data, or nullptr if there is no code available.\n"
"            */\n"
"        virtual SLANG_NO_THROW void const* SLANG_MCALL getCompileRequestCode(\n"
"            size_t*                 outSize) = 0;\n"
"\n"
"            /** Get the compilation result as a file system.\n"
"            The result is not written to the actual OS file system, but is made avaiable as an \n"
"            in memory representation.\n"
"            */\n"
"        virtual SLANG_NO_THROW ISlangMutableFileSystem* SLANG_MCALL getCompileRequestResultAsFileSystem() = 0;\n"
"\n"
"            /** Return the container code as a blob. The container blob is created as part of a compilation (with spCompile),\n"
"            and a container is produced with a suitable ContainerFormat. \n"
"\n"
"            @param outSize          The blob containing the container data. \n"
"            @returns                A `SlangResult` to indicate success or failure.\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL getContainerCode(\n"
"            ISlangBlob**            outBlob) = 0;\n"
"\n"
"            /** Load repro from memory specified.\n"
"\n"
"            Should only be performed on a newly created request.\n"
"\n"
"            NOTE! When using the fileSystem, files will be loaded via their `unique names` as if they are part of the flat file system. This\n"
"            mechanism is described more fully in docs/repro.md.\n"
"\n"
"            @param fileSystem       An (optional) filesystem. Pass nullptr to just use contents of repro held in data.\n"
"            @param data             The data to load from.\n"
"            @param size             The size of the data to load from. \n"
"            @returns                A `SlangResult` to indicate success or failure.\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL loadRepro(\n"
"            ISlangFileSystem* fileSystem,\n"
"            const void* data,\n"
"            size_t size) = 0;\n"
"\n"
"            /** Save repro state. Should *typically* be performed after spCompile, so that everything\n"
"            that is needed for a compilation is available. \n"
"\n"
"            @param outBlob          Blob that will hold the serialized state\n"
"            @returns                A `SlangResult` to indicate success or failure.\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL saveRepro(\n"
"            ISlangBlob** outBlob) = 0;\n"
"\n"
"            /** Enable repro capture.\n"
"\n"
"            Should be set after any ISlangFileSystem has been set, but before any compilation. It ensures that everything\n"
"            that the ISlangFileSystem accesses will be correctly recorded.\n"
"            Note that if a ISlangFileSystem/ISlangFileSystemExt isn't explicitly set (ie the default is used), then the\n"
"            request will automatically be set up to record everything appropriate. \n"
"\n"
"            @returns                A `SlangResult` to indicate success or failure.\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL enableReproCapture() = 0;\n"
"\n"
"            /** Get the (linked) program for a compile request.\n"
"\n"
"            The linked program will include all of the global-scope modules for the\n"
"            translation units in the program, plus any modules that they `import`\n"
"            (transitively), specialized to any global specialization arguments that\n"
"            were provided via the API.\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL getProgram(\n"
"            slang::IComponentType** outProgram) = 0;\n"
"\n"
"            /** Get the (partially linked) component type for an entry point.\n"
"\n"
"            The returned component type will include the entry point at the\n"
"            given index, and will be specialized using any specialization arguments\n"
"            that were provided for it via the API.\n"
"\n"
"            The returned component will *not* include the modules representing\n"
"            the global scope and its dependencies/specialization, so a client\n"
"            program will typically want to compose this component type with\n"
"            the one returned by `spCompileRequest_getProgram` to get a complete\n"
"            and usable component type from which kernel code can be requested.\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL getEntryPoint(\n"
"            SlangInt                entryPointIndex,\n"
"            slang::IComponentType** outEntryPoint) = 0;\n"
"\n"
"            /** Get the (un-linked) module for a translation unit.\n"
"\n"
"            The returned module will not be linked against any dependencies,\n"
"            nor against any entry points (even entry points declared inside\n"
"            the module). Similarly, the module will not be specialized\n"
"            to the arguments that might have been provided via the API.\n"
"\n"
"            This function provides an atomic unit of loaded code that\n"
"            is suitable for looking up types and entry points in the\n"
"            given module, and for linking together to produce a composite\n"
"            program that matches the needs of an application.\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL getModule(\n"
"            SlangInt                translationUnitIndex,\n"
"            slang::IModule**        outModule) = 0;\n"
"\n"
"            /** Get the `ISession` handle behind the `SlangCompileRequest`.\n"
"            TODO(JS): Arguably this should just return the session pointer.\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL getSession(\n"
"            slang::ISession** outSession) = 0;\n"
"\n"
"            /** get reflection data from a compilation request */\n"
"        virtual SLANG_NO_THROW SlangReflection* SLANG_MCALL getReflection() = 0;\n"
"\n"
"            /** Make output specially handled for command line output */\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL setCommandLineCompilerMode() = 0;\n"
"\n"
"            /** Add a defined capability that should be assumed available on the target */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL addTargetCapability(\n"
"            SlangInt            targetIndex,\n"
"            SlangCapabilityID   capability) = 0;\n"
"\n"
"            /** Get the (linked) program for a compile request, including all entry points.\n"
"\n"
"            The resulting program will include all of the global-scope modules for the\n"
"            translation units in the program, plus any modules that they `import`\n"
"            (transitively), specialized to any global specialization arguments that\n"
"            were provided via the API, as well as all entry points specified for compilation,\n"
"            specialized to their entry-point specialization arguments.\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL getProgramWithEntryPoints(\n"
"            slang::IComponentType** outProgram) = 0;\n"
"\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL isParameterLocationUsed(\n"
"            SlangInt entryPointIndex,\n"
"            SlangInt targetIndex,\n"
"            SlangParameterCategory category,\n"
"            SlangUInt spaceIndex,\n"
"            SlangUInt registerIndex,\n"
"            bool& outUsed) = 0;\n"
"\n"
"            /** Set the line directive mode for a target.\n"
"            */\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL setTargetLineDirectiveMode(\n"
"            SlangInt targetIndex,\n"
"            SlangLineDirectiveMode mode) = 0;\n"
"\n"
"            /** Set whether to use scalar buffer layouts for GLSL/Vulkan targets.\n"
"                If true, the generated GLSL/Vulkan code will use `scalar` layout for storage buffers.\n"
"                If false, the resulting code will std430 for storage buffers.\n"
"            */\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL setTargetForceGLSLScalarBufferLayout(int targetIndex, bool forceScalarLayout) = 0;\n"
"\n"
"            /** Overrides the severity of a specific diagnostic message.\n"
"\n"
"            @param messageID            Numeric identifier of the message to override,\n"
"                                        as defined in the 1st parameter of the DIAGNOSTIC macro.\n"
"            @param overrideSeverity     New severity of the message. If the message is originally Error or Fatal,\n"
"                                        the new severity cannot be lower than that.\n"
"            */\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL overrideDiagnosticSeverity(\n"
"            SlangInt messageID,\n"
"            SlangSeverity overrideSeverity) = 0;\n"
"\n"
"            /** Returns the currently active flags of the request's diagnostic sink. */\n"
"        virtual SLANG_NO_THROW SlangDiagnosticFlags SLANG_MCALL getDiagnosticFlags() = 0;\n"
"\n"
"            /** Sets the flags of the request's diagnostic sink.\n"
"                The previously specified flags are discarded. */\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL setDiagnosticFlags(SlangDiagnosticFlags flags) = 0;\n"
"\n"
"            /** Set the debug format to be used for debugging information */\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL setDebugInfoFormat(SlangDebugInfoFormat debugFormat) = 0;\n"
"\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL setEnableEffectAnnotations(bool value) = 0;\n"
"\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL setReportDownstreamTime(bool value) = 0;\n"
"\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL setReportPerfBenchmark(bool value) = 0;\n"
"\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL setSkipSPIRVValidation(bool value) = 0;\n"
"\n"
"    };\n"
"\n"
"    #define SLANG_UUID_ICompileRequest ICompileRequest::getTypeGuid()\n"
"\n"
"        /** Description of a code generation target.\n"
"        */\n"
"    struct TargetDesc\n"
"    {\n"
"            /** The size of this structure, in bytes.\n"
"            */\n"
"        size_t structureSize = sizeof(TargetDesc);\n"
"\n"
"            /** The target format to generate code for (e.g., SPIR-V, DXIL, etc.)\n"
"            */\n"
"        SlangCompileTarget      format = SLANG_TARGET_UNKNOWN;\n"
"\n"
"            /** The compilation profile supported by the target (e.g., \"Shader Model 5.1\")\n"
"            */\n"
"        SlangProfileID          profile = SLANG_PROFILE_UNKNOWN;\n"
"\n"
"            /** Flags for the code generation target. Currently unused. */\n"
"        SlangTargetFlags        flags = kDefaultTargetFlags;\n"
"\n"
"            /** Default mode to use for floating-point operations on the target.\n"
"            */\n"
"        SlangFloatingPointMode  floatingPointMode = SLANG_FLOATING_POINT_MODE_DEFAULT;\n"
"\n"
"            /** The line directive mode for output source code.\n"
"            */\n"
"        SlangLineDirectiveMode lineDirectiveMode = SLANG_LINE_DIRECTIVE_MODE_DEFAULT;\n"
"\n"
"            /** Whether to force `scalar` layout for glsl shader storage buffers.\n"
"            */\n"
"        bool forceGLSLScalarBufferLayout = false;\n"
"\n"
"            /** Pointer to an array of compiler option entries, whose size is compilerOptionEntryCount.\n"
"            */\n"
"        CompilerOptionEntry* compilerOptionEntries = nullptr;\n"
"\n"
"            /** Number of additional compiler option entries.\n"
"            */\n"
"        uint32_t compilerOptionEntryCount = 0;\n"
"\n"
"    };\n"
"\n"
"    typedef uint32_t SessionFlags;\n"
"    enum\n"
"    {\n"
"        kSessionFlags_None = 0\n"
"    };\n"
"\n"
"    struct PreprocessorMacroDesc\n"
"    {\n"
"        const char* name;\n"
"        const char* value;\n"
"    };\n"
"\n"
"    struct SessionDesc\n"
"    {\n"
"            /** The size of this structure, in bytes.\n"
"             */\n"
"        size_t structureSize = sizeof(SessionDesc);\n"
"\n"
"            /** Code generation targets to include in the session.\n"
"            */\n"
"        TargetDesc const*   targets = nullptr;\n"
"        SlangInt            targetCount = 0;\n"
"\n"
"            /** Flags to configure the session.\n"
"            */\n"
"        SessionFlags flags = kSessionFlags_None;\n"
"\n"
"            /** Default layout to assume for variables with matrix types.\n"
"            */\n"
"        SlangMatrixLayoutMode defaultMatrixLayoutMode = SLANG_MATRIX_LAYOUT_ROW_MAJOR;\n"
"\n"
"            /** Paths to use when searching for `#include`d or `import`ed files.\n"
"            */\n"
"        char const* const*  searchPaths = nullptr;\n"
"        SlangInt            searchPathCount = 0;\n"
"\n"
"        PreprocessorMacroDesc const*    preprocessorMacros = nullptr;\n"
"        SlangInt                        preprocessorMacroCount = 0;\n"
"\n"
"        ISlangFileSystem* fileSystem = nullptr;\n"
"\n"
"        bool enableEffectAnnotations = false;\n"
"        bool allowGLSLSyntax = false;\n"
"\n"
"        /** Pointer to an array of compiler option entries, whose size is compilerOptionEntryCount.\n"
"        */\n"
"        CompilerOptionEntry* compilerOptionEntries = nullptr;\n"
"\n"
"        /** Number of additional compiler option entries.\n"
"        */\n"
"        uint32_t compilerOptionEntryCount = 0;\n"
"\n"
"    };\n"
"\n"
"    enum class ContainerType\n"
"    {\n"
"        None, UnsizedArray, StructuredBuffer, ConstantBuffer, ParameterBlock\n"
"    };\n"
"\n"
"        /** A session provides a scope for code that is loaded.\n"
"\n"
"        A session can be used to load modules of Slang source code,\n"
"        and to request target-specific compiled binaries and layout\n"
"        information.\n"
"\n"
"        In order to be able to load code, the session owns a set\n"
"        of active \"search paths\" for resolving `#include` directives\n"
"        and `import` declrations, as well as a set of global\n"
"        preprocessor definitions that will be used for all code\n"
"        that gets `import`ed in the session.\n"
"\n"
"        If multiple user shaders are loaded in the same session,\n"
"        and import the same module (e.g., two source files do `import X`)\n"
"        then there will only be one copy of `X` loaded within the session.\n"
"\n"
"        In order to be able to generate target code, the session\n"
"        owns a list of available compilation targets, which specify\n"
"        code generation options.\n"
"\n"
"        Code loaded and compiled within a session is owned by the session\n"
"        and will remain resident in memory until the session is released.\n"
"        Applications wishing to control the memory usage for compiled\n"
"        and loaded code should use multiple sessions.\n"
"        */\n"
"    struct ISession : public ISlangUnknown\n"
"    {\n"
"        SLANG_COM_INTERFACE( 0x67618701, 0xd116, 0x468f, { 0xab, 0x3b, 0x47, 0x4b, 0xed, 0xce, 0xe, 0x3d } )\n"
"\n"
"            /** Get the global session thas was used to create this session.\n"
"            */\n"
"        virtual SLANG_NO_THROW IGlobalSession* SLANG_MCALL getGlobalSession() = 0;\n"
"\n"
"            /** Load a module as it would be by code using `import`.\n"
"            */\n"
"        virtual SLANG_NO_THROW IModule* SLANG_MCALL loadModule(\n"
"            const char* moduleName,\n"
"            IBlob**     outDiagnostics = nullptr) = 0;\n"
"\n"
"            /** Load a module from Slang source code.\n"
"            */\n"
"        virtual SLANG_NO_THROW IModule* SLANG_MCALL loadModuleFromSource(\n"
"            const char* moduleName,\n"
"            const char* path,\n"
"            slang::IBlob* source,\n"
"            slang::IBlob** outDiagnostics = nullptr) = 0;\n"
"\n"
"            /** Combine multiple component types to create a composite component type.\n"
"\n"
"            The `componentTypes` array must contain `componentTypeCount` pointers\n"
"            to component types that were loaded or created using the same session.\n"
"\n"
"            The shader parameters and specialization parameters of the composite will\n"
"            be the union of those in `componentTypes`. The relative order of child\n"
"            component types is significant, and will affect the order in which\n"
"            parameters are reflected and laid out.\n"
"\n"
"            The entry-point functions of the composite will be the union of those in\n"
"            `componentTypes`, and will follow the ordering of `componentTypes`.\n"
"\n"
"            The requirements of the composite component type will be a subset of\n"
"            those in `componentTypes`. If an entry in `componentTypes` has a requirement\n"
"            that can be satisfied by another entry, then the composition will\n"
"            satisfy the requirement and it will not appear as a requirement of\n"
"            the composite. If multiple entries in `componentTypes` have a requirement\n"
"            for the same type, then only the first such requirement will be retained\n"
"            on the composite. The relative ordering of requirements on the composite\n"
"            will otherwise match that of `componentTypes`.\n"
"\n"
"            If any diagnostics are generated during creation of the composite, they\n"
"            will be written to `outDiagnostics`. If an error is encountered, the\n"
"            function will return null.\n"
"\n"
"            It is an error to create a composite component type that recursively\n"
"            aggregates the a single module more than once.\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL createCompositeComponentType(\n"
"            IComponentType* const*  componentTypes,\n"
"            SlangInt                componentTypeCount,\n"
"            IComponentType**        outCompositeComponentType,\n"
"            ISlangBlob**            outDiagnostics = nullptr) = 0;\n"
"\n"
;
sb << 
"            /** Specialize a type based on type arguments.\n"
"            */\n"
"        virtual SLANG_NO_THROW TypeReflection* SLANG_MCALL specializeType(\n"
"            TypeReflection*             type,\n"
"            SpecializationArg const*    specializationArgs,\n"
"            SlangInt                    specializationArgCount,\n"
"            ISlangBlob**                outDiagnostics = nullptr) = 0;\n"
"\n"
"\n"
"            /** Get the layout `type` on the chosen `target`.\n"
"            */\n"
"        virtual SLANG_NO_THROW TypeLayoutReflection* SLANG_MCALL getTypeLayout(\n"
"            TypeReflection* type,\n"
"            SlangInt        targetIndex = 0,\n"
"            LayoutRules     rules = LayoutRules::Default,\n"
"            ISlangBlob**    outDiagnostics = nullptr) = 0;\n"
"\n"
"            /** Get a container type from `elementType`. For example, given type `T`, returns\n"
"                a type that represents `StructuredBuffer<T>`.\n"
"\n"
"                @param `elementType`: the element type to wrap around.\n"
"                @param `containerType`: the type of the container to wrap `elementType` in.\n"
"                @param `outDiagnostics`: a blob to receive diagnostic messages.\n"
"            */\n"
"        virtual SLANG_NO_THROW TypeReflection* SLANG_MCALL getContainerType(\n"
"            TypeReflection* elementType,\n"
"            ContainerType containerType,\n"
"            ISlangBlob** outDiagnostics = nullptr) = 0;\n"
"\n"
"            /** Return a `TypeReflection` that represents the `__Dynamic` type.\n"
"                This type can be used as a specialization argument to indicate using\n"
"                dynamic dispatch.\n"
"            */\n"
"        virtual SLANG_NO_THROW TypeReflection* SLANG_MCALL getDynamicType() = 0;\n"
"\n"
"            /** Get the mangled name for a type RTTI object.\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL getTypeRTTIMangledName(\n"
"            TypeReflection* type,\n"
"            ISlangBlob** outNameBlob) = 0;\n"
"\n"
"            /** Get the mangled name for a type witness.\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL getTypeConformanceWitnessMangledName(\n"
"            TypeReflection* type,\n"
"            TypeReflection* interfaceType,\n"
"            ISlangBlob** outNameBlob) = 0;\n"
"\n"
"            /** Get the sequential ID used to identify a type witness in a dynamic object.\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL getTypeConformanceWitnessSequentialID(\n"
"            slang::TypeReflection* type,\n"
"            slang::TypeReflection* interfaceType,\n"
"            uint32_t*              outId) = 0;\n"
"\n"
"            /** Create a request to load/compile front-end code.\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL createCompileRequest(\n"
"            SlangCompileRequest**   outCompileRequest) = 0;\n"
"\n"
"        \n"
"            /** Creates a `IComponentType` that represents a type's conformance to an interface.\n"
"                The retrieved `ITypeConformance` objects can be included in a composite `IComponentType`\n"
"                to explicitly specify which implementation types should be included in the final compiled\n"
"                code. For example, if an module defines `IMaterial` interface and `AMaterial`,\n"
"                `BMaterial`, `CMaterial` types that implements the interface, the user can exclude\n"
"                `CMaterial` implementation from the resulting shader code by explcitly adding\n"
"                `AMaterial:IMaterial` and `BMaterial:IMaterial` conformances to a composite\n"
"                `IComponentType` and get entry point code from it. The resulting code will not have\n"
"                anything related to `CMaterial` in the dynamic dispatch logic. If the user does not\n"
"                explicitly include any `TypeConformances` to an interface type, all implementations to\n"
"                that interface will be included by default. By linking a `ITypeConformance`, the user is\n"
"                also given the opportunity to specify the dispatch ID of the implementation type. If\n"
"                `conformanceIdOverride` is -1, there will be no override behavior and Slang will\n"
"                automatically assign IDs to implementation types. The automatically assigned IDs can be\n"
"                queried via `ISession::getTypeConformanceWitnessSequentialID`.\n"
"\n"
"                Returns SLANG_OK if succeeds, or SLANG_FAIL if `type` does not conform to `interfaceType`.\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL createTypeConformanceComponentType(\n"
"            slang::TypeReflection* type,\n"
"            slang::TypeReflection* interfaceType,\n"
"            ITypeConformance** outConformance,\n"
"            SlangInt conformanceIdOverride,\n"
"            ISlangBlob** outDiagnostics) = 0;\n"
"\n"
"            /** Load a module from a Slang module blob.\n"
"            */\n"
"        virtual SLANG_NO_THROW IModule* SLANG_MCALL loadModuleFromIRBlob(\n"
"            const char* moduleName,\n"
"            const char* path,\n"
"            slang::IBlob* source,\n"
"            slang::IBlob** outDiagnostics = nullptr) = 0;\n"
"\n"
"        virtual SLANG_NO_THROW SlangInt SLANG_MCALL getLoadedModuleCount() = 0;\n"
"        virtual SLANG_NO_THROW IModule* SLANG_MCALL getLoadedModule(SlangInt index) = 0;\n"
"\n"
"            /** Checks if a precompiled binary module is up-to-date with the current compiler\n"
"            *   option settings and the source file contents.\n"
"            */\n"
"        virtual SLANG_NO_THROW bool SLANG_MCALL isBinaryModuleUpToDate(\n"
"            const char* modulePath, slang::IBlob* binaryModuleBlob) = 0;\n"
"\n"
"            /** Load a module from a string.\n"
"            */\n"
"        virtual SLANG_NO_THROW IModule* SLANG_MCALL loadModuleFromSourceString(\n"
"            const char* moduleName,\n"
"            const char* path,\n"
"            const char* string,\n"
"            slang::IBlob** outDiagnostics = nullptr) = 0;\n"
"    };\n"
"\n"
"    #define SLANG_UUID_ISession ISession::getTypeGuid()\n"
"\n"
"        /** A component type is a unit of shader code layout, reflection, and linking.\n"
"\n"
"        A component type is a unit of shader code that can be included into\n"
"        a linked and compiled shader program. Each component type may have:\n"
"\n"
"        * Zero or more uniform shader parameters, representing textures,\n"
"          buffers, etc. that the code in the component depends on.\n"
"\n"
"        * Zero or more *specialization* parameters, which are type or\n"
"          value parameters that can be used to synthesize specialized\n"
"          versions of the component type.\n"
"\n"
"        * Zero or more entry points, which are the individually invocable\n"
"          kernels that can have final code generated.\n"
"\n"
"        * Zero or more *requirements*, which are other component\n"
"          types on which the component type depends.\n"
"\n"
"        One example of a component type is a module of Slang code:\n"
"\n"
"        * The global-scope shader parameters declared in the module are\n"
"          the parameters when considered as a component type.\n"
"\n"
"        * Any global-scope generic or interface type parameters introduce\n"
"          specialization parameters for the module.\n"
"\n"
"        * A module does not by default include any entry points when\n"
"          considered as a component type (although the code of the\n"
"          module might *declare* some entry points).\n"
"\n"
"        * Any other modules that are `import`ed in the source code\n"
"          become requirements of the module, when considered as a\n"
"          component type.\n"
"\n"
"        An entry point is another example of a component type:\n"
"\n"
"        * The `uniform` parameters of the entry point function are\n"
"          its shader parameters when considered as a component type.\n"
"\n"
"        * Any generic or interface-type parameters of the entry point\n"
"          introduce specialization parameters.\n"
"\n"
"        * An entry point component type exposes a single entry point (itself).\n"
"\n"
"        * An entry point has one requirement for the module in which\n"
"          it was defined.\n"
"\n"
"        Component types can be manipulated in a few ways:\n"
"\n"
"        * Multiple component types can be combined into a composite, which\n"
"          combines all of their code, parameters, etc.\n"
"\n"
"        * A component type can be specialized, by \"plugging in\" types and\n"
"          values for its specialization parameters.\n"
"\n"
"        * A component type can be laid out for a particular target, giving\n"
"          offsets/bindings to the shader parameters it contains.\n"
"\n"
"        * Generated kernel code can be requested for entry points.\n"
"\n"
"        */\n"
"    struct IComponentType : public ISlangUnknown\n"
"    {\n"
"        SLANG_COM_INTERFACE(0x5bc42be8, 0x5c50, 0x4929, { 0x9e, 0x5e, 0xd1, 0x5e, 0x7c, 0x24, 0x1, 0x5f })\n"
"\n"
"            /** Get the runtime session that this component type belongs to.\n"
"            */\n"
"        virtual SLANG_NO_THROW ISession* SLANG_MCALL getSession() = 0;\n"
"\n"
"            /** Get the layout for this program for the chosen `targetIndex`.\n"
"\n"
"            The resulting layout will establish offsets/bindings for all\n"
"            of the global and entry-point shader parameters in the\n"
"            component type.\n"
"\n"
"            If this component type has specialization parameters (that is,\n"
"            it is not fully specialized), then the resulting layout may\n"
"            be incomplete, and plugging in arguments for generic specialization\n"
"            parameters may result in a component type that doesn't have\n"
"            a compatible layout. If the component type only uses\n"
"            interface-type specialization parameters, then the layout\n"
"            for a specialization should be compatible with an unspecialized\n"
"            layout (all parameters in the unspecialized layout will have\n"
"            the same offset/binding in the specialized layout).\n"
"\n"
"            If this component type is combined into a composite, then\n"
"            the absolute offsets/bindings of parameters may not stay the same.\n"
"            If the shader parameters in a component type don't make\n"
"            use of explicit binding annotations (e.g., `register(...)`),\n"
"            then the *relative* offset of shader parameters will stay\n"
"            the same when it is used in a composition.\n"
"            */\n"
"        virtual SLANG_NO_THROW ProgramLayout* SLANG_MCALL getLayout(\n"
"            SlangInt    targetIndex = 0,\n"
"            IBlob**     outDiagnostics = nullptr) = 0;\n"
"\n"
"            /** Get the number of (unspecialized) specialization parameters for the component type.\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangInt SLANG_MCALL getSpecializationParamCount() = 0;\n"
"\n"
"            /** Get the compiled code for the entry point at `entryPointIndex` for the chosen `targetIndex`\n"
"\n"
"            Entry point code can only be computed for a component type that\n"
"            has no specialization parameters (it must be fully specialized)\n"
"            and that has no requirements (it must be fully linked).\n"
"\n"
"            If code has not already been generated for the given entry point and target,\n"
"            then a compilation error may be detected, in which case `outDiagnostics`\n"
"            (if non-null) will be filled in with a blob of messages diagnosing the error.\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL getEntryPointCode(\n"
"            SlangInt    entryPointIndex,\n"
"            SlangInt    targetIndex,\n"
"            IBlob**     outCode,\n"
"            IBlob**     outDiagnostics = nullptr) = 0;\n"
"\n"
"            /** Get the compilation result as a file system.\n"
"\n"
"            Has the same requirements as getEntryPointCode.\n"
"\n"
"            The result is not written to the actual OS file system, but is made avaiable as an\n"
"            in memory representation.\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL getResultAsFileSystem(\n"
"            SlangInt    entryPointIndex,\n"
"            SlangInt    targetIndex, \n"
"            ISlangMutableFileSystem** outFileSystem) = 0;\n"
"\n"
"            /** Compute a hash for the entry point at `entryPointIndex` for the chosen `targetIndex`.\n"
"\n"
"            This computes a hash based on all the dependencies for this component type as well as the\n"
"            target settings affecting the compiler backend. The computed hash is used as a key for caching\n"
"            the output of the compiler backend to implement shader caching.\n"
"            */\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL getEntryPointHash(\n"
"            SlangInt    entryPointIndex,\n"
"            SlangInt    targetIndex,\n"
"            IBlob**     outHash) = 0;\n"
"\n"
"            /** Specialize the component by binding its specialization parameters to concrete arguments.\n"
"\n"
"            The `specializationArgs` array must have `specializationArgCount` entries, and\n"
"            this must match the number of specialization parameters on this component type.\n"
"\n"
"            If any diagnostics (error or warnings) are produced, they will be written to `outDiagnostics`.\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL specialize(\n"
"            SpecializationArg const*    specializationArgs,\n"
"            SlangInt                    specializationArgCount,\n"
"            IComponentType**            outSpecializedComponentType,\n"
"            ISlangBlob**                outDiagnostics = nullptr) = 0;\n"
"\n"
"            /** Link this component type against all of its unsatisifed dependencies.\n"
"            \n"
"            A component type may have unsatisfied dependencies. For example, a module\n"
"            depends on any other modules it `import`s, and an entry point depends\n"
"            on the module that defined it.\n"
"\n"
"            A user can manually satisfy dependencies by creating a composite\n"
"            component type, and when doing so they retain full control over\n"
"            the relative ordering of shader parameters in the resulting layout.\n"
"\n"
"            It is an error to try to generate/access compiled kernel code for\n"
"            a component type with unresolved dependencies, so if dependencies\n"
"            remain after whatever manual composition steps an application\n"
"            cares to peform, the `link()` function can be used to automatically\n"
"            compose in any remaining dependencies. The order of parameters\n"
"            (and hence the global layout) that results will be deterministic,\n"
"            but is not currently documented.\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL link(\n"
"            IComponentType**            outLinkedComponentType,\n"
"            ISlangBlob**                outDiagnostics = nullptr) = 0;\n"
"\n"
"            /** Get entry point 'callable' functions accessible through the ISlangSharedLibrary interface.\n"
"\n"
"            The functions remain in scope as long as the ISlangSharedLibrary interface is in scope.\n"
"\n"
"            NOTE! Requires a compilation target of SLANG_HOST_CALLABLE.\n"
"    \n"
"            @param entryPointIndex  The index of the entry point to get code for.\n"
"            @param targetIndex      The index of the target to get code for (default: zero).\n"
"            @param outSharedLibrary A pointer to a ISharedLibrary interface which functions can be queried on.\n"
"            @returns                A `SlangResult` to indicate success or failure.\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL getEntryPointHostCallable(\n"
"            int                     entryPointIndex,\n"
"            int                     targetIndex,\n"
"            ISlangSharedLibrary**   outSharedLibrary,\n"
"            slang::IBlob**          outDiagnostics = 0) = 0;\n"
"\n"
"            /** Get a new ComponentType object that represents a renamed entry point.\n"
"\n"
"            The current object must be a single EntryPoint, or a CompositeComponentType or\n"
"            SpecializedComponentType that contains one EntryPoint component.\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL renameEntryPoint(\n"
"            const char* newName, IComponentType** outEntryPoint) = 0;\n"
"        \n"
"            /** Link and specify additional compiler options when generating code\n"
"            *   from the linked program.\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL linkWithOptions(\n"
"            IComponentType** outLinkedComponentType,\n"
"            uint32_t compilerOptionEntryCount,\n"
"            CompilerOptionEntry* compilerOptionEntries,\n"
"            ISlangBlob** outDiagnostics = nullptr) = 0;\n"
"    };\n"
"    #define SLANG_UUID_IComponentType IComponentType::getTypeGuid()\n"
"\n"
"    struct IEntryPoint : public IComponentType\n"
"    {\n"
"        SLANG_COM_INTERFACE(0x8f241361, 0xf5bd, 0x4ca0, { 0xa3, 0xac, 0x2, 0xf7, 0xfa, 0x24, 0x2, 0xb8 })\n"
"    };\n"
"\n"
"    #define SLANG_UUID_IEntryPoint IEntryPoint::getTypeGuid()\n"
"\n"
"    struct ITypeConformance : public IComponentType\n"
"    {\n"
"        SLANG_COM_INTERFACE(0x73eb3147, 0xe544, 0x41b5, { 0xb8, 0xf0, 0xa2, 0x44, 0xdf, 0x21, 0x94, 0xb })\n"
"    };\n"
"    #define SLANG_UUID_ITypeConformance ITypeConformance::getTypeGuid()\n"
"\n"
;
sb << 
"        /** A module is the granularity of shader code compilation and loading.\n"
"\n"
"        In most cases a module corresponds to a single compile \"translation unit.\"\n"
"        This will often be a single `.slang` or `.hlsl` file and everything it\n"
"        `#include`s.\n"
"\n"
"        Notably, a module `M` does *not* include the things it `import`s, as these\n"
"        as distinct modules that `M` depends on. There is a directed graph of\n"
"        module dependencies, and all modules in the graph must belong to the\n"
"        same session (`ISession`).\n"
"\n"
"        A module establishes a namespace for looking up types, functions, etc.\n"
"        */\n"
"    struct IModule : public IComponentType\n"
"    {\n"
"        SLANG_COM_INTERFACE(0xc720e64, 0x8722, 0x4d31, { 0x89, 0x90, 0x63, 0x8a, 0x98, 0xb1, 0xc2, 0x79 })\n"
"\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL findEntryPointByName(\n"
"            char const*     name,\n"
"            IEntryPoint**   outEntryPoint) = 0;\n"
"\n"
"        /// Get number of entry points defined in the module. An entry point defined in a module\n"
"        /// is by default not included in the linkage, so calls to `IComponentType::getEntryPointCount`\n"
"        /// on an `IModule` instance will always return 0. However `IModule::getDefinedEntryPointCount`\n"
"        /// will return the number of defined entry points.\n"
"        virtual SLANG_NO_THROW SlangInt32 SLANG_MCALL getDefinedEntryPointCount() = 0;\n"
"        /// Get the name of an entry point defined in the module.\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL\n"
"            getDefinedEntryPoint(SlangInt32 index, IEntryPoint** outEntryPoint) = 0;\n"
"\n"
"        /// Get a serialized representation of the checked module.\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL serialize(ISlangBlob** outSerializedBlob) = 0;\n"
"\n"
"        /// Write the serialized representation of this module to a file.\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL writeToFile(char const* fileName) = 0;\n"
"\n"
"        /// Get the name of the module.\n"
"        virtual SLANG_NO_THROW const char* SLANG_MCALL getName() = 0;\n"
"\n"
"        /// Get the path of the module.\n"
"        virtual SLANG_NO_THROW const char* SLANG_MCALL getFilePath() = 0;\n"
"\n"
"        /// Get the unique identity of the module.\n"
"        virtual SLANG_NO_THROW const char* SLANG_MCALL getUniqueIdentity() = 0;\n"
"\n"
"    };\n"
"    \n"
"    #define SLANG_UUID_IModule IModule::getTypeGuid()\n"
"\n"
"        /** Argument used for specialization to types/values.\n"
"        */\n"
"    struct SpecializationArg\n"
"    {\n"
"        enum class Kind : int32_t\n"
"        {\n"
"            Unknown,    /**< An invalid specialization argument. */\n"
"            Type,       /**< Specialize to a type. */\n"
"        };\n"
"\n"
"        /** The kind of specialization argument. */\n"
"        Kind kind;\n"
"        union\n"
"        {\n"
"            /** A type specialization argument, used for `Kind::Type`. */\n"
"            TypeReflection* type;\n"
"        };\n"
"\n"
"        static SpecializationArg fromType(TypeReflection* inType)\n"
"        {\n"
"            SpecializationArg rs;\n"
"            rs.kind = Kind::Type;\n"
"            rs.type = inType;\n"
"            return rs;\n"
"        }\n"
"    };\n"
"}\n"
"\n"
"// Passed into functions to create globalSession to identify the API version client code is\n"
"// using. \n"
"#define SLANG_API_VERSION 0\n"
"\n"
"/* Create a global session, with built in StdLib.\n"
"\n"
"@param apiVersion Pass in SLANG_API_VERSION\n"
"@param outGlobalSession (out)The created global session. \n"
"*/\n"
"SLANG_EXTERN_C SLANG_API SlangResult slang_createGlobalSession(\n"
"    SlangInt                apiVersion,\n"
"    slang::IGlobalSession** outGlobalSession);\n"
"\n"
"/* Create a global session, but do not set up the stdlib. The stdlib can\n"
"then be loaded via loadStdLib or compileStdLib\n"
"\n"
"@param apiVersion Pass in SLANG_API_VERSION\n"
"@param outGlobalSession (out)The created global session that doesn't have a StdLib setup.\n"
"\n"
"NOTE! API is experimental and not ready for production code \n"
"*/\n"
"SLANG_EXTERN_C SLANG_API SlangResult slang_createGlobalSessionWithoutStdLib(\n"
"    SlangInt                apiVersion,\n"
"    slang::IGlobalSession** outGlobalSession);\n"
"\n"
"/* Returns a blob that contains the serialized stdlib.\n"
"Returns nullptr if there isn't an embedded stdlib.\n"
"*/\n"
"SLANG_API ISlangBlob* slang_getEmbeddedStdLib();\n"
"\n"
"namespace slang\n"
"{\n"
"    inline SlangResult createGlobalSession(\n"
"        slang::IGlobalSession** outGlobalSession)\n"
"    {\n"
"        return slang_createGlobalSession(SLANG_API_VERSION, outGlobalSession);\n"
"    }\n"
"}\n"
"\n"
"/** @see slang::ICompileRequest::getProgram\n"
"*/\n"
"SLANG_EXTERN_C SLANG_API SlangResult spCompileRequest_getProgram(\n"
"    SlangCompileRequest*    request,\n"
"    slang::IComponentType** outProgram);\n"
"\n"
"/** @see slang::ICompileRequest::getProgramWithEntryPoints\n"
"*/\n"
"SLANG_EXTERN_C SLANG_API SlangResult spCompileRequest_getProgramWithEntryPoints(\n"
"    SlangCompileRequest*    request,\n"
"    slang::IComponentType** outProgram);\n"
"\n"
"/** @see slang::ICompileRequest::getEntryPoint\n"
"*/\n"
"SLANG_EXTERN_C SLANG_API SlangResult spCompileRequest_getEntryPoint(\n"
"    SlangCompileRequest*    request,\n"
"    SlangInt                entryPointIndex,\n"
"    slang::IComponentType** outEntryPoint);\n"
"\n"
"/** @see slang::ICompileRequest::getModule\n"
"*/\n"
"SLANG_EXTERN_C SLANG_API SlangResult spCompileRequest_getModule(\n"
"    SlangCompileRequest*    request,\n"
"    SlangInt                translationUnitIndex,\n"
"    slang::IModule**        outModule);\n"
"\n"
"/** @see slang::ICompileRequest::getSession\n"
"*/\n"
"SLANG_EXTERN_C SLANG_API SlangResult spCompileRequest_getSession(\n"
"    SlangCompileRequest* request,\n"
"    slang::ISession** outSession);\n"
"#endif\n"
"\n"
"/* DEPRECATED DEFINITIONS\n"
"\n"
"Everything below this point represents deprecated APIs/definition that are only\n"
"being kept around for source/binary compatibility with old client code. New\n"
"code should not use any of these declarations, and the Slang API will drop these\n"
"declarations over time.\n"
"*/\n"
"\n"
"#ifdef __cplusplus\n"
"extern \"C\" {\n"
"#endif\n"
"\n"
"#define SLANG_ERROR_INSUFFICIENT_BUFFER SLANG_E_BUFFER_TOO_SMALL\n"
"#define SLANG_ERROR_INVALID_PARAMETER SLANG_E_INVALID_ARG\n"
"\n"
"SLANG_API char const* spGetTranslationUnitSource(\n"
"    SlangCompileRequest*    request,\n"
"    int                     translationUnitIndex);\n"
"\n"
"#ifdef __cplusplus\n"
"}\n"
"#endif\n"
"\n"
"#endif\n"
"\n"
"\n"
"#include <assert.h>\n"
"\n"
"#include <stdint.h>\n"
"\n"
"#ifndef SLANG_CORE_SIGNAL_H\n"
"#define SLANG_CORE_SIGNAL_H\n"
"\n"
"\n"
"namespace Slang\n"
"{\n"
"\n"
"enum class SignalType\n"
"{\n"
"    Unexpected,\n"
"    Unimplemented,\n"
"    AssertFailure,\n"
"    Unreachable,\n"
"    InvalidOperation,\n"
"    AbortCompilation,\n"
"};\n"
"\n"
"\n"
"// Note that message can be passed as nullptr for no message.\n"
"SLANG_RETURN_NEVER void handleSignal(SignalType type, char const* message);\n"
"\n"
"#define SLANG_UNEXPECTED(reason) \\\n"
"    ::Slang::handleSignal(::Slang::SignalType::Unexpected, reason)\n"
"\n"
"#define SLANG_UNIMPLEMENTED_X(what) \\\n"
"    ::Slang::handleSignal(::Slang::SignalType::Unimplemented, what)\n"
"\n"
"#define SLANG_UNREACHABLE(msg) \\\n"
"    ::Slang::handleSignal(::Slang::SignalType::Unreachable, msg)\n"
"\n"
"#define SLANG_ASSERT_FAILURE(msg) \\\n"
"    ::Slang::handleSignal(::Slang::SignalType::AssertFailure, msg)\n"
"\n"
"#define SLANG_INVALID_OPERATION(msg) \\\n"
"    ::Slang::handleSignal(::Slang::SignalType::InvalidOperation, msg)\n"
"\n"
"#define SLANG_ABORT_COMPILATION(msg) \\\n"
"    ::Slang::handleSignal(::Slang::SignalType::AbortCompilation, msg)\n"
"\n"
"\n"
"}\n"
"\n"
"#endif\n"
"\n"
"\n"
"#define VARIADIC_TEMPLATE\n"
"\n"
"namespace Slang\n"
"{\n"
"    \n"
"\ttypedef int32_t Int32;\n"
"\ttypedef uint32_t UInt32;\n"
"\n"
"\ttypedef int64_t Int64;\n"
"\ttypedef uint64_t UInt64;\n"
"\n"
"    // Define \n"
"    typedef SlangUInt UInt;\n"
"    typedef SlangInt Int;\n"
"\n"
"    static const UInt kMaxUInt = ~UInt(0);\n"
"    static const Int kMaxInt = Int(kMaxUInt >> 1);\n"
"\n"
"//\ttypedef unsigned short Word;\n"
"\n"
"\ttypedef intptr_t PtrInt;\n"
"\n"
"    // TODO(JS): It looks like Index is actually 64 bit on 64 bit targets(!)\n"
"    // Previous discussions landed on Index being int32_t.\n"
"\n"
"    // Type used for indexing, in arrays/views etc. Signed.\n"
"    typedef Int Index;\n"
"    typedef UInt UIndex;\n"
"    typedef Int Count;\n"
"    typedef UInt UCount;\n"
"\n"
"    static const Index kMaxIndex = kMaxInt;\n"
"\n"
"    typedef uint8_t Byte;\n"
"\n"
"    // TODO(JS):\n"
"    // Perhaps these should be named Utf8, Utf16 and UnicodePoint/Rune/etc? For now, just keep it simple\n"
"    //\n"
"    typedef char Char8;\n"
"    // 16 bit character. Note much like in utf8, a character may or may not represent a code point (it can be part of a code point).  \n"
"    typedef uint16_t Char16;\n"
"\n"
"    // Can always hold a unicode code point.\n"
"    typedef uint32_t Char32;\n"
"\n"
"\ttemplate <typename T>\n"
"\tinline T&& _Move(T & obj)\n"
"\t{\n"
"\t\treturn static_cast<T&&>(obj);\n"
"\t}\n"
"\n"
"\ttemplate <typename T>\n"
"\tinline void Swap(T & v0, T & v1)\n"
"\t{\n"
"\t\tT tmp = _Move(v0);\n"
"\t\tv0 = _Move(v1);\n"
"\t\tv1 = _Move(tmp);\n"
"\t}\n"
"\n"
"    // Make these interfaces have more convenient names\n"
"    typedef ISlangCastable ICastable;\n"
"    typedef ISlangClonable IClonable;\n"
"\n"
"    // Convenience function for using clonable\n"
"    template <typename T>\n"
"    SLANG_FORCE_INLINE T* clone(IClonable* clonable) { return (T*)clonable->clone(T::getTypeGuid()); }\n"
"\n"
"    template <typename T>\n"
"    inline bool isBitSet(T value, T bitToTest)\n"
"    {\n"
"        static_assert(sizeof(T) <= sizeof(uint32_t), \"Only support up to 32 bit enums\");\n"
"        return (T)((uint32_t)value & (uint32_t)bitToTest) == bitToTest;\n"
"    }\n"
"}\n"
"\n"
"//\n"
"// Some macros for avoiding boilerplate\n"
"// TODO: could probably deduce the size with templates, and move the whole\n"
"// thing into a template\n"
"//\n"
"#if __cplusplus >= 202002L\n"
"#define SLANG_COMPONENTWISE_EQUALITY_1(type) bool operator==(const type& other) const = default;\n"
"#define SLANG_COMPONENTWISE_EQUALITY_2(type) bool operator==(const type& other) const = default;\n"
"#define SLANG_COMPONENTWISE_EQUALITY_3(type) bool operator==(const type& other) const = default;\n"
"#else\n"
"#define SLANG_COMPONENTWISE_EQUALITY_1(type) \\\n"
"    bool operator==(const type& other) const \\\n"
"    { \\\n"
"        const auto& [m1] = *this; \\\n"
"        const auto& [o1] = other; \\\n"
"        return m1 == o1; \\\n"
"    } \\\n"
"    bool operator!=(const type& other) const \\\n"
"    { \\\n"
"        return !(*this == other); \\\n"
"    }\n"
"\n"
"#define SLANG_COMPONENTWISE_EQUALITY_2(type) \\\n"
"    bool operator==(const type& other) const \\\n"
"    { \\\n"
"        const auto& [m1, m2] = *this; \\\n"
"        const auto& [o1, o2] = other; \\\n"
"        return m1 == o1 && m2 == o2; \\\n"
"    } \\\n"
"    bool operator!=(const type& other) const \\\n"
"    { \\\n"
"        return !(*this == other); \\\n"
"    }\n"
"\n"
"#define SLANG_COMPONENTWISE_EQUALITY_3(type) \\\n"
"    bool operator==(const type& other) const \\\n"
"    { \\\n"
"        const auto& [m1, m2, m3] = *this; \\\n"
"        const auto& [o1, o2, o3] = other; \\\n"
"        return m1 == o1 && m2 == o2 && m3 == o3; \\\n"
"    } \\\n"
"    bool operator!=(const type& other) const \\\n"
"    { \\\n"
"        return !(*this == other); \\\n"
"    }\n"
"#endif\n"
"\n"
"// TODO: Shouldn't these be SLANG_ prefixed?\n"
"#ifdef _MSC_VER\n"
"#define UNREACHABLE_RETURN(x)\n"
"#else\n"
"#define UNREACHABLE_RETURN(x) return x;\n"
"#endif\n"
"\n"
"//\n"
"// Use `SLANG_ASSUME(myBoolExpression);` to inform the compiler that the condition is true.\n"
"// Do not rely on side effects of the condition being performed.\n"
"//\n"
"#if defined(__cpp_assume)\n"
"#    define SLANG_ASSUME(X) [[assume(X)]]\n"
"#elif SLANG_GCC\n"
"#    define SLANG_ASSUME(X) do{if(!(X)) __builtin_unreachable();} while(0)\n"
"#elif SLANG_CLANG\n"
"#    define SLANG_ASSUME(X) __builtin_assume(X)\n"
"#elif SLANG_VC\n"
"#    define SLANG_ASSUME(X) __assume(X)\n"
"#else\n"
"     [[noreturn]] inline void invokeUndefinedBehaviour() {}\n"
"#    define SLANG_ASSUME(X) do{if(!(X)) invokeUndefinedBehaviour();} while(0)\n"
"#endif\n"
"\n"
"//\n"
"// Assertions abort in debug builds, but inform the compiler of true\n"
"// assumptions in release builds\n"
"//\n"
"#ifdef _DEBUG\n"
"#define SLANG_ASSERT(VALUE) do{if(!(VALUE)) SLANG_ASSERT_FAILURE(#VALUE);} while(0)\n"
"#else\n"
"#define SLANG_ASSERT(VALUE) SLANG_ASSUME(VALUE)\n"
"#endif\n"
"\n"
"#define SLANG_RELEASE_ASSERT(VALUE) if(VALUE) {} else SLANG_ASSERT_FAILURE(#VALUE)\n"
"\n"
"template<typename T> void slang_use_obj(T&) {}\n"
"\n"
"#define SLANG_UNREFERENCED_PARAMETER(P) slang_use_obj(P)\n"
"#define SLANG_UNREFERENCED_VARIABLE(P) slang_use_obj(P)\n"
"#endif\n"
"\n"
"#if defined(SLANG_RT_DYNAMIC)\n"
"#if defined(_MSC_VER)\n"
"#    ifdef SLANG_RT_DYNAMIC_EXPORT\n"
"#        define SLANG_RT_API SLANG_DLL_EXPORT\n"
"#    else\n"
"#        define SLANG_RT_API __declspec(dllimport)\n"
"#    endif\n"
"#else\n"
"// TODO: need to consider compiler capabilities\n"
"//#     ifdef SLANG_RT_DYNAMIC_EXPORT\n"
"#    define SLANG_RT_API SLANG_DLL_EXPORT\n"
"//#     endif\n"
"#endif\n"
"#endif\n"
"\n"
"#if defined(_MSC_VER)\n"
"#   define SLANG_ATTR_PRINTF(string_index, varargs_index)\n"
"#else\n"
"#   define SLANG_ATTR_PRINTF(string_index, varargs_index) __attribute__((format(printf, string_index, varargs_index)))\n"
"#endif\n"
"\n"
"#ifndef SLANG_RT_API\n"
"#define SLANG_RT_API\n"
"#endif\n"
"\n"
"#ifndef SLANG_CORE_HASH_H\n"
"#define SLANG_CORE_HASH_H\n"
"\n"
"#ifndef SLANG_CORE_MATH_H\n"
"#define SLANG_CORE_MATH_H\n"
"\n"
"#include <cmath>\n"
"\n"
"namespace Slang\n"
"{\n"
"    // Some handy constants\n"
"\n"
"    // The largest positive (or negative) number \n"
"#   define SLANG_HALF_MAX 65504.0f\n"
"    // Smallest (denormalized) value. 1 / 2^24\n"
"#   define SLANG_HALF_SUB_NORMAL_MIN (1.0f / 16777216.0f)\n"
"\n"
"\tclass Math\n"
"\t{\n"
"\tpublic:\n"
"        // Use to fix type punning issues with strict aliasing\n"
"        union FloatIntUnion\n"
"        {\n"
"            float fvalue;\n"
"            int ivalue;\n"
"\n"
"            SLANG_FORCE_INLINE static FloatIntUnion makeFromInt(int i) { FloatIntUnion cast; cast.ivalue = i; return cast; }\n"
"            SLANG_FORCE_INLINE static FloatIntUnion makeFromFloat(float f) { FloatIntUnion cast; cast.fvalue = f; return cast; }\n"
"        };\n"
"        union DoubleInt64Union\n"
"        {\n"
"            double dvalue;\n"
"            int64_t ivalue;\n"
"            SLANG_FORCE_INLINE static DoubleInt64Union makeFromInt64(int64_t i) { DoubleInt64Union cast; cast.ivalue = i; return cast; }\n"
"            SLANG_FORCE_INLINE static DoubleInt64Union makeFromDouble(double d) { DoubleInt64Union cast; cast.dvalue = d; return cast; }\n"
"        };\n"
"        \n"
"\t\tstatic const float Pi;\n"
"\n"
"        template <typename T>\n"
"        static T Abs(T a)\n"
"        {\n"
"            return (a < 0) ? -a : a;\n"
"        }\n"
"\n"
"\t\ttemplate<typename T>\n"
"\t\tstatic T Min(const T& v1, const T&v2)\n"
"\t\t{\n"
"\t\t\treturn v1<v2?v1:v2;\n"
"\t\t}\n"
"\t\ttemplate<typename T>\n"
"\t\tstatic T Max(const T& v1, const T&v2)\n"
"\t\t{\n"
"\t\t\treturn v1>v2?v1:v2;\n"
"\t\t}\n"
"\t\ttemplate<typename T>\n"
"\t\tstatic T Min(const T& v1, const T&v2, const T&v3)\n"
"\t\t{\n"
"\t\t\treturn Min(v1, Min(v2, v3));\n"
"\t\t}\n"
"\t\ttemplate<typename T>\n"
"\t\tstatic T Max(const T& v1, const T&v2, const T&v3)\n"
"\t\t{\n"
"\t\t\treturn Max(v1, Max(v2, v3));\n"
"\t\t}\n"
"\t\ttemplate<typename T>\n"
"\t\tstatic T Clamp(const T& val, const T& vmin, const T&vmax)\n"
"\t\t{\n"
"\t\t\tif (val < vmin) return vmin;\n"
"\t\t\telse if (val > vmax) return vmax;\n"
"\t\t\telse return val;\n"
"\t\t}\n"
"\n"
"\t\tstatic inline int FastFloor(float x)\n"
"\t\t{\n"
"\t\t\tint i = (int)x;\n"
"\t\t\treturn i - (i > x);\n"
"\t\t}\n"
"\n"
"\t\tstatic inline int FastFloor(double x)\n"
"\t\t{\n"
"\t\t\tint i = (int)x;\n"
"\t\t\treturn i - (i > x);\n"
"\t\t}\n"
"\n"
"\t\tstatic inline int IsNaN(float x)\n"
"\t\t{\n"
"\t\t\treturn std::isnan(x);\n"
"\t\t}\n"
"\n"
"\t\tstatic inline int IsInf(float x)\n"
"\t\t{\n"
"\t\t\treturn std::isinf(x);\n"
"\t\t}\n"
"\n"
"\t\tstatic inline unsigned int Ones32(unsigned int x)\n"
"\t\t{\n"
"\t\t\t/* 32-bit recursive reduction using SWAR...\n"
"\t\t\t\tbut first step is mapping 2-bit values\n"
"\t\t\t\tinto sum of 2 1-bit values in sneaky way\n"
"\t\t\t*/\n"
"\t\t\tx -= ((x >> 1) & 0x55555555);\n"
"\t\t\tx = (((x >> 2) & 0x33333333) + (x & 0x33333333));\n"
"\t\t\tx = (((x >> 4) + x) & 0x0f0f0f0f);\n"
"\t\t\tx += (x >> 8);\n"
"\t\t\tx += (x >> 16);\n"
"\t\t\treturn(x & 0x0000003f);\n"
"\t\t}\n"
"\n"
"\t\tstatic inline unsigned int Log2Floor(unsigned int x)\n"
"\t\t{\n"
"\t\t\tx |= (x >> 1);\n"
"\t\t\tx |= (x >> 2);\n"
"\t\t\tx |= (x >> 4);\n"
"\t\t\tx |= (x >> 8);\n"
"\t\t\tx |= (x >> 16);\n"
"\t\t\treturn(Ones32(x >> 1));\n"
"\t\t}\n"
"\n"
"\t\tstatic inline unsigned int Log2Ceil(unsigned int x)\n"
"\t\t{\n"
"\t\t\tint y = (x & (x - 1));\n"
"\t\t\ty |= -y;\n"
"\t\t\ty >>= (32 - 1);\n"
"\t\t\tx |= (x >> 1);\n"
"\t\t\tx |= (x >> 2);\n"
"\t\t\tx |= (x >> 4);\n"
"\t\t\tx |= (x >> 8);\n"
"\t\t\tx |= (x >> 16);\n"
"\t\t\treturn(Ones32(x >> 1) - y);\n"
"\t\t}\n"
"\t\t/*\n"
"\t\tstatic inline int Log2(float x)\n"
"\t\t{\n"
"\t\t\tunsigned int ix = (unsigned int&)x;\n"
"\t\t\tunsigned int exp = (ix >> 23) & 0xFF;\n"
"\t\t\tint log2 = (unsigned int)(exp) - 127;\n"
"\n"
"\t\t\treturn log2;\n"
"\t\t}\n"
"\t\t*/\n"
"\n"
"        static bool AreNearlyEqual(double a, double b, double epsilon)\n"
"        {\n"
"            // If they are equal then we are done\n"
"            if (a == b)\n"
"            {\n"
"                return true;\n"
"            }\n"
"\n"
"            const double absA = Abs(a);\n"
"            const double absB = Abs(b);\n"
"            const double diff = Abs(a - b);\n"
"\n"
"            // https://en.wikipedia.org/wiki/Double_precision_floating-point_format\n"
"            const double minNormal = 2.2250738585072014e-308;\n"
"            // Either a or b are very close to being zero, so doing relative comparison isn't really appropriate\n"
"            if (a == 0.0 || b == 0.0 || (absA + absB < minNormal))\n"
"            {\n"
"                return diff < (epsilon * minNormal);\n"
"            }\n"
"            else\n"
"            {\n"
"                // Calculate a relative relative error\n"
"                return diff < epsilon * (absA + absB);\n"
"            }\n"
"        }\n"
"\n"
"        template <typename T>\n"
"        static T getLowestBit(T val)\n"
"        {\n"
"            return val & (-val);\n"
"        }\n"
"\t};\n"
"    inline int FloatAsInt(float val)\n"
"\t{\n"
"        return Math::FloatIntUnion::makeFromFloat(val).ivalue; \n"
"\t}\n"
"    inline float IntAsFloat(int val)\n"
"\t{\n"
"        return Math::FloatIntUnion::makeFromInt(val).fvalue; \n"
"\t}\n"
"\n"
"    SLANG_FORCE_INLINE int64_t DoubleAsInt64(double val)\n"
"    {\n"
;
sb << 
"        return Math::DoubleInt64Union::makeFromDouble(val).ivalue;\n"
"    }\n"
"    SLANG_FORCE_INLINE double Int64AsDouble(int64_t value)\n"
"    {\n"
"        return Math::DoubleInt64Union::makeFromInt64(value).dvalue;\n"
"    }\n"
"\n"
"\tinline unsigned short FloatToHalf(float val)\n"
"\t{\n"
"        const auto x = FloatAsInt(val);\n"
"        \n"
"\t\tunsigned short bits = (x >> 16) & 0x8000;\n"
"\t\tunsigned short m = (x >> 12) & 0x07ff;\n"
"\t\tunsigned int e = (x >> 23) & 0xff;\n"
"\t\tif (e < 103)\n"
"\t\t\treturn bits;\n"
"\t\tif (e > 142)\n"
"\t\t{\n"
"\t\t\tbits |= 0x7c00u;\n"
"\t\t\tbits |= e == 255 && (x & 0x007fffffu);\n"
"\t\t\treturn bits;\n"
"\t\t}\n"
"\t\tif (e < 113)\n"
"\t\t{\n"
"\t\t\tm |= 0x0800u;\n"
"\t\t\tbits |= (m >> (114 - e)) + ((m >> (113 - e)) & 1);\n"
"\t\t\treturn bits;\n"
"\t\t}\n"
"\t\tbits |= ((e - 112) << 10) | (m >> 1);\n"
"\t\tbits += m & 1;\n"
"\t\treturn bits;\n"
"\t}\n"
"\n"
"\tinline float HalfToFloat(unsigned short input)\n"
"\t{\n"
"\t\tstatic const auto magic = Math::FloatIntUnion::makeFromInt((127 + (127 - 15)) << 23);\n"
"\t\tstatic const auto was_infnan = Math::FloatIntUnion::makeFromInt((127 + 16) << 23);\n"
"        Math::FloatIntUnion o;\n"
"\t\to.ivalue = (input & 0x7fff) << 13;     // exponent/mantissa bits\n"
"\t\to.fvalue *= magic.fvalue;                 // exponent adjust\n"
"\t\tif (o.fvalue >= was_infnan.fvalue)        // make sure Inf/NaN survive\n"
"\t\t\to.ivalue |= 255 << 23;\n"
"\t\to.ivalue |= (input & 0x8000) << 16;    // sign bit\n"
"\t\treturn o.fvalue;\n"
"\t}\n"
"\n"
"\tclass Random\n"
"\t{\n"
"\tprivate:\n"
"\t\tunsigned int seed;\n"
"\tpublic:\n"
"\t\tRandom(int seed)\n"
"\t\t{\n"
"\t\t\tthis->seed = seed;\n"
"\t\t}\n"
"\t\tint Next() // random between 0 and RandMax (currently 0x7fff)\n"
"\t\t{\n"
"\t\t\treturn ((seed = ((seed << 12) + 150889L) % 714025) & 0x7fff);\n"
"\t\t}\n"
"\t\tint Next(int min, int max) // inclusive min, exclusive max\n"
"\t\t{\n"
"\t\t\tunsigned int a = ((seed = ((seed << 12) + 150889L) % 714025) & 0xFFFF);\n"
"\t\t\tunsigned int b = ((seed = ((seed << 12) + 150889L) % 714025) & 0xFFFF);\n"
"\t\t\tunsigned int r = (a << 16) + b;\n"
"\t\t\treturn min + r % (max - min);\n"
"\t\t}\n"
"\t\tfloat NextFloat()\n"
"\t\t{\n"
"\t\t\treturn ((Next() << 15) + Next()) / ((float)(1 << 30));\n"
"\t\t}\n"
"\t\tfloat NextFloat(float valMin, float valMax)\n"
"\t\t{\n"
"\t\t\treturn valMin + (valMax - valMin) * NextFloat();\n"
"\t\t}\n"
"\t\tstatic int RandMax()\n"
"\t\t{\n"
"\t\t\treturn 0x7fff;\n"
"\t\t}\n"
"\t};\n"
"}\n"
"\n"
"#endif \n"
"\n"
"///////////////////////// ankerl::unordered_dense::{map, set} /////////////////////////\n"
"\n"
"// A fast & densely stored hashmap and hashset based on robin-hood backward shift deletion.\n"
"// Version 4.0.4\n"
"// https://github.com/martinus/unordered_dense\n"
"//\n"
"// Licensed under the MIT License <http://opensource.org/licenses/MIT>.\n"
"// SPDX-License-Identifier: MIT\n"
"// Copyright (c) 2022-2023 Martin Leitner-Ankerl <martin.ankerl@gmail.com>\n"
"//\n"
"// Permission is hereby granted, free of charge, to any person obtaining a copy\n"
"// of this software and associated documentation files (the \"Software\"), to deal\n"
"// in the Software without restriction, including without limitation the rights\n"
"// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n"
"// copies of the Software, and to permit persons to whom the Software is\n"
"// furnished to do so, subject to the following conditions:\n"
"//\n"
"// The above copyright notice and this permission notice shall be included in all\n"
"// copies or substantial portions of the Software.\n"
"//\n"
"// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n"
"// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n"
"// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n"
"// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n"
"// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n"
"// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n"
"// SOFTWARE.\n"
"\n"
"#ifndef ANKERL_UNORDERED_DENSE_H\n"
"#define ANKERL_UNORDERED_DENSE_H\n"
"\n"
"// see https://semver.org/spec/v2.0.0.html\n"
"#define ANKERL_UNORDERED_DENSE_VERSION_MAJOR 4 // NOLINT(cppcoreguidelines-macro-usage) incompatible API changes\n"
"#define ANKERL_UNORDERED_DENSE_VERSION_MINOR 0 // NOLINT(cppcoreguidelines-macro-usage) backwards compatible functionality\n"
"#define ANKERL_UNORDERED_DENSE_VERSION_PATCH 4 // NOLINT(cppcoreguidelines-macro-usage) backwards compatible bug fixes\n"
"\n"
"// API versioning with inline namespace, see https://www.foonathan.net/2018/11/inline-namespaces/\n"
"\n"
"// NOLINTNEXTLINE(cppcoreguidelines-macro-usage)\n"
"#define ANKERL_UNORDERED_DENSE_VERSION_CONCAT1(major, minor, patch) v##major##_##minor##_##patch\n"
"// NOLINTNEXTLINE(cppcoreguidelines-macro-usage)\n"
"#define ANKERL_UNORDERED_DENSE_VERSION_CONCAT(major, minor, patch) ANKERL_UNORDERED_DENSE_VERSION_CONCAT1(major, minor, patch)\n"
"#define ANKERL_UNORDERED_DENSE_NAMESPACE   \\\n"
"    ANKERL_UNORDERED_DENSE_VERSION_CONCAT( \\\n"
"        ANKERL_UNORDERED_DENSE_VERSION_MAJOR, ANKERL_UNORDERED_DENSE_VERSION_MINOR, ANKERL_UNORDERED_DENSE_VERSION_PATCH)\n"
"\n"
"#if defined(_MSVC_LANG)\n"
"#    define ANKERL_UNORDERED_DENSE_CPP_VERSION _MSVC_LANG\n"
"#else\n"
"#    define ANKERL_UNORDERED_DENSE_CPP_VERSION __cplusplus\n"
"#endif\n"
"\n"
"#if defined(__GNUC__)\n"
"// NOLINTNEXTLINE(cppcoreguidelines-macro-usage)\n"
"#    define ANKERL_UNORDERED_DENSE_PACK(decl) decl __attribute__((__packed__))\n"
"#elif defined(_MSC_VER)\n"
"// NOLINTNEXTLINE(cppcoreguidelines-macro-usage)\n"
"#    define ANKERL_UNORDERED_DENSE_PACK(decl) __pragma(pack(push, 1)) decl __pragma(pack(pop))\n"
"#endif\n"
"\n"
"// exceptions\n"
"#if defined(__cpp_exceptions) || defined(__EXCEPTIONS) || defined(_CPPUNWIND)\n"
"#    define ANKERL_UNORDERED_DENSE_HAS_EXCEPTIONS() 1 // NOLINT(cppcoreguidelines-macro-usage)\n"
"#else\n"
"#    define ANKERL_UNORDERED_DENSE_HAS_EXCEPTIONS() 0 // NOLINT(cppcoreguidelines-macro-usage)\n"
"#endif\n"
"#ifdef _MSC_VER\n"
"#    define ANKERL_UNORDERED_DENSE_NOINLINE __declspec(noinline)\n"
"#else\n"
"#    define ANKERL_UNORDERED_DENSE_NOINLINE __attribute__((noinline))\n"
"#endif\n"
"\n"
"#if ANKERL_UNORDERED_DENSE_CPP_VERSION < 201703L\n"
"#    error ankerl::unordered_dense requires C++17 or higher\n"
"#else\n"
"#    include <array>            // for array\n"
"#    include <cstdint>          // for uint64_t, uint32_t, uint8_t, UINT64_C\n"
"#    include <cstring>          // for size_t, memcpy, memset\n"
"#    include <functional>       // for equal_to, hash\n"
"#    include <initializer_list> // for initializer_list\n"
"#    include <iterator>         // for pair, distance\n"
"#    include <limits>           // for numeric_limits\n"
"#    include <memory>           // for allocator, allocator_traits, shared_ptr\n"
"#    include <stdexcept>        // for out_of_range\n"
"#    include <string>           // for basic_string\n"
"#    include <string_view>      // for basic_string_view, hash\n"
"#    include <tuple>            // for forward_as_tuple\n"
"#    include <type_traits>      // for enable_if_t, declval, conditional_t, ena...\n"
"#    include <utility>          // for forward, exchange, pair, as_const, piece...\n"
"#    include <vector>           // for vector\n"
"#    if ANKERL_UNORDERED_DENSE_HAS_EXCEPTIONS() == 0\n"
"#        include <cstdlib> // for abort\n"
"#    endif\n"
"\n"
"#    if defined(__has_include)\n"
"#        if __has_include(<memory_resource>)\n"
"#            define ANKERL_UNORDERED_DENSE_PMR std::pmr // NOLINT(cppcoreguidelines-macro-usage)\n"
"#            include <memory_resource>                  // for polymorphic_allocator\n"
"#        elif __has_include(<experimental/memory_resource>)\n"
"#            define ANKERL_UNORDERED_DENSE_PMR std::experimental::pmr // NOLINT(cppcoreguidelines-macro-usage)\n"
"#            include <experimental/memory_resource>                   // for polymorphic_allocator\n"
"#        endif\n"
"#    endif\n"
"\n"
"#    if defined(_MSC_VER) && defined(_M_X64)\n"
"#        include <intrin.h>\n"
"#        pragma intrinsic(_umul128)\n"
"#    endif\n"
"\n"
"#    if defined(__GNUC__) || defined(__INTEL_COMPILER) || defined(__clang__)\n"
"#        define ANKERL_UNORDERED_DENSE_LIKELY(x) __builtin_expect(x, 1)   // NOLINT(cppcoreguidelines-macro-usage)\n"
"#        define ANKERL_UNORDERED_DENSE_UNLIKELY(x) __builtin_expect(x, 0) // NOLINT(cppcoreguidelines-macro-usage)\n"
"#    else\n"
"#        define ANKERL_UNORDERED_DENSE_LIKELY(x) (x)   // NOLINT(cppcoreguidelines-macro-usage)\n"
"#        define ANKERL_UNORDERED_DENSE_UNLIKELY(x) (x) // NOLINT(cppcoreguidelines-macro-usage)\n"
"#    endif\n"
"\n"
"namespace ankerl::unordered_dense {\n"
"inline namespace ANKERL_UNORDERED_DENSE_NAMESPACE {\n"
"\n"
"namespace detail {\n"
"\n"
"#    if ANKERL_UNORDERED_DENSE_HAS_EXCEPTIONS()\n"
"\n"
"// make sure this is not inlined as it is slow and dramatically enlarges code, thus making other\n"
"// inlinings more difficult. Throws are also generally the slow path.\n"
"[[noreturn]] inline ANKERL_UNORDERED_DENSE_NOINLINE void on_error_key_not_found() {\n"
"    throw std::out_of_range(\"ankerl::unordered_dense::map::at(): key not found\");\n"
"}\n"
"[[noreturn]] inline ANKERL_UNORDERED_DENSE_NOINLINE void on_error_bucket_overflow() {\n"
"    throw std::overflow_error(\"ankerl::unordered_dense: reached max bucket size, cannot increase size\");\n"
"}\n"
"[[noreturn]] inline ANKERL_UNORDERED_DENSE_NOINLINE void on_error_too_many_elements() {\n"
"    throw std::out_of_range(\"ankerl::unordered_dense::map::replace(): too many elements\");\n"
"}\n"
"\n"
"#    else\n"
"\n"
"[[noreturn]] inline void on_error_key_not_found() {\n"
"    abort();\n"
"}\n"
"[[noreturn]] inline void on_error_bucket_overflow() {\n"
"    abort();\n"
"}\n"
"[[noreturn]] inline void on_error_too_many_elements() {\n"
"    abort();\n"
"}\n"
"\n"
"#    endif\n"
"\n"
"} // namespace detail\n"
"\n"
"// hash ///////////////////////////////////////////////////////////////////////\n"
"\n"
"// This is a stripped-down implementation of wyhash: https://github.com/wangyi-fudan/wyhash\n"
"// No big-endian support (because different values on different machines don't matter),\n"
"// hardcodes seed and the secret, reformattes the code, and clang-tidy fixes.\n"
"namespace detail::wyhash {\n"
"\n"
"static inline void mum(uint64_t* a, uint64_t* b) {\n"
"#    if defined(__SIZEOF_INT128__)\n"
"    __uint128_t r = *a;\n"
"    r *= *b;\n"
"    *a = static_cast<uint64_t>(r);\n"
"    *b = static_cast<uint64_t>(r >> 64U);\n"
"#    elif defined(_MSC_VER) && defined(_M_X64)\n"
"    *a = _umul128(*a, *b, b);\n"
"#    else\n"
"    uint64_t ha = *a >> 32U;\n"
"    uint64_t hb = *b >> 32U;\n"
"    uint64_t la = static_cast<uint32_t>(*a);\n"
"    uint64_t lb = static_cast<uint32_t>(*b);\n"
"    uint64_t hi{};\n"
"    uint64_t lo{};\n"
"    uint64_t rh = ha * hb;\n"
"    uint64_t rm0 = ha * lb;\n"
"    uint64_t rm1 = hb * la;\n"
"    uint64_t rl = la * lb;\n"
"    uint64_t t = rl + (rm0 << 32U);\n"
"    auto c = static_cast<uint64_t>(t < rl);\n"
"    lo = t + (rm1 << 32U);\n"
"    c += static_cast<uint64_t>(lo < t);\n"
"    hi = rh + (rm0 >> 32U) + (rm1 >> 32U) + c;\n"
"    *a = lo;\n"
"    *b = hi;\n"
"#    endif\n"
"}\n"
"\n"
"// multiply and xor mix function, aka MUM\n"
"[[nodiscard]] static inline auto mix(uint64_t a, uint64_t b) -> uint64_t {\n"
"    mum(&a, &b);\n"
"    return a ^ b;\n"
"}\n"
"\n"
"// read functions. WARNING: we don't care about endianness, so results are different on big endian!\n"
"[[nodiscard]] static inline auto r8(const uint8_t* p) -> uint64_t {\n"
"    uint64_t v{};\n"
"    std::memcpy(&v, p, 8U);\n"
"    return v;\n"
"}\n"
"\n"
"[[nodiscard]] static inline auto r4(const uint8_t* p) -> uint64_t {\n"
"    uint32_t v{};\n"
"    std::memcpy(&v, p, 4);\n"
"    return v;\n"
"}\n"
"\n"
"// reads 1, 2, or 3 bytes\n"
"[[nodiscard]] static inline auto r3(const uint8_t* p, size_t k) -> uint64_t {\n"
"    return (static_cast<uint64_t>(p[0]) << 16U) | (static_cast<uint64_t>(p[k >> 1U]) << 8U) | p[k - 1];\n"
"}\n"
"\n"
"[[maybe_unused]] [[nodiscard]] static inline auto hash(void const* key, size_t len) -> uint64_t {\n"
"    static constexpr auto secret = std::array{UINT64_C(0xa0761d6478bd642f),\n"
"                                              UINT64_C(0xe7037ed1a0b428db),\n"
"                                              UINT64_C(0x8ebc6af09c88c6e3),\n"
"                                              UINT64_C(0x589965cc75374cc3)};\n"
"\n"
"    auto const* p = static_cast<uint8_t const*>(key);\n"
"    uint64_t seed = secret[0];\n"
"    uint64_t a{};\n"
"    uint64_t b{};\n"
"    if (ANKERL_UNORDERED_DENSE_LIKELY(len <= 16)) {\n"
"        if (ANKERL_UNORDERED_DENSE_LIKELY(len >= 4)) {\n"
"            a = (r4(p) << 32U) | r4(p + ((len >> 3U) << 2U));\n"
"            b = (r4(p + len - 4) << 32U) | r4(p + len - 4 - ((len >> 3U) << 2U));\n"
"        } else if (ANKERL_UNORDERED_DENSE_LIKELY(len > 0)) {\n"
"            a = r3(p, len);\n"
"            b = 0;\n"
"        } else {\n"
"            a = 0;\n"
"            b = 0;\n"
"        }\n"
"    } else {\n"
"        size_t i = len;\n"
"        if (ANKERL_UNORDERED_DENSE_UNLIKELY(i > 48)) {\n"
"            uint64_t see1 = seed;\n"
"            uint64_t see2 = seed;\n"
"            do {\n"
"                seed = mix(r8(p) ^ secret[1], r8(p + 8) ^ seed);\n"
"                see1 = mix(r8(p + 16) ^ secret[2], r8(p + 24) ^ see1);\n"
"                see2 = mix(r8(p + 32) ^ secret[3], r8(p + 40) ^ see2);\n"
"                p += 48;\n"
"                i -= 48;\n"
"            } while (ANKERL_UNORDERED_DENSE_LIKELY(i > 48));\n"
"            seed ^= see1 ^ see2;\n"
"        }\n"
"        while (ANKERL_UNORDERED_DENSE_UNLIKELY(i > 16)) {\n"
"            seed = mix(r8(p) ^ secret[1], r8(p + 8) ^ seed);\n"
"            i -= 16;\n"
"            p += 16;\n"
"        }\n"
"        a = r8(p + i - 16);\n"
"        b = r8(p + i - 8);\n"
"    }\n"
"\n"
"    return mix(secret[1] ^ len, mix(a ^ secret[1], b ^ seed));\n"
"}\n"
"\n"
"[[nodiscard]] static inline auto hash(uint64_t x) -> uint64_t {\n"
"    return detail::wyhash::mix(x, UINT64_C(0x9E3779B97F4A7C15));\n"
"}\n"
"\n"
"} // namespace detail::wyhash\n"
"\n"
"template <typename T, typename Enable = void>\n"
"struct hash {\n"
"    auto operator()(T const& obj) const noexcept(noexcept(std::declval<std::hash<T>>().operator()(std::declval<T const&>())))\n"
"        -> uint64_t {\n"
"        return std::hash<T>{}(obj);\n"
"    }\n"
"};\n"
"\n"
"template <typename CharT>\n"
"struct hash<std::basic_string<CharT>> {\n"
"    using is_avalanching = void;\n"
"    auto operator()(std::basic_string<CharT> const& str) const noexcept -> uint64_t {\n"
"        return detail::wyhash::hash(str.data(), sizeof(CharT) * str.size());\n"
"    }\n"
"};\n"
"\n"
"template <typename CharT>\n"
"struct hash<std::basic_string_view<CharT>> {\n"
"    using is_avalanching = void;\n"
"    auto operator()(std::basic_string_view<CharT> const& sv) const noexcept -> uint64_t {\n"
"        return detail::wyhash::hash(sv.data(), sizeof(CharT) * sv.size());\n"
"    }\n"
"};\n"
"\n"
"template <class T>\n"
"struct hash<T*> {\n"
"    using is_avalanching = void;\n"
"    auto operator()(T* ptr) const noexcept -> uint64_t {\n"
"        // NOLINTNEXTLINE(cppcoreguidelines-pro-type-reinterpret-cast)\n"
"        return detail::wyhash::hash(reinterpret_cast<uintptr_t>(ptr));\n"
"    }\n"
"};\n"
"\n"
"template <class T>\n"
"struct hash<std::unique_ptr<T>> {\n"
"    using is_avalanching = void;\n"
"    auto operator()(std::unique_ptr<T> const& ptr) const noexcept -> uint64_t {\n"
"        // NOLINTNEXTLINE(cppcoreguidelines-pro-type-reinterpret-cast)\n"
"        return detail::wyhash::hash(reinterpret_cast<uintptr_t>(ptr.get()));\n"
"    }\n"
"};\n"
"\n"
"template <class T>\n"
"struct hash<std::shared_ptr<T>> {\n"
"    using is_avalanching = void;\n"
"    auto operator()(std::shared_ptr<T> const& ptr) const noexcept -> uint64_t {\n"
"        // NOLINTNEXTLINE(cppcoreguidelines-pro-type-reinterpret-cast)\n"
"        return detail::wyhash::hash(reinterpret_cast<uintptr_t>(ptr.get()));\n"
"    }\n"
"};\n"
"\n"
"template <typename Enum>\n"
"struct hash<Enum, typename std::enable_if<std::is_enum<Enum>::value>::type> {\n"
"    using is_avalanching = void;\n"
"    auto operator()(Enum e) const noexcept -> uint64_t {\n"
"        using underlying = typename std::underlying_type_t<Enum>;\n"
"        return detail::wyhash::hash(static_cast<underlying>(e));\n"
"    }\n"
"};\n"
"\n"
"// NOLINTNEXTLINE(cppcoreguidelines-macro-usage)\n"
"#    define ANKERL_UNORDERED_DENSE_HASH_STATICCAST(T)                    \\\n"
"        template <>                                                      \\\n"
"        struct hash<T> {                                                 \\\n"
"            using is_avalanching = void;                                 \\\n"
"            auto operator()(T const& obj) const noexcept -> uint64_t {   \\\n"
"                return detail::wyhash::hash(static_cast<uint64_t>(obj)); \\\n"
"            }                                                            \\\n"
"        }\n"
"\n"
"#    if defined(__GNUC__) && !defined(__clang__)\n"
"#        pragma GCC diagnostic push\n"
"#        pragma GCC diagnostic ignored \"-Wuseless-cast\"\n"
"#    endif\n"
"// see https://en.cppreference.com/w/cpp/utility/hash\n"
"ANKERL_UNORDERED_DENSE_HASH_STATICCAST(bool);\n"
"ANKERL_UNORDERED_DENSE_HASH_STATICCAST(char);\n"
"ANKERL_UNORDERED_DENSE_HASH_STATICCAST(signed char);\n"
"ANKERL_UNORDERED_DENSE_HASH_STATICCAST(unsigned char);\n"
"#    if ANKERL_UNORDERED_DENSE_CPP_VERSION >= 202002L\n"
"ANKERL_UNORDERED_DENSE_HASH_STATICCAST(char8_t);\n"
"#    endif\n"
"ANKERL_UNORDERED_DENSE_HASH_STATICCAST(char16_t);\n"
"ANKERL_UNORDERED_DENSE_HASH_STATICCAST(char32_t);\n"
"ANKERL_UNORDERED_DENSE_HASH_STATICCAST(wchar_t);\n"
"ANKERL_UNORDERED_DENSE_HASH_STATICCAST(short);\n"
"ANKERL_UNORDERED_DENSE_HASH_STATICCAST(unsigned short);\n"
"ANKERL_UNORDERED_DENSE_HASH_STATICCAST(int);\n"
"ANKERL_UNORDERED_DENSE_HASH_STATICCAST(unsigned int);\n"
"ANKERL_UNORDERED_DENSE_HASH_STATICCAST(long);\n"
"ANKERL_UNORDERED_DENSE_HASH_STATICCAST(long long);\n"
"ANKERL_UNORDERED_DENSE_HASH_STATICCAST(unsigned long);\n"
"ANKERL_UNORDERED_DENSE_HASH_STATICCAST(unsigned long long);\n"
"\n"
"#    if defined(__GNUC__) && !defined(__clang__)\n"
"#        pragma GCC diagnostic pop\n"
"#    endif\n"
"\n"
;
sb << 
"// bucket_type //////////////////////////////////////////////////////////\n"
"\n"
"namespace bucket_type {\n"
"\n"
"struct standard {\n"
"    static constexpr uint32_t dist_inc = 1U << 8U;             // skip 1 byte fingerprint\n"
"    static constexpr uint32_t fingerprint_mask = dist_inc - 1; // mask for 1 byte of fingerprint\n"
"\n"
"    uint32_t m_dist_and_fingerprint; // upper 3 byte: distance to original bucket. lower byte: fingerprint from hash\n"
"    uint32_t m_value_idx;            // index into the m_values vector.\n"
"};\n"
"\n"
"ANKERL_UNORDERED_DENSE_PACK(struct big {\n"
"    static constexpr uint32_t dist_inc = 1U << 8U;             // skip 1 byte fingerprint\n"
"    static constexpr uint32_t fingerprint_mask = dist_inc - 1; // mask for 1 byte of fingerprint\n"
"\n"
"    uint32_t m_dist_and_fingerprint; // upper 3 byte: distance to original bucket. lower byte: fingerprint from hash\n"
"    size_t m_value_idx;              // index into the m_values vector.\n"
"});\n"
"\n"
"} // namespace bucket_type\n"
"\n"
"namespace detail {\n"
"\n"
"struct nonesuch {};\n"
"\n"
"template <class Default, class AlwaysVoid, template <class...> class Op, class... Args>\n"
"struct detector {\n"
"    using value_t = std::false_type;\n"
"    using type = Default;\n"
"};\n"
"\n"
"template <class Default, template <class...> class Op, class... Args>\n"
"struct detector<Default, std::void_t<Op<Args...>>, Op, Args...> {\n"
"    using value_t = std::true_type;\n"
"    using type = Op<Args...>;\n"
"};\n"
"\n"
"template <template <class...> class Op, class... Args>\n"
"using is_detected = typename detail::detector<detail::nonesuch, void, Op, Args...>::value_t;\n"
"\n"
"template <template <class...> class Op, class... Args>\n"
"constexpr bool is_detected_v = is_detected<Op, Args...>::value;\n"
"\n"
"template <typename T>\n"
"using detect_avalanching = typename T::is_avalanching;\n"
"\n"
"template <typename T>\n"
"using detect_is_transparent = typename T::is_transparent;\n"
"\n"
"template <typename T>\n"
"using detect_iterator = typename T::iterator;\n"
"\n"
"template <typename T>\n"
"using detect_reserve = decltype(std::declval<T&>().reserve(size_t{}));\n"
"\n"
"// enable_if helpers\n"
"\n"
"template <typename Mapped>\n"
"constexpr bool is_map_v = !std::is_void_v<Mapped>;\n"
"\n"
"// clang-format off\n"
"template <typename Hash, typename KeyEqual>\n"
"constexpr bool is_transparent_v = is_detected_v<detect_is_transparent, Hash> && is_detected_v<detect_is_transparent, KeyEqual>;\n"
"// clang-format on\n"
"\n"
"template <typename From, typename To1, typename To2>\n"
"constexpr bool is_neither_convertible_v = !std::is_convertible_v<From, To1> && !std::is_convertible_v<From, To2>;\n"
"\n"
"template <typename T>\n"
"constexpr bool has_reserve = is_detected_v<detect_reserve, T>;\n"
"\n"
"// base type for map has mapped_type\n"
"template <class T>\n"
"struct base_table_type_map {\n"
"    using mapped_type = T;\n"
"};\n"
"\n"
"// base type for set doesn't have mapped_type\n"
"struct base_table_type_set {};\n"
"\n"
"} // namespace detail\n"
"\n"
"// Very much like std::deque, but faster for indexing (in most cases). As of now this doesn't implement the full std::vector\n"
"// API, but merely what's necessary to work as an underlying container for ankerl::unordered_dense::{map, set}.\n"
"// It allocates blocks of equal size and puts them into the m_blocks vector. That means it can grow simply by adding a new\n"
"// block to the back of m_blocks, and doesn't double its size like an std::vector. The disadvantage is that memory is not\n"
"// linear and thus there is one more indirection necessary for indexing.\n"
"template <typename T, typename Allocator = std::allocator<T>, size_t MaxSegmentSizeBytes = 4096>\n"
"class segmented_vector {\n"
"    template <bool IsConst>\n"
"    class iter_t;\n"
"\n"
"public:\n"
"    using allocator_type = Allocator;\n"
"    using pointer = typename std::allocator_traits<allocator_type>::pointer;\n"
"    using const_pointer = typename std::allocator_traits<allocator_type>::const_pointer;\n"
"    using difference_type = typename std::allocator_traits<allocator_type>::difference_type;\n"
"    using value_type = T;\n"
"    using size_type = std::size_t;\n"
"    using reference = T&;\n"
"    using const_reference = T const&;\n"
"    using iterator = iter_t<false>;\n"
"    using const_iterator = iter_t<true>;\n"
"\n"
"private:\n"
"    using vec_alloc = typename std::allocator_traits<Allocator>::template rebind_alloc<pointer>;\n"
"    std::vector<pointer, vec_alloc> m_blocks{};\n"
"    size_t m_size{};\n"
"\n"
"    // Calculates the maximum number for x in  (s << x) <= max_val\n"
"    static constexpr auto num_bits_closest(size_t max_val, size_t s) -> size_t {\n"
"        auto f = size_t{0};\n"
"        while (s << (f + 1) <= max_val) {\n"
"            ++f;\n"
"        }\n"
"        return f;\n"
"    }\n"
"\n"
"    using self_t = segmented_vector<T, Allocator, MaxSegmentSizeBytes>;\n"
"    static constexpr auto num_bits = num_bits_closest(MaxSegmentSizeBytes, sizeof(T));\n"
"    static constexpr auto num_elements_in_block = 1U << num_bits;\n"
"    static constexpr auto mask = num_elements_in_block - 1U;\n"
"\n"
"    /**\n"
"     * Iterator class doubles as const_iterator and iterator\n"
"     */\n"
"    template <bool IsConst>\n"
"    class iter_t {\n"
"        using ptr_t = typename std::conditional_t<IsConst, segmented_vector::const_pointer const*, segmented_vector::pointer*>;\n"
"        ptr_t m_data{};\n"
"        size_t m_idx{};\n"
"\n"
"        template <bool B>\n"
"        friend class iter_t;\n"
"\n"
"    public:\n"
"        using difference_type = segmented_vector::difference_type;\n"
"        using value_type = T;\n"
"        using reference = typename std::conditional_t<IsConst, value_type const&, value_type&>;\n"
"        using pointer = typename std::conditional_t<IsConst, segmented_vector::const_pointer, segmented_vector::pointer>;\n"
"        using iterator_category = std::forward_iterator_tag;\n"
"\n"
"        iter_t() noexcept = default;\n"
"\n"
"        template <bool OtherIsConst, typename = typename std::enable_if<IsConst && !OtherIsConst>::type>\n"
"        // NOLINTNEXTLINE(google-explicit-constructor,hicpp-explicit-conversions)\n"
"        constexpr iter_t(iter_t<OtherIsConst> const& other) noexcept\n"
"            : m_data(other.m_data)\n"
"            , m_idx(other.m_idx) {}\n"
"\n"
"        constexpr iter_t(ptr_t data, size_t idx) noexcept\n"
"            : m_data(data)\n"
"            , m_idx(idx) {}\n"
"\n"
"        template <bool OtherIsConst, typename = typename std::enable_if<IsConst && !OtherIsConst>::type>\n"
"        constexpr auto operator=(iter_t<OtherIsConst> const& other) noexcept -> iter_t& {\n"
"            m_data = other.m_data;\n"
"            m_idx = other.m_idx;\n"
"            return *this;\n"
"        }\n"
"\n"
"        constexpr auto operator++() noexcept -> iter_t& {\n"
"            ++m_idx;\n"
"            return *this;\n"
"        }\n"
"\n"
"        constexpr auto operator+(difference_type diff) noexcept -> iter_t {\n"
"            return {m_data, static_cast<size_t>(static_cast<difference_type>(m_idx) + diff)};\n"
"        }\n"
"\n"
"        template <bool OtherIsConst>\n"
"        constexpr auto operator-(iter_t<OtherIsConst> const& other) noexcept -> difference_type {\n"
"            return static_cast<difference_type>(m_idx) - static_cast<difference_type>(other.m_idx);\n"
"        }\n"
"\n"
"        constexpr auto operator*() const noexcept -> reference {\n"
"            return m_data[m_idx >> num_bits][m_idx & mask];\n"
"        }\n"
"\n"
"        constexpr auto operator->() const noexcept -> pointer {\n"
"            return &m_data[m_idx >> num_bits][m_idx & mask];\n"
"        }\n"
"\n"
"        template <bool O>\n"
"        constexpr auto operator==(iter_t<O> const& o) const noexcept -> bool {\n"
"            return m_idx == o.m_idx;\n"
"        }\n"
"\n"
"        template <bool O>\n"
"        constexpr auto operator!=(iter_t<O> const& o) const noexcept -> bool {\n"
"            return !(*this == o);\n"
"        }\n"
"    };\n"
"\n"
"    // slow path: need to allocate a new segment every once in a while\n"
"    void increase_capacity() {\n"
"        auto ba = Allocator(m_blocks.get_allocator());\n"
"        pointer block = std::allocator_traits<Allocator>::allocate(ba, num_elements_in_block);\n"
"        m_blocks.push_back(block);\n"
"    }\n"
"\n"
"    // Moves everything from other\n"
"    void append_everything_from(segmented_vector&& other) {\n"
"        reserve(size() + other.size());\n"
"        for (auto&& o : other) {\n"
"            emplace_back(std::move(o));\n"
"        }\n"
"    }\n"
"\n"
"    // Copies everything from other\n"
"    void append_everything_from(segmented_vector const& other) {\n"
"        reserve(size() + other.size());\n"
"        for (auto const& o : other) {\n"
"            emplace_back(o);\n"
"        }\n"
"    }\n"
"\n"
"    void dealloc() {\n"
"        auto ba = Allocator(m_blocks.get_allocator());\n"
"        for (auto ptr : m_blocks) {\n"
"            std::allocator_traits<Allocator>::deallocate(ba, ptr, num_elements_in_block);\n"
"        }\n"
"    }\n"
"\n"
"    [[nodiscard]] static constexpr auto calc_num_blocks_for_capacity(size_t capacity) {\n"
"        return (capacity + num_elements_in_block - 1U) / num_elements_in_block;\n"
"    }\n"
"\n"
"public:\n"
"    segmented_vector() = default;\n"
"\n"
"    // NOLINTNEXTLINE(google-explicit-constructor,hicpp-explicit-conversions)\n"
"    segmented_vector(Allocator alloc)\n"
"        : m_blocks(vec_alloc(alloc)) {}\n"
"\n"
"    segmented_vector(segmented_vector&& other, Allocator alloc)\n"
"        : segmented_vector(alloc) {\n"
"        *this = std::move(other);\n"
"    }\n"
"\n"
"    segmented_vector(segmented_vector const& other, Allocator alloc)\n"
"        : m_blocks(vec_alloc(alloc)) {\n"
"        append_everything_from(other);\n"
"    }\n"
"\n"
"    segmented_vector(segmented_vector&& other) noexcept\n"
"        : segmented_vector(std::move(other), get_allocator()) {}\n"
"\n"
"    segmented_vector(segmented_vector const& other) {\n"
"        append_everything_from(other);\n"
"    }\n"
"\n"
"    auto operator=(segmented_vector const& other) -> segmented_vector& {\n"
"        if (this == &other) {\n"
"            return *this;\n"
"        }\n"
"        clear();\n"
"        append_everything_from(other);\n"
"        return *this;\n"
"    }\n"
"\n"
"    auto operator=(segmented_vector&& other) noexcept -> segmented_vector& {\n"
"        clear();\n"
"        dealloc();\n"
"        if (other.get_allocator() == get_allocator()) {\n"
"            m_blocks = std::move(other.m_blocks);\n"
"            m_size = std::exchange(other.m_size, {});\n"
"        } else {\n"
"            // make sure to construct with other's allocator!\n"
"            m_blocks = std::vector<pointer, vec_alloc>(vec_alloc(other.get_allocator()));\n"
"            append_everything_from(std::move(other));\n"
"        }\n"
"        return *this;\n"
"    }\n"
"\n"
"    ~segmented_vector() {\n"
"        clear();\n"
"        dealloc();\n"
"    }\n"
"\n"
"    [[nodiscard]] constexpr auto size() const -> size_t {\n"
"        return m_size;\n"
"    }\n"
"\n"
"    [[nodiscard]] constexpr auto capacity() const -> size_t {\n"
"        return m_blocks.size() * num_elements_in_block;\n"
"    }\n"
"\n"
"    // Indexing is highly performance critical\n"
"    [[nodiscard]] constexpr auto operator[](size_t i) const noexcept -> T const& {\n"
"        return m_blocks[i >> num_bits][i & mask];\n"
"    }\n"
"\n"
"    [[nodiscard]] constexpr auto operator[](size_t i) noexcept -> T& {\n"
"        return m_blocks[i >> num_bits][i & mask];\n"
"    }\n"
"\n"
"    [[nodiscard]] constexpr auto begin() -> iterator {\n"
"        return {m_blocks.data(), 0U};\n"
"    }\n"
"    [[nodiscard]] constexpr auto begin() const -> const_iterator {\n"
"        return {m_blocks.data(), 0U};\n"
"    }\n"
"    [[nodiscard]] constexpr auto cbegin() const -> const_iterator {\n"
"        return {m_blocks.data(), 0U};\n"
"    }\n"
"\n"
"    [[nodiscard]] constexpr auto end() -> iterator {\n"
"        return {m_blocks.data(), m_size};\n"
"    }\n"
"    [[nodiscard]] constexpr auto end() const -> const_iterator {\n"
"        return {m_blocks.data(), m_size};\n"
"    }\n"
"    [[nodiscard]] constexpr auto cend() const -> const_iterator {\n"
"        return {m_blocks.data(), m_size};\n"
"    }\n"
"\n"
"    [[nodiscard]] constexpr auto back() -> reference {\n"
"        return operator[](m_size - 1);\n"
"    }\n"
"    [[nodiscard]] constexpr auto back() const -> const_reference {\n"
"        return operator[](m_size - 1);\n"
"    }\n"
"\n"
"    void pop_back() {\n"
"        back().~T();\n"
"        --m_size;\n"
"    }\n"
"\n"
"    [[nodiscard]] auto empty() const {\n"
"        return 0 == m_size;\n"
"    }\n"
"\n"
"    void reserve(size_t new_capacity) {\n"
"        m_blocks.reserve(calc_num_blocks_for_capacity(new_capacity));\n"
"        while (new_capacity > capacity()) {\n"
"            increase_capacity();\n"
"        }\n"
"    }\n"
"\n"
"    [[nodiscard]] auto get_allocator() const -> allocator_type {\n"
"        return allocator_type{m_blocks.get_allocator()};\n"
"    }\n"
"\n"
"    template <class... Args>\n"
"    auto emplace_back(Args&&... args) -> reference {\n"
"        if (m_size == capacity()) {\n"
"            increase_capacity();\n"
"        }\n"
"        auto* ptr = static_cast<void*>(&operator[](m_size));\n"
"        auto& ref = *new (ptr) T(std::forward<Args>(args)...);\n"
"        ++m_size;\n"
"        return ref;\n"
"    }\n"
"\n"
"    void clear() {\n"
"        if constexpr (!std::is_trivially_destructible_v<T>) {\n"
"            for (size_t i = 0, s = size(); i < s; ++i) {\n"
"                operator[](i).~T();\n"
"            }\n"
"        }\n"
"        m_size = 0;\n"
"    }\n"
"\n"
"    void shrink_to_fit() {\n"
"        auto ba = Allocator(m_blocks.get_allocator());\n"
"        auto num_blocks_required = calc_num_blocks_for_capacity(m_size);\n"
"        while (m_blocks.size() > num_blocks_required) {\n"
"            std::allocator_traits<Allocator>::deallocate(ba, m_blocks.back(), num_elements_in_block);\n"
"            m_blocks.pop_back();\n"
"        }\n"
"        m_blocks.shrink_to_fit();\n"
"    }\n"
"};\n"
"\n"
"namespace detail {\n"
"\n"
"// This is it, the table. Doubles as map and set, and uses `void` for T when its used as a set.\n"
"template <class Key,\n"
"          class T, // when void, treat it as a set.\n"
"          class Hash,\n"
"          class KeyEqual,\n"
"          class AllocatorOrContainer,\n"
"          class Bucket,\n"
"          bool IsSegmented>\n"
"class table : public std::conditional_t<is_map_v<T>, base_table_type_map<T>, base_table_type_set> {\n"
"    using underlying_value_type = typename std::conditional_t<is_map_v<T>, std::pair<Key, T>, Key>;\n"
"    using underlying_container_type = std::conditional_t<IsSegmented,\n"
"                                                         segmented_vector<underlying_value_type, AllocatorOrContainer>,\n"
"                                                         std::vector<underlying_value_type, AllocatorOrContainer>>;\n"
"\n"
"public:\n"
"    using value_container_type = std::\n"
"        conditional_t<is_detected_v<detect_iterator, AllocatorOrContainer>, AllocatorOrContainer, underlying_container_type>;\n"
"\n"
"private:\n"
"    using bucket_alloc =\n"
"        typename std::allocator_traits<typename value_container_type::allocator_type>::template rebind_alloc<Bucket>;\n"
"    using bucket_alloc_traits = std::allocator_traits<bucket_alloc>;\n"
"\n"
"    static constexpr uint8_t initial_shifts = 64 - 3; // 2^(64-m_shift) number of buckets\n"
"    static constexpr float default_max_load_factor = 0.8F;\n"
"\n"
"public:\n"
"    using key_type = Key;\n"
"    using value_type = typename value_container_type::value_type;\n"
"    using size_type = typename value_container_type::size_type;\n"
"    using difference_type = typename value_container_type::difference_type;\n"
"    using hasher = Hash;\n"
"    using key_equal = KeyEqual;\n"
"    using allocator_type = typename value_container_type::allocator_type;\n"
"    using reference = typename value_container_type::reference;\n"
"    using const_reference = typename value_container_type::const_reference;\n"
"    using pointer = typename value_container_type::pointer;\n"
"    using const_pointer = typename value_container_type::const_pointer;\n"
"    using const_iterator = typename value_container_type::const_iterator;\n"
"    using iterator = std::conditional_t<is_map_v<T>, typename value_container_type::iterator, const_iterator>;\n"
"    using bucket_type = Bucket;\n"
"\n"
"private:\n"
"    using value_idx_type = decltype(Bucket::m_value_idx);\n"
"    using dist_and_fingerprint_type = decltype(Bucket::m_dist_and_fingerprint);\n"
"\n"
"    static_assert(std::is_trivially_destructible_v<Bucket>, \"assert there's no need to call destructor / std::destroy\");\n"
"    static_assert(std::is_trivially_copyable_v<Bucket>, \"assert we can just memset / memcpy\");\n"
"\n"
"    value_container_type m_values{}; // Contains all the key-value pairs in one densely stored container. No holes.\n"
"    using bucket_pointer = typename std::allocator_traits<bucket_alloc>::pointer;\n"
"    bucket_pointer m_buckets{};\n"
"    size_t m_num_buckets = 0;\n"
"    size_t m_max_bucket_capacity = 0;\n"
"    float m_max_load_factor = default_max_load_factor;\n"
"    Hash m_hash{};\n"
"    KeyEqual m_equal{};\n"
"    uint8_t m_shifts = initial_shifts;\n"
"\n"
"    [[nodiscard]] auto next(value_idx_type bucket_idx) const -> value_idx_type {\n"
"        return ANKERL_UNORDERED_DENSE_UNLIKELY(bucket_idx + 1U == m_num_buckets)\n"
"                   ? 0\n"
"                   : static_cast<value_idx_type>(bucket_idx + 1U);\n"
"    }\n"
"\n"
"    // Helper to access bucket through pointer types\n"
"    [[nodiscard]] static constexpr auto at(bucket_pointer bucket_ptr, size_t offset) -> Bucket& {\n"
"        return *(bucket_ptr + static_cast<typename std::allocator_traits<bucket_alloc>::difference_type>(offset));\n"
"    }\n"
"\n"
"    // use the dist_inc and dist_dec functions so that uint16_t types work without warning\n"
"    [[nodiscard]] static constexpr auto dist_inc(dist_and_fingerprint_type x) -> dist_and_fingerprint_type {\n"
"        return static_cast<dist_and_fingerprint_type>(x + Bucket::dist_inc);\n"
"    }\n"
"\n"
"    [[nodiscard]] static constexpr auto dist_dec(dist_and_fingerprint_type x) -> dist_and_fingerprint_type {\n"
;
sb << 
"        return static_cast<dist_and_fingerprint_type>(x - Bucket::dist_inc);\n"
"    }\n"
"\n"
"    // The goal of mixed_hash is to always produce a high quality 64bit hash.\n"
"    template <typename K>\n"
"    [[nodiscard]] constexpr auto mixed_hash(K const& key) const -> uint64_t {\n"
"        if constexpr (is_detected_v<detect_avalanching, Hash>) {\n"
"            // we know that the hash is good because is_avalanching.\n"
"            if constexpr (sizeof(decltype(m_hash(key))) < sizeof(uint64_t)) {\n"
"                // 32bit hash and is_avalanching => multiply with a constant to avalanche bits upwards\n"
"                return m_hash(key) * UINT64_C(0x9ddfea08eb382d69);\n"
"            } else {\n"
"                // 64bit and is_avalanching => only use the hash itself.\n"
"                return m_hash(key);\n"
"            }\n"
"        } else {\n"
"            // not is_avalanching => apply wyhash\n"
"            return wyhash::hash(m_hash(key));\n"
"        }\n"
"    }\n"
"\n"
"    [[nodiscard]] constexpr auto dist_and_fingerprint_from_hash(uint64_t hash) const -> dist_and_fingerprint_type {\n"
"        return Bucket::dist_inc | (static_cast<dist_and_fingerprint_type>(hash) & Bucket::fingerprint_mask);\n"
"    }\n"
"\n"
"    [[nodiscard]] constexpr auto bucket_idx_from_hash(uint64_t hash) const -> value_idx_type {\n"
"        return static_cast<value_idx_type>(hash >> m_shifts);\n"
"    }\n"
"\n"
"    [[nodiscard]] static constexpr auto get_key(value_type const& vt) -> key_type const& {\n"
"        if constexpr (is_map_v<T>) {\n"
"            return vt.first;\n"
"        } else {\n"
"            return vt;\n"
"        }\n"
"    }\n"
"\n"
"    template <typename K>\n"
"    [[nodiscard]] auto next_while_less(K const& key) const -> Bucket {\n"
"        auto hash = mixed_hash(key);\n"
"        auto dist_and_fingerprint = dist_and_fingerprint_from_hash(hash);\n"
"        auto bucket_idx = bucket_idx_from_hash(hash);\n"
"\n"
"        while (dist_and_fingerprint < at(m_buckets, bucket_idx).m_dist_and_fingerprint) {\n"
"            dist_and_fingerprint = dist_inc(dist_and_fingerprint);\n"
"            bucket_idx = next(bucket_idx);\n"
"        }\n"
"        return {dist_and_fingerprint, bucket_idx};\n"
"    }\n"
"\n"
"    void place_and_shift_up(Bucket bucket, value_idx_type place) {\n"
"        while (0 != at(m_buckets, place).m_dist_and_fingerprint) {\n"
"            bucket = std::exchange(at(m_buckets, place), bucket);\n"
"            bucket.m_dist_and_fingerprint = dist_inc(bucket.m_dist_and_fingerprint);\n"
"            place = next(place);\n"
"        }\n"
"        at(m_buckets, place) = bucket;\n"
"    }\n"
"\n"
"    [[nodiscard]] static constexpr auto calc_num_buckets(uint8_t shifts) -> size_t {\n"
"        return (std::min)(max_bucket_count(), size_t{1} << (64U - shifts));\n"
"    }\n"
"\n"
"    [[nodiscard]] constexpr auto calc_shifts_for_size(size_t s) const -> uint8_t {\n"
"        auto shifts = initial_shifts;\n"
"        while (shifts > 0 && static_cast<size_t>(static_cast<float>(calc_num_buckets(shifts)) * max_load_factor()) < s) {\n"
"            --shifts;\n"
"        }\n"
"        return shifts;\n"
"    }\n"
"\n"
"    // assumes m_values has data, m_buckets=m_buckets_end=nullptr, m_shifts is INITIAL_SHIFTS\n"
"    void copy_buckets(table const& other) {\n"
"        if (!empty()) {\n"
"            m_shifts = other.m_shifts;\n"
"            allocate_buckets_from_shift();\n"
"            std::memcpy(m_buckets, other.m_buckets, sizeof(Bucket) * bucket_count());\n"
"        }\n"
"    }\n"
"\n"
"    /**\n"
"     * True when no element can be added any more without increasing the size\n"
"     */\n"
"    [[nodiscard]] auto is_full() const -> bool {\n"
"        return size() >= m_max_bucket_capacity;\n"
"    }\n"
"\n"
"    void deallocate_buckets() {\n"
"        auto ba = bucket_alloc(m_values.get_allocator());\n"
"        if (nullptr != m_buckets) {\n"
"            bucket_alloc_traits::deallocate(ba, m_buckets, bucket_count());\n"
"            m_buckets = nullptr;\n"
"        }\n"
"        m_num_buckets = 0;\n"
"        m_max_bucket_capacity = 0;\n"
"    }\n"
"\n"
"    void allocate_buckets_from_shift() {\n"
"        auto ba = bucket_alloc(m_values.get_allocator());\n"
"        m_num_buckets = calc_num_buckets(m_shifts);\n"
"        m_buckets = bucket_alloc_traits::allocate(ba, m_num_buckets);\n"
"        if (m_num_buckets == max_bucket_count()) {\n"
"            // reached the maximum, make sure we can use each bucket\n"
"            m_max_bucket_capacity = max_bucket_count();\n"
"        } else {\n"
"            m_max_bucket_capacity = static_cast<value_idx_type>(static_cast<float>(m_num_buckets) * max_load_factor());\n"
"        }\n"
"    }\n"
"\n"
"    void clear_buckets() {\n"
"        if (m_buckets != nullptr) {\n"
"            std::memset(&*m_buckets, 0, sizeof(Bucket) * bucket_count());\n"
"        }\n"
"    }\n"
"\n"
"    void clear_and_fill_buckets_from_values() {\n"
"        clear_buckets();\n"
"        for (value_idx_type value_idx = 0, end_idx = static_cast<value_idx_type>(m_values.size()); value_idx < end_idx;\n"
"             ++value_idx) {\n"
"            auto const& key = get_key(m_values[value_idx]);\n"
"            auto [dist_and_fingerprint, bucket] = next_while_less(key);\n"
"\n"
"            // we know for certain that key has not yet been inserted, so no need to check it.\n"
"            place_and_shift_up({dist_and_fingerprint, value_idx}, bucket);\n"
"        }\n"
"    }\n"
"\n"
"    void increase_size() {\n"
"        if (ANKERL_UNORDERED_DENSE_UNLIKELY(m_max_bucket_capacity == max_bucket_count())) {\n"
"            on_error_bucket_overflow();\n"
"        }\n"
"        --m_shifts;\n"
"        deallocate_buckets();\n"
"        allocate_buckets_from_shift();\n"
"        clear_and_fill_buckets_from_values();\n"
"    }\n"
"\n"
"    void do_erase(value_idx_type bucket_idx) {\n"
"        auto const value_idx_to_remove = at(m_buckets, bucket_idx).m_value_idx;\n"
"\n"
"        // shift down until either empty or an element with correct spot is found\n"
"        auto next_bucket_idx = next(bucket_idx);\n"
"        while (at(m_buckets, next_bucket_idx).m_dist_and_fingerprint >= Bucket::dist_inc * 2) {\n"
"            at(m_buckets, bucket_idx) = {dist_dec(at(m_buckets, next_bucket_idx).m_dist_and_fingerprint),\n"
"                                         at(m_buckets, next_bucket_idx).m_value_idx};\n"
"            bucket_idx = std::exchange(next_bucket_idx, next(next_bucket_idx));\n"
"        }\n"
"        at(m_buckets, bucket_idx) = {};\n"
"\n"
"        // update m_values\n"
"        if (value_idx_to_remove != m_values.size() - 1) {\n"
"            // no luck, we'll have to replace the value with the last one and update the index accordingly\n"
"            auto& val = m_values[value_idx_to_remove];\n"
"            val = std::move(m_values.back());\n"
"\n"
"            // update the values_idx of the moved entry. No need to play the info game, just look until we find the values_idx\n"
"            auto mh = mixed_hash(get_key(val));\n"
"            bucket_idx = bucket_idx_from_hash(mh);\n"
"\n"
"            auto const values_idx_back = static_cast<value_idx_type>(m_values.size() - 1);\n"
"            while (values_idx_back != at(m_buckets, bucket_idx).m_value_idx) {\n"
"                bucket_idx = next(bucket_idx);\n"
"            }\n"
"            at(m_buckets, bucket_idx).m_value_idx = value_idx_to_remove;\n"
"        }\n"
"        m_values.pop_back();\n"
"    }\n"
"\n"
"    template <typename K>\n"
"    auto do_erase_key(K&& key) -> size_t {\n"
"        if (empty()) {\n"
"            return 0;\n"
"        }\n"
"\n"
"        auto [dist_and_fingerprint, bucket_idx] = next_while_less(key);\n"
"\n"
"        while (dist_and_fingerprint == at(m_buckets, bucket_idx).m_dist_and_fingerprint &&\n"
"               !m_equal(key, get_key(m_values[at(m_buckets, bucket_idx).m_value_idx]))) {\n"
"            dist_and_fingerprint = dist_inc(dist_and_fingerprint);\n"
"            bucket_idx = next(bucket_idx);\n"
"        }\n"
"\n"
"        if (dist_and_fingerprint != at(m_buckets, bucket_idx).m_dist_and_fingerprint) {\n"
"            return 0;\n"
"        }\n"
"        do_erase(bucket_idx);\n"
"        return 1;\n"
"    }\n"
"\n"
"    template <class K, class M>\n"
"    auto do_insert_or_assign(K&& key, M&& mapped) -> std::pair<iterator, bool> {\n"
"        auto it_isinserted = try_emplace(std::forward<K>(key), std::forward<M>(mapped));\n"
"        if (!it_isinserted.second) {\n"
"            it_isinserted.first->second = std::forward<M>(mapped);\n"
"        }\n"
"        return it_isinserted;\n"
"    }\n"
"\n"
"    template <typename K, typename... Args>\n"
"    auto do_place_element(dist_and_fingerprint_type dist_and_fingerprint, value_idx_type bucket_idx, K&& key, Args&&... args)\n"
"        -> std::pair<iterator, bool> {\n"
"\n"
"        // emplace the new value. If that throws an exception, no harm done; index is still in a valid state\n"
"        m_values.emplace_back(std::piecewise_construct,\n"
"                              std::forward_as_tuple(std::forward<K>(key)),\n"
"                              std::forward_as_tuple(std::forward<Args>(args)...));\n"
"\n"
"        // place element and shift up until we find an empty spot\n"
"        auto value_idx = static_cast<value_idx_type>(m_values.size() - 1);\n"
"        place_and_shift_up({dist_and_fingerprint, value_idx}, bucket_idx);\n"
"        return {begin() + static_cast<difference_type>(value_idx), true};\n"
"    }\n"
"\n"
"    template <typename K, typename... Args>\n"
"    auto do_try_emplace(K&& key, Args&&... args) -> std::pair<iterator, bool> {\n"
"        if (ANKERL_UNORDERED_DENSE_UNLIKELY(is_full())) {\n"
"            increase_size();\n"
"        }\n"
"\n"
"        auto hash = mixed_hash(key);\n"
"        auto dist_and_fingerprint = dist_and_fingerprint_from_hash(hash);\n"
"        auto bucket_idx = bucket_idx_from_hash(hash);\n"
"\n"
"        while (true) {\n"
"            auto* bucket = &at(m_buckets, bucket_idx);\n"
"            if (dist_and_fingerprint == bucket->m_dist_and_fingerprint) {\n"
"                if (m_equal(key, m_values[bucket->m_value_idx].first)) {\n"
"                    return {begin() + static_cast<difference_type>(bucket->m_value_idx), false};\n"
"                }\n"
"            } else if (dist_and_fingerprint > bucket->m_dist_and_fingerprint) {\n"
"                return do_place_element(dist_and_fingerprint, bucket_idx, std::forward<K>(key), std::forward<Args>(args)...);\n"
"            }\n"
"            dist_and_fingerprint = dist_inc(dist_and_fingerprint);\n"
"            bucket_idx = next(bucket_idx);\n"
"        }\n"
"    }\n"
"\n"
"    template <typename K>\n"
"    auto do_find(K const& key) -> iterator {\n"
"        if (ANKERL_UNORDERED_DENSE_UNLIKELY(empty())) {\n"
"            return end();\n"
"        }\n"
"\n"
"        auto mh = mixed_hash(key);\n"
"        auto dist_and_fingerprint = dist_and_fingerprint_from_hash(mh);\n"
"        auto bucket_idx = bucket_idx_from_hash(mh);\n"
"        auto* bucket = &at(m_buckets, bucket_idx);\n"
"\n"
"        // unrolled loop. *Always* check a few directly, then enter the loop. This is faster.\n"
"        if (dist_and_fingerprint == bucket->m_dist_and_fingerprint && m_equal(key, get_key(m_values[bucket->m_value_idx]))) {\n"
"            return begin() + static_cast<difference_type>(bucket->m_value_idx);\n"
"        }\n"
"        dist_and_fingerprint = dist_inc(dist_and_fingerprint);\n"
"        bucket_idx = next(bucket_idx);\n"
"        bucket = &at(m_buckets, bucket_idx);\n"
"\n"
"        if (dist_and_fingerprint == bucket->m_dist_and_fingerprint && m_equal(key, get_key(m_values[bucket->m_value_idx]))) {\n"
"            return begin() + static_cast<difference_type>(bucket->m_value_idx);\n"
"        }\n"
"        dist_and_fingerprint = dist_inc(dist_and_fingerprint);\n"
"        bucket_idx = next(bucket_idx);\n"
"        bucket = &at(m_buckets, bucket_idx);\n"
"\n"
"        while (true) {\n"
"            if (dist_and_fingerprint == bucket->m_dist_and_fingerprint) {\n"
"                if (m_equal(key, get_key(m_values[bucket->m_value_idx]))) {\n"
"                    return begin() + static_cast<difference_type>(bucket->m_value_idx);\n"
"                }\n"
"            } else if (dist_and_fingerprint > bucket->m_dist_and_fingerprint) {\n"
"                return end();\n"
"            }\n"
"            dist_and_fingerprint = dist_inc(dist_and_fingerprint);\n"
"            bucket_idx = next(bucket_idx);\n"
"            bucket = &at(m_buckets, bucket_idx);\n"
"        }\n"
"    }\n"
"\n"
"    template <typename K>\n"
"    auto do_find(K const& key) const -> const_iterator {\n"
"        return const_cast<table*>(this)->do_find(key); // NOLINT(cppcoreguidelines-pro-type-const-cast)\n"
"    }\n"
"\n"
"    template <typename K, typename Q = T, std::enable_if_t<is_map_v<Q>, bool> = true>\n"
"    auto do_at(K const& key) -> Q& {\n"
"        if (auto it = find(key); ANKERL_UNORDERED_DENSE_LIKELY(end() != it)) {\n"
"            return it->second;\n"
"        }\n"
"        on_error_key_not_found();\n"
"    }\n"
"\n"
"    template <typename K, typename Q = T, std::enable_if_t<is_map_v<Q>, bool> = true>\n"
"    auto do_at(K const& key) const -> Q const& {\n"
"        return const_cast<table*>(this)->at(key); // NOLINT(cppcoreguidelines-pro-type-const-cast)\n"
"    }\n"
"\n"
"public:\n"
"    table()\n"
"        : table(0) {}\n"
"\n"
"    explicit table(size_t bucket_count,\n"
"                   Hash const& hash = Hash(),\n"
"                   KeyEqual const& equal = KeyEqual(),\n"
"                   allocator_type const& alloc_or_container = allocator_type())\n"
"        : m_values(alloc_or_container)\n"
"        , m_hash(hash)\n"
"        , m_equal(equal) {\n"
"        if (0 != bucket_count) {\n"
"            reserve(bucket_count);\n"
"        }\n"
"    }\n"
"\n"
"    table(size_t bucket_count, allocator_type const& alloc)\n"
"        : table(bucket_count, Hash(), KeyEqual(), alloc) {}\n"
"\n"
"    table(size_t bucket_count, Hash const& hash, allocator_type const& alloc)\n"
"        : table(bucket_count, hash, KeyEqual(), alloc) {}\n"
"\n"
"    explicit table(allocator_type const& alloc)\n"
"        : table(0, Hash(), KeyEqual(), alloc) {}\n"
"\n"
"    template <class InputIt>\n"
"    table(InputIt first,\n"
"          InputIt last,\n"
"          size_type bucket_count = 0,\n"
"          Hash const& hash = Hash(),\n"
"          KeyEqual const& equal = KeyEqual(),\n"
"          allocator_type const& alloc = allocator_type())\n"
"        : table(bucket_count, hash, equal, alloc) {\n"
"        insert(first, last);\n"
"    }\n"
"\n"
"    template <class InputIt>\n"
"    table(InputIt first, InputIt last, size_type bucket_count, allocator_type const& alloc)\n"
"        : table(first, last, bucket_count, Hash(), KeyEqual(), alloc) {}\n"
"\n"
"    template <class InputIt>\n"
"    table(InputIt first, InputIt last, size_type bucket_count, Hash const& hash, allocator_type const& alloc)\n"
"        : table(first, last, bucket_count, hash, KeyEqual(), alloc) {}\n"
"\n"
"    table(table const& other)\n"
"        : table(other, other.m_values.get_allocator()) {}\n"
"\n"
"    table(table const& other, allocator_type const& alloc)\n"
"        : m_values(other.m_values, alloc)\n"
"        , m_max_load_factor(other.m_max_load_factor)\n"
"        , m_hash(other.m_hash)\n"
"        , m_equal(other.m_equal) {\n"
"        copy_buckets(other);\n"
"    }\n"
"\n"
"    table(table&& other) noexcept\n"
"        : table(std::move(other), other.m_values.get_allocator()) {}\n"
"\n"
"    table(table&& other, allocator_type const& alloc) noexcept\n"
"        : m_values(alloc) {\n"
"        *this = std::move(other);\n"
"    }\n"
"\n"
"    table(std::initializer_list<value_type> ilist,\n"
"          size_t bucket_count = 0,\n"
"          Hash const& hash = Hash(),\n"
"          KeyEqual const& equal = KeyEqual(),\n"
"          allocator_type const& alloc = allocator_type())\n"
"        : table(bucket_count, hash, equal, alloc) {\n"
"        insert(ilist);\n"
"    }\n"
"\n"
"    table(std::initializer_list<value_type> ilist, size_type bucket_count, allocator_type const& alloc)\n"
"        : table(ilist, bucket_count, Hash(), KeyEqual(), alloc) {}\n"
"\n"
"    table(std::initializer_list<value_type> init, size_type bucket_count, Hash const& hash, allocator_type const& alloc)\n"
"        : table(init, bucket_count, hash, KeyEqual(), alloc) {}\n"
"\n"
"    ~table() {\n"
"        if (nullptr != m_buckets) {\n"
"            auto ba = bucket_alloc(m_values.get_allocator());\n"
"            bucket_alloc_traits::deallocate(ba, m_buckets, bucket_count());\n"
"        }\n"
"    }\n"
"\n"
"    auto operator=(table const& other) -> table& {\n"
"        if (&other != this) {\n"
"            deallocate_buckets(); // deallocate before m_values is set (might have another allocator)\n"
"            m_values = other.m_values;\n"
"            m_max_load_factor = other.m_max_load_factor;\n"
"            m_hash = other.m_hash;\n"
"            m_equal = other.m_equal;\n"
"            m_shifts = initial_shifts;\n"
"            copy_buckets(other);\n"
"        }\n"
"        return *this;\n"
"    }\n"
"\n"
"    auto operator=(table&& other) noexcept(\n"
"        noexcept(std::is_nothrow_move_assignable_v<value_container_type>&& std::is_nothrow_move_assignable_v<Hash>&&\n"
"                     std::is_nothrow_move_assignable_v<KeyEqual>)) -> table& {\n"
"        if (&other != this) {\n"
"            deallocate_buckets(); // deallocate before m_values is set (might have another allocator)\n"
"            m_values = std::move(other.m_values);\n"
"            other.m_values.clear();\n"
"\n"
"            // we can only reuse m_buckets when both maps have the same allocator!\n"
"            if (get_allocator() == other.get_allocator()) {\n"
"                m_buckets = std::exchange(other.m_buckets, nullptr);\n"
"                m_num_buckets = std::exchange(other.m_num_buckets, 0);\n"
"                m_max_bucket_capacity = std::exchange(other.m_max_bucket_capacity, 0);\n"
"                m_shifts = std::exchange(other.m_shifts, initial_shifts);\n"
"                m_max_load_factor = std::exchange(other.m_max_load_factor, default_max_load_factor);\n"
;
sb << 
"                m_hash = std::exchange(other.m_hash, {});\n"
"                m_equal = std::exchange(other.m_equal, {});\n"
"            } else {\n"
"                // set max_load_factor *before* copying the other's buckets, so we have the same\n"
"                // behavior\n"
"                m_max_load_factor = other.m_max_load_factor;\n"
"\n"
"                // copy_buckets sets m_buckets, m_num_buckets, m_max_bucket_capacity, m_shifts\n"
"                copy_buckets(other);\n"
"                // clear's the other's buckets so other is now already usable.\n"
"                other.clear_buckets();\n"
"                m_hash = other.m_hash;\n"
"                m_equal = other.m_equal;\n"
"            }\n"
"            // map \"other\" is now already usable, it's empty.\n"
"        }\n"
"        return *this;\n"
"    }\n"
"\n"
"    auto operator=(std::initializer_list<value_type> ilist) -> table& {\n"
"        clear();\n"
"        insert(ilist);\n"
"        return *this;\n"
"    }\n"
"\n"
"    auto get_allocator() const noexcept -> allocator_type {\n"
"        return m_values.get_allocator();\n"
"    }\n"
"\n"
"    // iterators //////////////////////////////////////////////////////////////\n"
"\n"
"    auto begin() noexcept -> iterator {\n"
"        return m_values.begin();\n"
"    }\n"
"\n"
"    auto begin() const noexcept -> const_iterator {\n"
"        return m_values.begin();\n"
"    }\n"
"\n"
"    auto cbegin() const noexcept -> const_iterator {\n"
"        return m_values.cbegin();\n"
"    }\n"
"\n"
"    auto end() noexcept -> iterator {\n"
"        return m_values.end();\n"
"    }\n"
"\n"
"    auto cend() const noexcept -> const_iterator {\n"
"        return m_values.cend();\n"
"    }\n"
"\n"
"    auto end() const noexcept -> const_iterator {\n"
"        return m_values.end();\n"
"    }\n"
"\n"
"    // capacity ///////////////////////////////////////////////////////////////\n"
"\n"
"    [[nodiscard]] auto empty() const noexcept -> bool {\n"
"        return m_values.empty();\n"
"    }\n"
"\n"
"    [[nodiscard]] auto size() const noexcept -> size_t {\n"
"        return m_values.size();\n"
"    }\n"
"\n"
"    [[nodiscard]] static constexpr auto max_size() noexcept -> size_t {\n"
"        if constexpr ((std::numeric_limits<value_idx_type>::max)() == (std::numeric_limits<size_t>::max)()) {\n"
"            return size_t{1} << (sizeof(value_idx_type) * 8 - 1);\n"
"        } else {\n"
"            return size_t{1} << (sizeof(value_idx_type) * 8);\n"
"        }\n"
"    }\n"
"\n"
"    // modifiers //////////////////////////////////////////////////////////////\n"
"\n"
"    void clear() {\n"
"        m_values.clear();\n"
"        clear_buckets();\n"
"    }\n"
"\n"
"    auto insert(value_type const& value) -> std::pair<iterator, bool> {\n"
"        return emplace(value);\n"
"    }\n"
"\n"
"    auto insert(value_type&& value) -> std::pair<iterator, bool> {\n"
"        return emplace(std::move(value));\n"
"    }\n"
"\n"
"    template <class P, std::enable_if_t<std::is_constructible_v<value_type, P&&>, bool> = true>\n"
"    auto insert(P&& value) -> std::pair<iterator, bool> {\n"
"        return emplace(std::forward<P>(value));\n"
"    }\n"
"\n"
"    auto insert(const_iterator /*hint*/, value_type const& value) -> iterator {\n"
"        return insert(value).first;\n"
"    }\n"
"\n"
"    auto insert(const_iterator /*hint*/, value_type&& value) -> iterator {\n"
"        return insert(std::move(value)).first;\n"
"    }\n"
"\n"
"    template <class P, std::enable_if_t<std::is_constructible_v<value_type, P&&>, bool> = true>\n"
"    auto insert(const_iterator /*hint*/, P&& value) -> iterator {\n"
"        return insert(std::forward<P>(value)).first;\n"
"    }\n"
"\n"
"    template <class InputIt>\n"
"    void insert(InputIt first, InputIt last) {\n"
"        while (first != last) {\n"
"            insert(*first);\n"
"            ++first;\n"
"        }\n"
"    }\n"
"\n"
"    void insert(std::initializer_list<value_type> ilist) {\n"
"        insert(ilist.begin(), ilist.end());\n"
"    }\n"
"\n"
"    // nonstandard API: *this is emptied.\n"
"    // Also see \"A Standard flat_map\" https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p0429r9.pdf\n"
"    auto extract() && -> value_container_type {\n"
"        return std::move(m_values);\n"
"    }\n"
"\n"
"    // nonstandard API:\n"
"    // Discards the internally held container and replaces it with the one passed. Erases non-unique elements.\n"
"    auto replace(value_container_type&& container) {\n"
"        if (ANKERL_UNORDERED_DENSE_UNLIKELY(container.size() > max_size())) {\n"
"            on_error_too_many_elements();\n"
"        }\n"
"        auto shifts = calc_shifts_for_size(container.size());\n"
"        if (0 == m_num_buckets || shifts < m_shifts || container.get_allocator() != m_values.get_allocator()) {\n"
"            m_shifts = shifts;\n"
"            deallocate_buckets();\n"
"            allocate_buckets_from_shift();\n"
"        }\n"
"        clear_buckets();\n"
"\n"
"        m_values = std::move(container);\n"
"\n"
"        // can't use clear_and_fill_buckets_from_values() because container elements might not be unique\n"
"        auto value_idx = value_idx_type{};\n"
"\n"
"        // loop until we reach the end of the container. duplicated entries will be replaced with back().\n"
"        while (value_idx != static_cast<value_idx_type>(m_values.size())) {\n"
"            auto const& key = get_key(m_values[value_idx]);\n"
"\n"
"            auto hash = mixed_hash(key);\n"
"            auto dist_and_fingerprint = dist_and_fingerprint_from_hash(hash);\n"
"            auto bucket_idx = bucket_idx_from_hash(hash);\n"
"\n"
"            bool key_found = false;\n"
"            while (true) {\n"
"                auto const& bucket = at(m_buckets, bucket_idx);\n"
"                if (dist_and_fingerprint > bucket.m_dist_and_fingerprint) {\n"
"                    break;\n"
"                }\n"
"                if (dist_and_fingerprint == bucket.m_dist_and_fingerprint &&\n"
"                    m_equal(key, m_values[bucket.m_value_idx].first)) {\n"
"                    key_found = true;\n"
"                    break;\n"
"                }\n"
"                dist_and_fingerprint = dist_inc(dist_and_fingerprint);\n"
"                bucket_idx = next(bucket_idx);\n"
"            }\n"
"\n"
"            if (key_found) {\n"
"                if (value_idx != static_cast<value_idx_type>(m_values.size() - 1)) {\n"
"                    m_values[value_idx] = std::move(m_values.back());\n"
"                }\n"
"                m_values.pop_back();\n"
"            } else {\n"
"                place_and_shift_up({dist_and_fingerprint, value_idx}, bucket_idx);\n"
"                ++value_idx;\n"
"            }\n"
"        }\n"
"    }\n"
"\n"
"    template <class M, typename Q = T, std::enable_if_t<is_map_v<Q>, bool> = true>\n"
"    auto insert_or_assign(Key const& key, M&& mapped) -> std::pair<iterator, bool> {\n"
"        return do_insert_or_assign(key, std::forward<M>(mapped));\n"
"    }\n"
"\n"
"    template <class M, typename Q = T, std::enable_if_t<is_map_v<Q>, bool> = true>\n"
"    auto insert_or_assign(Key&& key, M&& mapped) -> std::pair<iterator, bool> {\n"
"        return do_insert_or_assign(std::move(key), std::forward<M>(mapped));\n"
"    }\n"
"\n"
"    template <typename K,\n"
"              typename M,\n"
"              typename Q = T,\n"
"              typename H = Hash,\n"
"              typename KE = KeyEqual,\n"
"              std::enable_if_t<is_map_v<Q> && is_transparent_v<H, KE>, bool> = true>\n"
"    auto insert_or_assign(K&& key, M&& mapped) -> std::pair<iterator, bool> {\n"
"        return do_insert_or_assign(std::forward<K>(key), std::forward<M>(mapped));\n"
"    }\n"
"\n"
"    template <class M, typename Q = T, std::enable_if_t<is_map_v<Q>, bool> = true>\n"
"    auto insert_or_assign(const_iterator /*hint*/, Key const& key, M&& mapped) -> iterator {\n"
"        return do_insert_or_assign(key, std::forward<M>(mapped)).first;\n"
"    }\n"
"\n"
"    template <class M, typename Q = T, std::enable_if_t<is_map_v<Q>, bool> = true>\n"
"    auto insert_or_assign(const_iterator /*hint*/, Key&& key, M&& mapped) -> iterator {\n"
"        return do_insert_or_assign(std::move(key), std::forward<M>(mapped)).first;\n"
"    }\n"
"\n"
"    template <typename K,\n"
"              typename M,\n"
"              typename Q = T,\n"
"              typename H = Hash,\n"
"              typename KE = KeyEqual,\n"
"              std::enable_if_t<is_map_v<Q> && is_transparent_v<H, KE>, bool> = true>\n"
"    auto insert_or_assign(const_iterator /*hint*/, K&& key, M&& mapped) -> iterator {\n"
"        return do_insert_or_assign(std::forward<K>(key), std::forward<M>(mapped)).first;\n"
"    }\n"
"\n"
"    // Single arguments for unordered_set can be used without having to construct the value_type\n"
"    template <class K,\n"
"              typename Q = T,\n"
"              typename H = Hash,\n"
"              typename KE = KeyEqual,\n"
"              std::enable_if_t<!is_map_v<Q> && is_transparent_v<H, KE>, bool> = true>\n"
"    auto emplace(K&& key) -> std::pair<iterator, bool> {\n"
"        if (is_full()) {\n"
"            increase_size();\n"
"        }\n"
"\n"
"        auto hash = mixed_hash(key);\n"
"        auto dist_and_fingerprint = dist_and_fingerprint_from_hash(hash);\n"
"        auto bucket_idx = bucket_idx_from_hash(hash);\n"
"\n"
"        while (dist_and_fingerprint <= at(m_buckets, bucket_idx).m_dist_and_fingerprint) {\n"
"            if (dist_and_fingerprint == at(m_buckets, bucket_idx).m_dist_and_fingerprint &&\n"
"                m_equal(key, m_values[at(m_buckets, bucket_idx).m_value_idx])) {\n"
"                // found it, return without ever actually creating anything\n"
"                return {begin() + static_cast<difference_type>(at(m_buckets, bucket_idx).m_value_idx), false};\n"
"            }\n"
"            dist_and_fingerprint = dist_inc(dist_and_fingerprint);\n"
"            bucket_idx = next(bucket_idx);\n"
"        }\n"
"\n"
"        // value is new, insert element first, so when exception happens we are in a valid state\n"
"        m_values.emplace_back(std::forward<K>(key));\n"
"        // now place the bucket and shift up until we find an empty spot\n"
"        auto value_idx = static_cast<value_idx_type>(m_values.size() - 1);\n"
"        place_and_shift_up({dist_and_fingerprint, value_idx}, bucket_idx);\n"
"        return {begin() + static_cast<difference_type>(value_idx), true};\n"
"    }\n"
"\n"
"    template <class... Args>\n"
"    auto emplace(Args&&... args) -> std::pair<iterator, bool> {\n"
"        if (is_full()) {\n"
"            increase_size();\n"
"        }\n"
"\n"
"        // we have to instantiate the value_type to be able to access the key.\n"
"        // 1. emplace_back the object so it is constructed. 2. If the key is already there, pop it later in the loop.\n"
"        auto& key = get_key(m_values.emplace_back(std::forward<Args>(args)...));\n"
"        auto hash = mixed_hash(key);\n"
"        auto dist_and_fingerprint = dist_and_fingerprint_from_hash(hash);\n"
"        auto bucket_idx = bucket_idx_from_hash(hash);\n"
"\n"
"        while (dist_and_fingerprint <= at(m_buckets, bucket_idx).m_dist_and_fingerprint) {\n"
"            if (dist_and_fingerprint == at(m_buckets, bucket_idx).m_dist_and_fingerprint &&\n"
"                m_equal(key, get_key(m_values[at(m_buckets, bucket_idx).m_value_idx]))) {\n"
"                m_values.pop_back(); // value was already there, so get rid of it\n"
"                return {begin() + static_cast<difference_type>(at(m_buckets, bucket_idx).m_value_idx), false};\n"
"            }\n"
"            dist_and_fingerprint = dist_inc(dist_and_fingerprint);\n"
"            bucket_idx = next(bucket_idx);\n"
"        }\n"
"\n"
"        // value is new, place the bucket and shift up until we find an empty spot\n"
"        auto value_idx = static_cast<value_idx_type>(m_values.size() - 1);\n"
"        place_and_shift_up({dist_and_fingerprint, value_idx}, bucket_idx);\n"
"\n"
"        return {begin() + static_cast<difference_type>(value_idx), true};\n"
"    }\n"
"\n"
"    template <class... Args>\n"
"    auto emplace_hint(const_iterator /*hint*/, Args&&... args) -> iterator {\n"
"        return emplace(std::forward<Args>(args)...).first;\n"
"    }\n"
"\n"
"    template <class... Args, typename Q = T, std::enable_if_t<is_map_v<Q>, bool> = true>\n"
"    auto try_emplace(Key const& key, Args&&... args) -> std::pair<iterator, bool> {\n"
"        return do_try_emplace(key, std::forward<Args>(args)...);\n"
"    }\n"
"\n"
"    template <class... Args, typename Q = T, std::enable_if_t<is_map_v<Q>, bool> = true>\n"
"    auto try_emplace(Key&& key, Args&&... args) -> std::pair<iterator, bool> {\n"
"        return do_try_emplace(std::move(key), std::forward<Args>(args)...);\n"
"    }\n"
"\n"
"    template <class... Args, typename Q = T, std::enable_if_t<is_map_v<Q>, bool> = true>\n"
"    auto try_emplace(const_iterator /*hint*/, Key const& key, Args&&... args) -> iterator {\n"
"        return do_try_emplace(key, std::forward<Args>(args)...).first;\n"
"    }\n"
"\n"
"    template <class... Args, typename Q = T, std::enable_if_t<is_map_v<Q>, bool> = true>\n"
"    auto try_emplace(const_iterator /*hint*/, Key&& key, Args&&... args) -> iterator {\n"
"        return do_try_emplace(std::move(key), std::forward<Args>(args)...).first;\n"
"    }\n"
"\n"
"    template <\n"
"        typename K,\n"
"        typename... Args,\n"
"        typename Q = T,\n"
"        typename H = Hash,\n"
"        typename KE = KeyEqual,\n"
"        std::enable_if_t<is_map_v<Q> && is_transparent_v<H, KE> && is_neither_convertible_v<K&&, iterator, const_iterator>,\n"
"                         bool> = true>\n"
"    auto try_emplace(K&& key, Args&&... args) -> std::pair<iterator, bool> {\n"
"        return do_try_emplace(std::forward<K>(key), std::forward<Args>(args)...);\n"
"    }\n"
"\n"
"    template <\n"
"        typename K,\n"
"        typename... Args,\n"
"        typename Q = T,\n"
"        typename H = Hash,\n"
"        typename KE = KeyEqual,\n"
"        std::enable_if_t<is_map_v<Q> && is_transparent_v<H, KE> && is_neither_convertible_v<K&&, iterator, const_iterator>,\n"
"                         bool> = true>\n"
"    auto try_emplace(const_iterator /*hint*/, K&& key, Args&&... args) -> iterator {\n"
"        return do_try_emplace(std::forward<K>(key), std::forward<Args>(args)...).first;\n"
"    }\n"
"\n"
"    auto erase(iterator it) -> iterator {\n"
"        auto hash = mixed_hash(get_key(*it));\n"
"        auto bucket_idx = bucket_idx_from_hash(hash);\n"
"\n"
"        auto const value_idx_to_remove = static_cast<value_idx_type>(it - cbegin());\n"
"        while (at(m_buckets, bucket_idx).m_value_idx != value_idx_to_remove) {\n"
"            bucket_idx = next(bucket_idx);\n"
"        }\n"
"\n"
"        do_erase(bucket_idx);\n"
"        return begin() + static_cast<difference_type>(value_idx_to_remove);\n"
"    }\n"
"\n"
"    template <typename Q = T, std::enable_if_t<is_map_v<Q>, bool> = true>\n"
"    auto erase(const_iterator it) -> iterator {\n"
"        return erase(begin() + (it - cbegin()));\n"
"    }\n"
"\n"
"    auto erase(const_iterator first, const_iterator last) -> iterator {\n"
"        auto const idx_first = first - cbegin();\n"
"        auto const idx_last = last - cbegin();\n"
"        auto const first_to_last = std::distance(first, last);\n"
"        auto const last_to_end = std::distance(last, cend());\n"
"\n"
"        // remove elements from left to right which moves elements from the end back\n"
"        auto const mid = idx_first + (std::min)(first_to_last, last_to_end);\n"
"        auto idx = idx_first;\n"
"        while (idx != mid) {\n"
"            erase(begin() + idx);\n"
"            ++idx;\n"
"        }\n"
"\n"
"        // all elements from the right are moved, now remove the last element until all done\n"
"        idx = idx_last;\n"
"        while (idx != mid) {\n"
"            --idx;\n"
"            erase(begin() + idx);\n"
"        }\n"
"\n"
"        return begin() + idx_first;\n"
"    }\n"
"\n"
"    auto erase(Key const& key) -> size_t {\n"
"        return do_erase_key(key);\n"
"    }\n"
"\n"
"    template <class K, class H = Hash, class KE = KeyEqual, std::enable_if_t<is_transparent_v<H, KE>, bool> = true>\n"
"    auto erase(K&& key) -> size_t {\n"
"        return do_erase_key(std::forward<K>(key));\n"
"    }\n"
"\n"
"    void swap(table& other) noexcept(noexcept(std::is_nothrow_swappable_v<value_container_type>&&\n"
"                                                  std::is_nothrow_swappable_v<Hash>&& std::is_nothrow_swappable_v<KeyEqual>)) {\n"
"        using std::swap;\n"
"        swap(other, *this);\n"
"    }\n"
"\n"
"    // lookup /////////////////////////////////////////////////////////////////\n"
"\n"
"    template <typename Q = T, std::enable_if_t<is_map_v<Q>, bool> = true>\n"
"    auto at(key_type const& key) -> Q& {\n"
"        return do_at(key);\n"
"    }\n"
"\n"
"    template <typename K,\n"
"              typename Q = T,\n"
"              typename H = Hash,\n"
"              typename KE = KeyEqual,\n"
"              std::enable_if_t<is_map_v<Q> && is_transparent_v<H, KE>, bool> = true>\n"
"    auto at(K const& key) -> Q& {\n"
"        return do_at(key);\n"
"    }\n"
"\n"
"    template <typename Q = T, std::enable_if_t<is_map_v<Q>, bool> = true>\n"
"    auto at(key_type const& key) const -> Q const& {\n"
"        return do_at(key);\n"
"    }\n"
"\n"
"    template <typename K,\n"
"              typename Q = T,\n"
"              typename H = Hash,\n"
"              typename KE = KeyEqual,\n"
"              std::enable_if_t<is_map_v<Q> && is_transparent_v<H, KE>, bool> = true>\n"
"    auto at(K const& key) const -> Q const& {\n"
"        return do_at(key);\n"
"    }\n"
"\n"
"    template <typename Q = T, std::enable_if_t<is_map_v<Q>, bool> = true>\n"
"    auto operator[](Key const& key) -> Q& {\n"
"        return try_emplace(key).first->second;\n"
"    }\n"
"\n"
"    template <typename Q = T, std::enable_if_t<is_map_v<Q>, bool> = true>\n"
"    auto operator[](Key&& key) -> Q& {\n"
"        return try_emplace(std::move(key)).first->second;\n"
"    }\n"
"\n"
"    template <typename K,\n"
"              typename Q = T,\n"
"              typename H = Hash,\n"
"              typename KE = KeyEqual,\n"
;
sb << 
"              std::enable_if_t<is_map_v<Q> && is_transparent_v<H, KE>, bool> = true>\n"
"    auto operator[](K&& key) -> Q& {\n"
"        return try_emplace(std::forward<K>(key)).first->second;\n"
"    }\n"
"\n"
"    auto count(Key const& key) const -> size_t {\n"
"        return find(key) == end() ? 0 : 1;\n"
"    }\n"
"\n"
"    template <class K, class H = Hash, class KE = KeyEqual, std::enable_if_t<is_transparent_v<H, KE>, bool> = true>\n"
"    auto count(K const& key) const -> size_t {\n"
"        return find(key) == end() ? 0 : 1;\n"
"    }\n"
"\n"
"    auto find(Key const& key) -> iterator {\n"
"        return do_find(key);\n"
"    }\n"
"\n"
"    auto find(Key const& key) const -> const_iterator {\n"
"        return do_find(key);\n"
"    }\n"
"\n"
"    template <class K, class H = Hash, class KE = KeyEqual, std::enable_if_t<is_transparent_v<H, KE>, bool> = true>\n"
"    auto find(K const& key) -> iterator {\n"
"        return do_find(key);\n"
"    }\n"
"\n"
"    template <class K, class H = Hash, class KE = KeyEqual, std::enable_if_t<is_transparent_v<H, KE>, bool> = true>\n"
"    auto find(K const& key) const -> const_iterator {\n"
"        return do_find(key);\n"
"    }\n"
"\n"
"    auto contains(Key const& key) const -> bool {\n"
"        return find(key) != end();\n"
"    }\n"
"\n"
"    template <class K, class H = Hash, class KE = KeyEqual, std::enable_if_t<is_transparent_v<H, KE>, bool> = true>\n"
"    auto contains(K const& key) const -> bool {\n"
"        return find(key) != end();\n"
"    }\n"
"\n"
"    auto equal_range(Key const& key) -> std::pair<iterator, iterator> {\n"
"        auto it = do_find(key);\n"
"        return {it, it == end() ? end() : it + 1};\n"
"    }\n"
"\n"
"    auto equal_range(const Key& key) const -> std::pair<const_iterator, const_iterator> {\n"
"        auto it = do_find(key);\n"
"        return {it, it == end() ? end() : it + 1};\n"
"    }\n"
"\n"
"    template <class K, class H = Hash, class KE = KeyEqual, std::enable_if_t<is_transparent_v<H, KE>, bool> = true>\n"
"    auto equal_range(K const& key) -> std::pair<iterator, iterator> {\n"
"        auto it = do_find(key);\n"
"        return {it, it == end() ? end() : it + 1};\n"
"    }\n"
"\n"
"    template <class K, class H = Hash, class KE = KeyEqual, std::enable_if_t<is_transparent_v<H, KE>, bool> = true>\n"
"    auto equal_range(K const& key) const -> std::pair<const_iterator, const_iterator> {\n"
"        auto it = do_find(key);\n"
"        return {it, it == end() ? end() : it + 1};\n"
"    }\n"
"\n"
"    // bucket interface ///////////////////////////////////////////////////////\n"
"\n"
"    auto bucket_count() const noexcept -> size_t { // NOLINT(modernize-use-nodiscard)\n"
"        return m_num_buckets;\n"
"    }\n"
"\n"
"    static constexpr auto max_bucket_count() noexcept -> size_t { // NOLINT(modernize-use-nodiscard)\n"
"        return max_size();\n"
"    }\n"
"\n"
"    // hash policy ////////////////////////////////////////////////////////////\n"
"\n"
"    [[nodiscard]] auto load_factor() const -> float {\n"
"        return bucket_count() ? static_cast<float>(size()) / static_cast<float>(bucket_count()) : 0.0F;\n"
"    }\n"
"\n"
"    [[nodiscard]] auto max_load_factor() const -> float {\n"
"        return m_max_load_factor;\n"
"    }\n"
"\n"
"    void max_load_factor(float ml) {\n"
"        m_max_load_factor = ml;\n"
"        if (m_num_buckets != max_bucket_count()) {\n"
"            m_max_bucket_capacity = static_cast<value_idx_type>(static_cast<float>(bucket_count()) * max_load_factor());\n"
"        }\n"
"    }\n"
"\n"
"    void rehash(size_t count) {\n"
"        count = (std::min)(count, max_size());\n"
"        auto shifts = calc_shifts_for_size((std::max)(count, size()));\n"
"        if (shifts != m_shifts) {\n"
"            m_shifts = shifts;\n"
"            deallocate_buckets();\n"
"            m_values.shrink_to_fit();\n"
"            allocate_buckets_from_shift();\n"
"            clear_and_fill_buckets_from_values();\n"
"        }\n"
"    }\n"
"\n"
"    void reserve(size_t capa) {\n"
"        capa = (std::min)(capa, max_size());\n"
"        if constexpr (has_reserve<value_container_type>) {\n"
"            // std::deque doesn't have reserve(). Make sure we only call when available\n"
"            m_values.reserve(capa);\n"
"        }\n"
"        auto shifts = calc_shifts_for_size((std::max)(capa, size()));\n"
"        if (0 == m_num_buckets || shifts < m_shifts) {\n"
"            m_shifts = shifts;\n"
"            deallocate_buckets();\n"
"            allocate_buckets_from_shift();\n"
"            clear_and_fill_buckets_from_values();\n"
"        }\n"
"    }\n"
"\n"
"    // observers //////////////////////////////////////////////////////////////\n"
"\n"
"    auto hash_function() const -> hasher {\n"
"        return m_hash;\n"
"    }\n"
"\n"
"    auto key_eq() const -> key_equal {\n"
"        return m_equal;\n"
"    }\n"
"\n"
"    // nonstandard API: expose the underlying values container\n"
"    [[nodiscard]] auto values() const noexcept -> value_container_type const& {\n"
"        return m_values;\n"
"    }\n"
"\n"
"    // non-member functions ///////////////////////////////////////////////////\n"
"\n"
"    friend auto operator==(table const& a, table const& b) -> bool {\n"
"        if (&a == &b) {\n"
"            return true;\n"
"        }\n"
"        if (a.size() != b.size()) {\n"
"            return false;\n"
"        }\n"
"        for (auto const& b_entry : b) {\n"
"            auto it = a.find(get_key(b_entry));\n"
"            if constexpr (is_map_v<T>) {\n"
"                // map: check that key is here, then also check that value is the same\n"
"                if (a.end() == it || !(b_entry.second == it->second)) {\n"
"                    return false;\n"
"                }\n"
"            } else {\n"
"                // set: only check that the key is here\n"
"                if (a.end() == it) {\n"
"                    return false;\n"
"                }\n"
"            }\n"
"        }\n"
"        return true;\n"
"    }\n"
"\n"
"    friend auto operator!=(table const& a, table const& b) -> bool {\n"
"        return !(a == b);\n"
"    }\n"
"};\n"
"\n"
"} // namespace detail\n"
"\n"
"template <class Key,\n"
"          class T,\n"
"          class Hash = hash<Key>,\n"
"          class KeyEqual = std::equal_to<Key>,\n"
"          class AllocatorOrContainer = std::allocator<std::pair<Key, T>>,\n"
"          class Bucket = bucket_type::standard>\n"
"using map = detail::table<Key, T, Hash, KeyEqual, AllocatorOrContainer, Bucket, false>;\n"
"\n"
"template <class Key,\n"
"          class T,\n"
"          class Hash = hash<Key>,\n"
"          class KeyEqual = std::equal_to<Key>,\n"
"          class AllocatorOrContainer = std::allocator<std::pair<Key, T>>,\n"
"          class Bucket = bucket_type::standard>\n"
"using segmented_map = detail::table<Key, T, Hash, KeyEqual, AllocatorOrContainer, Bucket, true>;\n"
"\n"
"template <class Key,\n"
"          class Hash = hash<Key>,\n"
"          class KeyEqual = std::equal_to<Key>,\n"
"          class AllocatorOrContainer = std::allocator<Key>,\n"
"          class Bucket = bucket_type::standard>\n"
"using set = detail::table<Key, void, Hash, KeyEqual, AllocatorOrContainer, Bucket, false>;\n"
"\n"
"template <class Key,\n"
"          class Hash = hash<Key>,\n"
"          class KeyEqual = std::equal_to<Key>,\n"
"          class AllocatorOrContainer = std::allocator<Key>,\n"
"          class Bucket = bucket_type::standard>\n"
"using segmented_set = detail::table<Key, void, Hash, KeyEqual, AllocatorOrContainer, Bucket, true>;\n"
"\n"
"#    if defined(ANKERL_UNORDERED_DENSE_PMR)\n"
"\n"
"namespace pmr {\n"
"\n"
"template <class Key,\n"
"          class T,\n"
"          class Hash = hash<Key>,\n"
"          class KeyEqual = std::equal_to<Key>,\n"
"          class Bucket = bucket_type::standard>\n"
"using map =\n"
"    detail::table<Key, T, Hash, KeyEqual, ANKERL_UNORDERED_DENSE_PMR::polymorphic_allocator<std::pair<Key, T>>, Bucket, false>;\n"
"\n"
"template <class Key,\n"
"          class T,\n"
"          class Hash = hash<Key>,\n"
"          class KeyEqual = std::equal_to<Key>,\n"
"          class Bucket = bucket_type::standard>\n"
"using segmented_map =\n"
"    detail::table<Key, T, Hash, KeyEqual, ANKERL_UNORDERED_DENSE_PMR::polymorphic_allocator<std::pair<Key, T>>, Bucket, true>;\n"
"\n"
"template <class Key, class Hash = hash<Key>, class KeyEqual = std::equal_to<Key>, class Bucket = bucket_type::standard>\n"
"using set = detail::table<Key, void, Hash, KeyEqual, ANKERL_UNORDERED_DENSE_PMR::polymorphic_allocator<Key>, Bucket, false>;\n"
"\n"
"template <class Key, class Hash = hash<Key>, class KeyEqual = std::equal_to<Key>, class Bucket = bucket_type::standard>\n"
"using segmented_set =\n"
"    detail::table<Key, void, Hash, KeyEqual, ANKERL_UNORDERED_DENSE_PMR::polymorphic_allocator<Key>, Bucket, true>;\n"
"\n"
"} // namespace pmr\n"
"\n"
"#    endif\n"
"\n"
"// deduction guides ///////////////////////////////////////////////////////////\n"
"\n"
"// deduction guides for alias templates are only possible since C++20\n"
"// see https://en.cppreference.com/w/cpp/language/class_template_argument_deduction\n"
"\n"
"} // namespace ANKERL_UNORDERED_DENSE_NAMESPACE\n"
"} // namespace ankerl::unordered_dense\n"
"\n"
"// std extensions /////////////////////////////////////////////////////////////\n"
"\n"
"namespace std { // NOLINT(cert-dcl58-cpp)\n"
"\n"
"template <class Key,\n"
"          class T,\n"
"          class Hash,\n"
"          class KeyEqual,\n"
"          class AllocatorOrContainer,\n"
"          class Bucket,\n"
"          class Pred,\n"
"          bool IsSegmented>\n"
"// NOLINTNEXTLINE(cert-dcl58-cpp)\n"
"auto erase_if(ankerl::unordered_dense::detail::table<Key, T, Hash, KeyEqual, AllocatorOrContainer, Bucket, IsSegmented>& map,\n"
"              Pred pred) -> size_t {\n"
"    using map_t = ankerl::unordered_dense::detail::table<Key, T, Hash, KeyEqual, AllocatorOrContainer, Bucket, IsSegmented>;\n"
"\n"
"    // going back to front because erase() invalidates the end iterator\n"
"    auto const old_size = map.size();\n"
"    auto idx = old_size;\n"
"    while (idx) {\n"
"        --idx;\n"
"        auto it = map.begin() + static_cast<typename map_t::difference_type>(idx);\n"
"        if (pred(*it)) {\n"
"            map.erase(it);\n"
"        }\n"
"    }\n"
"\n"
"    return old_size - map.size();\n"
"}\n"
"\n"
"} // namespace std\n"
"\n"
"#endif\n"
"#endif\n"
"\n"
"#include <cstring>\n"
"#include <type_traits>\n"
"\n"
"namespace Slang\n"
"{\n"
"    //\n"
"    // Types\n"
"    //\n"
"\n"
"    // A fixed 64bit wide hash on all targets.\n"
"    typedef uint64_t HashCode64;\n"
"    typedef HashCode64 HashCode;\n"
"    // A fixed 32bit wide hash on all targets.\n"
"    typedef uint32_t HashCode32;\n"
"\n"
"    //\n"
"    // Some helpers to determine which hash to use for a type\n"
"    //\n"
"\n"
"    // Forward declare Hash\n"
"    template<typename T> struct Hash;\n"
"\n"
"    template<typename T, typename = void>\n"
"    constexpr static bool HasSlangHash = false;\n"
"    template<typename T>\n"
"    constexpr static bool HasSlangHash<\n"
"        T,\n"
"        std::enable_if_t<std::is_convertible_v<\n"
"            decltype((std::declval<const T&>()).getHashCode()),\n"
"            HashCode64>>>\n"
"        = true;\n"
"\n"
"    // Does the hashmap implementation provide a uniform hash for this type.\n"
"    template<typename T, typename = void>\n"
"    constexpr static bool HasWyhash = false;\n"
"    template<typename T>\n"
"    constexpr static bool HasWyhash<T, typename ankerl::unordered_dense::hash<T>::is_avalanching> = true;\n"
"\n"
"    // We want to have an associated type 'is_avalanching = void' iff we have a\n"
"    // hash with good uniformity, the two specializations here add that member\n"
"    // when appropriate (since we can't declare an associated type with\n"
"    // constexpr if or something terse like that)\n"
"    template <typename T, typename = void>\n"
"    struct DetectAvalanchingHash {};\n"
"    template <typename T>\n"
"    struct DetectAvalanchingHash<T, std::enable_if_t<HasWyhash<T>>>\n"
"    {\n"
"        using is_avalanching = void;\n"
"    };\n"
"    // Have we marked 'getHashCode' as having good uniformity properties.\n"
"    template <typename T>\n"
"    struct DetectAvalanchingHash<T, std::enable_if_t<T::kHasUniformHash>>\n"
"    {\n"
"        using is_avalanching = void;\n"
"    };\n"
"\n"
"    // A helper for hashing according to the bit representation\n"
"    template<typename T, typename U>\n"
"    struct BitCastHash : DetectAvalanchingHash<U>\n"
"    {\n"
"        auto operator()(const T& t) const\n"
"        {\n"
"            // Doesn't discard or invent bits\n"
"            static_assert(sizeof(T) == sizeof(U));\n"
"            // Can we copy bytes to and fro\n"
"            static_assert(std::is_trivially_copyable_v<T>);\n"
"            static_assert(std::is_trivially_copyable_v<U>);\n"
"            // Because we construct a U to memcpy into\n"
"            static_assert(std::is_trivially_constructible_v<U>);\n"
"\n"
"            U u;\n"
"            memcpy(&u, &t, sizeof(T));\n"
"            return Hash<U>{}(u);\n"
"        }\n"
"    };\n"
"\n"
"    //\n"
"    // Our hashing functor which disptaches to the most appropriate hashing\n"
"    // function for the type\n"
"    //\n"
"\n"
"    template<typename T>\n"
"    struct Hash : DetectAvalanchingHash<T>\n"
"    {\n"
"        auto operator()(const T& t) const\n"
"        {\n"
"            // Our preference is for any hash we've defined ourselves\n"
"            if constexpr (HasSlangHash<T>)\n"
"                return t.getHashCode();\n"
"            // Otherwise fall back to any good hash provided by the hashmap\n"
"            // library\n"
"            else if constexpr (HasWyhash<T>)\n"
"                return ankerl::unordered_dense::hash<T>{}(t);\n"
"            // Otherwise fail\n"
"            else\n"
"            {\n"
"                // !sizeof(T*) is a 'false' which is dependent on T (pending P2593R0)\n"
"                static_assert(!sizeof(T*), \"No hash implementation found for this type\");\n"
"                // This is to avoid the return type being deduced as 'void' and creating further errors.\n"
"                return HashCode64(0);\n"
"            }\n"
"        }\n"
"    };\n"
"\n"
"    // Specializations for float and double which hash 0 and -0 to distinct values\n"
"    template<>\n"
"    struct Hash<float> : BitCastHash<float, uint32_t> {};\n"
"    template<>\n"
"    struct Hash<double> : BitCastHash<double, uint64_t> {};\n"
"\n"
"    //\n"
"    // Utility functions for using hashes\n"
"    //\n"
"\n"
"    // A wrapper for Hash<TKey>\n"
"\ttemplate<typename TKey>\n"
"\tauto getHashCode(const TKey& key)\n"
"\t{\n"
"        return Hash<TKey>{}(key);\n"
"\t}\n"
"\n"
"\tinline HashCode64 getHashCode(const char* buffer, std::size_t len)\n"
"\t{\n"
"        return ankerl::unordered_dense::detail::wyhash::hash(buffer, len);\n"
"\t}\n"
"\n"
"    template<typename T>\n"
"    HashCode64 hashObjectBytes(const T& t)\n"
"    {\n"
"        static_assert(std::has_unique_object_representations_v<T>,\n"
"            \"This type must have a unique object representation to use hashObjectBytes\");\n"
"        return getHashCode(reinterpret_cast<const char*>(&t), sizeof(t));\n"
"    }\n"
"\n"
"    // Use in a struct to declare a uniform hash which doens't care about the\n"
"    // structure of the members.\n"
"#   define SLANG_BYTEWISE_HASHABLE \\\n"
"        static constexpr bool kHasUniformHash = true; \\\n"
"        ::Slang::HashCode64 getHashCode() const \\\n"
"        { \\\n"
"            return ::Slang::hashObjectBytes(*this); \\\n"
"        }\n"
"\n"
"#   define SLANG_COMPONENTWISE_HASHABLE_1 \\\n"
"        auto getHashCode() const \\\n"
"        { \\\n"
"            const auto& [m1] = *this; \\\n"
"            return Slang::getHashCode(m1); \\\n"
"        }\n"
"\n"
"#   define SLANG_COMPONENTWISE_HASHABLE_2 \\\n"
"        auto getHashCode() const \\\n"
"        { \\\n"
"            const auto& [m1, m2] = *this; \\\n"
"            return combineHash(::Slang::getHashCode(m1), ::Slang::getHashCode(m2)); \\\n"
"        }\n"
"\n"
"    inline HashCode64 combineHash(HashCode64 h)\n"
"    {\n"
"        return h;\n"
"    }\n"
"\n"
"    inline HashCode32 combineHash(HashCode32 h)\n"
"    {\n"
"        return h;\n"
"    }\n"
"\n"
"    // A left fold of a mixing operation\n"
"    template<typename H1, typename H2, typename... Hs>\n"
"    auto combineHash(H1 n, H2 m, Hs... args)\n"
"    {\n"
"        // TODO: restrict the types here more, currently we tend to throw\n"
"        // unhashed integers in here along with proper hashes of objects.\n"
"        static_assert(std::is_convertible_v<H1, HashCode64> || std::is_convertible_v<H1, HashCode32>);\n"
"        static_assert(std::is_convertible_v<H2, HashCode64> || std::is_convertible_v<H2, HashCode32>);\n"
"        return combineHash((n * 16777619) ^ m, args...);\n"
"    }\n"
"\n"
"    struct Hasher\n"
"    {\n"
"    public:\n"
"        Hasher() {}\n"
"\n"
"            /// Hash the given `value` and combine it into this hash state\n"
"        template<typename T>\n"
"        void hashValue(T const& value)\n"
"        {\n"
"            // TODO: Eventually, we should replace `getHashCode`\n"
"            // with a \"hash into\" operation that takes the value\n"
"            // and a `Hasher`.\n"
"\n"
"            m_hashCode = combineHash(m_hashCode, getHashCode(value));\n"
"        }\n"
"\n"
"            /// Combine the given `hash` code into the hash state.\n"
"            ///\n"
"            /// Note: users should prefer to use `hashValue` or `hashObject`\n"
"            /// when possible, as they may be able to ensure a higher-quality\n"
"            /// hash result (e.g., by using more bits to represent the state\n"
"            /// during hashing than are used for the final hash code).\n"
"            ///\n"
"        void addHash(HashCode hash)\n"
"        {\n"
"            m_hashCode = combineHash(m_hashCode, hash);\n"
"        }\n"
"\n"
"        HashCode getResult() const\n"
"        {\n"
"            return m_hashCode;\n"
"        }\n"
"\n"
"    private:\n"
"        HashCode m_hashCode = 0;\n"
"    };\n"
"}\n"
"\n"
"#endif\n"
"\n"
"#ifndef SLANG_CORE_TYPE_TRAITS_H\n"
"#define SLANG_CORE_TYPE_TRAITS_H\n"
"\n"
"namespace Slang\n"
"{\n"
"\tstruct TraitResultYes\n"
"\t{\n"
"\t\tchar x;\n"
"\t};\n"
"\tstruct TraitResultNo\n"
"\t{\n"
"\t\tchar x[2];\n"
"\t};\n"
"\n"
"\ttemplate <typename B, typename D>\n"
"\tstruct IsBaseOfTraitHost\n"
"\t{\n"
"\t\toperator B*() const { return nullptr; }\n"
"\t\toperator D*() { return nullptr; }\n"
"\t};\n"
"\n"
"\ttemplate <typename B, typename D>\n"
"\tstruct IsBaseOf\n"
"\t{\n"
"\t\ttemplate <typename T>\n"
"\t\tstatic TraitResultYes Check(D*, T) { return TraitResultYes(); }\n"
;
sb << 
"\t\tstatic TraitResultNo Check(B*, int) { return TraitResultNo(); }\n"
"\t\tenum { Value = sizeof(Check(IsBaseOfTraitHost<B, D>(), int())) == sizeof(TraitResultYes) };\n"
"\t};\n"
"\n"
"\ttemplate<bool B, class T = void>\n"
"\tstruct EnableIf {};\n"
"\n"
"\ttemplate<class T>\n"
"\tstruct EnableIf<true, T> { typedef T type; };\n"
"\n"
"\ttemplate <typename B, typename D>\n"
"\tstruct IsConvertible\n"
"\t{\n"
"\t\tstatic TraitResultYes Use(B) { return TraitResultYes(); };\n"
"\t\tstatic TraitResultNo Use(...) { return TraitResultNo(); };\n"
"\t\tenum { Value = sizeof(Use(*(D*)(nullptr))) == sizeof(TraitResultYes) };\n"
"\t};\n"
"}\n"
"\n"
"#endif\n"
"\n"
"\n"
"\n"
"namespace Slang\n"
"{\n"
"    // Base class for all reference-counted objects\n"
"    class SLANG_RT_API RefObject\n"
"    {\n"
"    private:\n"
"        UInt referenceCount;\n"
"\n"
"    public:\n"
"        RefObject()\n"
"            : referenceCount(0)\n"
"        {}\n"
"\n"
"        RefObject(const RefObject &)\n"
"            : referenceCount(0)\n"
"        {}\n"
"\n"
"        RefObject& operator=(const RefObject&) { return *this; }\n"
"\n"
"        virtual ~RefObject()\n"
"        {}\n"
"\n"
"        UInt addReference()\n"
"        {\n"
"            return ++referenceCount;\n"
"        }\n"
"\n"
"        UInt decreaseReference()\n"
"        {\n"
"            return --referenceCount;\n"
"        }\n"
"\n"
"        UInt releaseReference()\n"
"        {\n"
"            SLANG_ASSERT(referenceCount != 0);\n"
"            if(--referenceCount == 0)\n"
"            {\n"
"                delete this;\n"
"                return 0;\n"
"            }\n"
"            return referenceCount;\n"
"        }\n"
"\n"
"        bool isUniquelyReferenced()\n"
"        {\n"
"            SLANG_ASSERT(referenceCount != 0);\n"
"            return referenceCount == 1;\n"
"        }\n"
"\n"
"        UInt debugGetReferenceCount()\n"
"        {\n"
"            return referenceCount;\n"
"        }\n"
"    };\n"
"\n"
"    SLANG_FORCE_INLINE void addReference(RefObject* obj)\n"
"    {\n"
"        if(obj) obj->addReference();\n"
"    }\n"
"\n"
"    SLANG_FORCE_INLINE void releaseReference(RefObject* obj)\n"
"    {\n"
"        if(obj) obj->releaseReference();\n"
"    }\n"
"\n"
"    // For straight dynamic cast.\n"
"    // Use instead of dynamic_cast as it allows for replacement without using Rtti in the future\n"
"    template <typename T>\n"
"    SLANG_FORCE_INLINE T* dynamicCast(RefObject* obj) { return dynamic_cast<T*>(obj); }\n"
"    template <typename T>\n"
"    SLANG_FORCE_INLINE const T* dynamicCast(const RefObject* obj) { return dynamic_cast<const T*>(obj); }\n"
"\n"
"    // Like a dynamicCast, but allows a type to implement a specific implementation that is suitable for it\n"
"    template <typename T>\n"
"    SLANG_FORCE_INLINE T* as(RefObject* obj) { return dynamicCast<T>(obj); }\n"
"    template <typename T>\n"
"    SLANG_FORCE_INLINE const T* as(const RefObject* obj) { return dynamicCast<T>(obj); }\n"
"\n"
"    // \"Smart\" pointer to a reference-counted object\n"
"    template<typename T> struct SLANG_RT_API RefPtr\n"
"    {\n"
"        RefPtr()\n"
"            : pointer(nullptr)\n"
"        {}\n"
"\n"
"        RefPtr(T* p)\n"
"            : pointer(p)\n"
"        {\n"
"            addReference(p);\n"
"        }\n"
"\n"
"        RefPtr(RefPtr<T> const& p)\n"
"            : pointer(p.pointer)\n"
"        {\n"
"            addReference(p.pointer);\n"
"        }\n"
"\n"
"        RefPtr(RefPtr<T>&& p)\n"
"            : pointer(p.pointer)\n"
"        {\n"
"            p.pointer = nullptr;\n"
"        }\n"
"\n"
"        template <typename U>\n"
"        RefPtr(RefPtr<U> const& p,\n"
"            typename EnableIf<IsConvertible<T*, U*>::Value, void>::type * = 0)\n"
"            : pointer(static_cast<U*>(p))\n"
"        {\n"
"            addReference(static_cast<U*>(p));\n"
"        }\n"
"\n"
"#if 0\n"
"        void operator=(T* p)\n"
"        {\n"
"            T* old = pointer;\n"
"            addReference(p);\n"
"            pointer = p;\n"
"            releaseReference(old);\n"
"        }\n"
"#endif\n"
"\n"
"        void operator=(RefPtr<T> const& p)\n"
"        {\n"
"            T* old = pointer;\n"
"            addReference(p.pointer);\n"
"            pointer = p.pointer;\n"
"            releaseReference(old);\n"
"        }\n"
"\n"
"        void operator=(RefPtr<T>&& p)\n"
"        {\n"
"            T* old = pointer;\n"
"            pointer = p.pointer;\n"
"            p.pointer = old;\n"
"        }\n"
"\n"
"        template <typename U>\n"
"        typename EnableIf<IsConvertible<T*, U*>::value, void>::type\n"
"            operator=(RefPtr<U> const& p)\n"
"        {\n"
"            T* old = pointer;\n"
"            addReference(p.pointer);\n"
"            pointer = p.pointer;\n"
"            releaseReference(old);\n"
"        }\n"
"\n"
"        HashCode getHashCode() const\n"
"        {\n"
"            // Note: We need a `RefPtr<T>` to hash the same as a `T*`,\n"
"            // so that a `T*` can be used as a key in a dictionary with\n"
"            // `RefPtr<T>` keys, and vice versa.\n"
"            //\n"
"            return Slang::getHashCode(pointer);\n"
"        }\n"
"\n"
"        bool operator==(const T * ptr) const\n"
"        {\n"
"            return pointer == ptr;\n"
"        }\n"
"\n"
"        bool operator!=(const T * ptr) const\n"
"        {\n"
"            return pointer != ptr;\n"
"        }\n"
"\n"
"\t\tbool operator==(RefPtr<T> const& ptr) const\n"
"\t\t{\n"
"\t\t\treturn pointer == ptr.pointer;\n"
"\t\t}\n"
"\n"
"\t\tbool operator!=(RefPtr<T> const& ptr) const\n"
"\t\t{\n"
"\t\t\treturn pointer != ptr.pointer;\n"
"\t\t}\n"
"\n"
"        template<typename U>\n"
"        RefPtr<U> dynamicCast() const\n"
"        {\n"
"            return RefPtr<U>(Slang::dynamicCast<U>(pointer));\n"
"        }\n"
"\n"
"        template<typename U>\n"
"        RefPtr<U> as() const\n"
"        {\n"
"            return RefPtr<U>(Slang::as<U>(pointer));\n"
"        }\n"
"\n"
"        template <typename U>\n"
"        bool is() const { return Slang::as<U>(pointer) != nullptr; }\n"
"\n"
"        ~RefPtr()\n"
"        {\n"
"            releaseReference(static_cast<Slang::RefObject*>(pointer));\n"
"        }\n"
"\n"
"        T& operator*() const\n"
"        {\n"
"            return *pointer;\n"
"        }\n"
"\n"
"        T* operator->() const\n"
"        {\n"
"            return pointer;\n"
"        }\n"
"\n"
"\t\tT * Ptr() const\n"
"\t\t{\n"
"\t\t\treturn pointer;\n"
"\t\t}\n"
"\n"
"        T* get() const\n"
"        {\n"
"            return pointer;\n"
"        }\n"
"\n"
"        operator T*() const\n"
"        {\n"
"            return pointer;\n"
"        }\n"
"\n"
"        void attach(T* p)\n"
"        {\n"
"            T* old = pointer;\n"
"            pointer = p;\n"
"            releaseReference(old);\n"
"        }\n"
"\n"
"        T* detach()\n"
"        {\n"
"            auto rs = pointer;\n"
"            pointer = nullptr;\n"
"            return rs;\n"
"        }\n"
"\n"
"        void swapWith(RefPtr<T>& rhs)\n"
"        {\n"
"            auto rhsPtr = rhs.pointer;\n"
"            rhs.pointer = pointer;\n"
"            pointer = rhsPtr;\n"
"        }\n"
"\n"
"        SLANG_FORCE_INLINE void setNull()\n"
"        {\n"
"            releaseReference(pointer);\n"
"            pointer = nullptr;\n"
"        }\n"
"\n"
"        /// Get ready for writing (nulls contents)\n"
"        SLANG_FORCE_INLINE T** writeRef() { *this = nullptr; return &pointer; }\n"
"\n"
"        /// Get for read access\n"
"        SLANG_FORCE_INLINE T*const* readRef() const { return &pointer; }\n"
"\n"
"    private:\n"
"        T* pointer;\n"
"\t};\n"
"\n"
"    // Helper type for implementing weak pointers. The object being pointed at weakly creates a WeakSink object\n"
"    // that other objects can reference and share. When the object is destroyed it detaches the sink\n"
"    // doing so will make other users call to 'get' return null. Thus any user of the WeakSink, must check if the weakly pointed to\n"
"    // things pointer is nullptr before using.\n"
"    template <typename T>\n"
"    class WeakSink : public RefObject\n"
"    {\n"
"    public:\n"
"        WeakSink(T* ptr):\n"
"            m_ptr(ptr)\n"
"        {\n"
"        }\n"
"\n"
"        SLANG_FORCE_INLINE T* get() const { return m_ptr; }\n"
"        SLANG_FORCE_INLINE void detach() { m_ptr = nullptr; }\n"
"\n"
"    private:\n"
"        T* m_ptr;\n"
"    };\n"
"\n"
"    // A pointer that can be transformed to hold either a weak reference or a strong reference.\n"
"    template<typename T>\n"
"    class TransformablePtr\n"
"    {\n"
"    private:\n"
"        T* m_weakPtr = nullptr;\n"
"        RefPtr<T> m_strongPtr;\n"
"\n"
"    public:\n"
"        TransformablePtr() = default;\n"
"        TransformablePtr(T* ptr) { *this = ptr; }\n"
"        TransformablePtr(RefPtr<T> ptr) { *this = ptr; }\n"
"        TransformablePtr(const TransformablePtr<T>& ptr) = default;\n"
"        TransformablePtr<T>& operator=(const TransformablePtr<T>& ptr) = default;\n"
"\n"
"        void promoteToStrongReference() { m_strongPtr = m_weakPtr; }\n"
"        void demoteToWeakReference() { m_strongPtr = nullptr; }\n"
"        bool isStrongReference() const { return m_strongPtr != nullptr; }\n"
"\n"
"        T& operator*() const { return *m_weakPtr; }\n"
"\n"
"        T* operator->() const { return m_weakPtr; }\n"
"\n"
"        T* Ptr() const { return m_weakPtr; }\n"
"        T* get() const { return m_weakPtr; }\n"
"\n"
"        operator T*() const { return m_weakPtr; }\n"
"        operator RefPtr<T>() const { return m_weakPtr; }\n"
"\n"
"\n"
"        TransformablePtr<T>& operator=(T* ptr)\n"
"        {\n"
"            m_weakPtr = ptr;\n"
"            m_strongPtr = ptr;\n"
"            return *this;\n"
"        }\n"
"        template<typename U>\n"
"        TransformablePtr<T>& operator=(const RefPtr<U>& ptr)\n"
"        {\n"
"            m_weakPtr = ptr.Ptr();\n"
"            m_strongPtr = ptr;\n"
"            return *this;\n"
"        }\n"
"        \n"
"        HashCode getHashCode() const\n"
"        {\n"
"            // Note: We need a `RefPtr<T>` to hash the same as a `T*`,\n"
"            // so that a `T*` can be used as a key in a dictionary with\n"
"            // `RefPtr<T>` keys, and vice versa.\n"
"            //\n"
"            return Slang::getHashCode(m_weakPtr);\n"
"        }\n"
"\n"
"        bool operator==(const T* ptr) const { return m_weakPtr == ptr; }\n"
"\n"
"        bool operator!=(const T* ptr) const { return m_weakPtr != ptr; }\n"
"\n"
"        bool operator==(RefPtr<T> const& ptr) const { return m_weakPtr == ptr.Ptr(); }\n"
"\n"
"        bool operator!=(RefPtr<T> const& ptr) const { return m_weakPtr != ptr.Ptr(); }\n"
"\n"
"        bool operator==(TransformablePtr<T> const& ptr) const { return m_weakPtr == ptr.m_weakPtr; }\n"
"\n"
"        bool operator!=(TransformablePtr<T> const& ptr) const { return m_weakPtr != ptr.m_weakPtr; }\n"
"    };\n"
"}\n"
"#endif\n"
"\n"
"#ifndef _MSC_VER\n"
"#ifndef SLANG_CORE_SECURE_CRT_H\n"
"#define SLANG_CORE_SECURE_CRT_H\n"
"#include <stdarg.h>\n"
"#include <stdio.h>\n"
"#include <stdlib.h>\n"
"#include <string.h>\n"
"#include <strings.h>\n"
"#include <assert.h>\n"
"\n"
"#include <wchar.h>\n"
"\n"
"inline void slang_memcpy_s(void *dest, [[maybe_unused]] size_t destSize, const void * src, size_t count)\n"
"{\n"
"    assert(destSize >= count);\n"
"    memcpy(dest, src, count);\n"
"}\n"
"\n"
"#define _TRUNCATE ((size_t)-1)\n"
"#define _stricmp strcasecmp\n"
"\n"
"inline void slang_fopen_s(FILE**f, const char * fileName, const char * mode)\n"
"{\n"
"\t*f = fopen(fileName, mode);\n"
"}\n"
"\n"
"inline size_t slang_fread_s(void * buffer, [[maybe_unused]] size_t bufferSize, size_t elementSize, size_t count, FILE * stream)\n"
"{\n"
"    assert(bufferSize >= elementSize * count);\n"
"    return fread(buffer, elementSize, count, stream);\n"
"}\n"
"\n"
"inline size_t slang_wcsnlen_s(const wchar_t * str, size_t /*numberofElements*/)\n"
"{\n"
"\treturn wcslen(str);\n"
"}\n"
"\n"
"inline size_t slang_strnlen_s(const char * str, size_t numberOfElements)\n"
"{\n"
"#if defined( __CYGWIN__ )\n"
"    const char* cur = str;\n"
"    if (str)\n"
"    {\n"
"        const char*const end = str + numberOfElements;\n"
"        while (*cur && cur < end) cur++;\n"
"    }\n"
"    return size_t(cur - str);\n"
"#else\n"
"\treturn strnlen(str, numberOfElements);\n"
"#endif\n"
"}\n"
"\n"
"__attribute__((format(printf, 3, 4)))\n"
"inline int slang_sprintf_s(char * buffer, size_t sizeOfBuffer, const char * format, ...)\n"
"{\n"
"\tva_list argptr;\n"
"\tva_start(argptr, format);\n"
"\tint rs = vsnprintf(buffer, sizeOfBuffer, format, argptr);\n"
"\tva_end(argptr);\n"
"\treturn rs;\n"
"}\n"
"\n"
"// A patch was submitted to GCC wchar_t support in 2001, so I'm sure we can\n"
"// enable this any day now...\n"
"// __attribute__((format(wprintf, 3, 4)))\n"
"inline int slang_swprintf_s(wchar_t * buffer, size_t sizeOfBuffer, const wchar_t * format, ...)\n"
"{\n"
"\tva_list argptr;\n"
"\tva_start(argptr, format);\n"
"\tint rs = vswprintf(buffer, sizeOfBuffer, format, argptr);\n"
"\tva_end(argptr);\n"
"\treturn rs;\n"
"}\n"
"\n"
"inline void slang_wcscpy_s(wchar_t * strDestination, size_t /*numberOfElements*/, const wchar_t * strSource)\n"
"{\n"
"\twcscpy(strDestination, strSource);\n"
"}\n"
"inline void slang_strcpy_s(char * strDestination, size_t /*numberOfElements*/, const char * strSource)\n"
"{\n"
"\tstrcpy(strDestination, strSource);\n"
"}\n"
"\n"
"inline void slang_wcsncpy_s(wchar_t * strDestination, size_t /*numberOfElements*/, const wchar_t * strSource, size_t count)\n"
"{\n"
"\twcsncpy(strDestination, strSource, count);\n"
"}\n"
"inline void slang_strncpy_s(char * strDestination, size_t /*numberOfElements*/, const char * strSource, size_t count)\n"
"{\n"
"\tstrncpy(strDestination, strSource, count);\n"
"}\n"
"\n"
"#define memcpy_s slang_memcpy_s\n"
"#define fopen_s slang_fopen_s\n"
"#define fread_s slang_fread_s\n"
"#define wcsnlen_s slang_wcsnlen_s\n"
"#define strnlen_s slang_strnlen_s\n"
"#define swprintf_s slang_swprintf_s\n"
"#define wcscpy_s slang_wcscpy_s\n"
"#define strcpy_s slang_strcpy_s\n"
"#define wcsncpy_s slang_wcsncpy_s\n"
"#define strncpy_s slang_strncpy_s\n"
"#define sprintf_s slang_sprintf_s\n"
"\n"
"#endif\n"
"#endif\n"
"\n"
"#pragma once\n"
"\n"
"#include <cstdint>\n"
"#include <cstring>\n"
"#include <type_traits>\n"
"\n"
"namespace Slang\n"
"{\n"
"    //\n"
"    // Types\n"
"    //\n"
"\n"
"    struct StableHashCode64\n"
"    {\n"
"        uint64_t hash;\n"
"        explicit operator uint64_t() const { return hash; }\n"
"        bool operator==(StableHashCode64 other) const { return other.hash == hash; };\n"
"        bool operator!=(StableHashCode64 other) const { return other.hash != hash; };\n"
"    };\n"
"\n"
"    struct StableHashCode32\n"
"    {\n"
"        uint32_t hash;\n"
"        explicit operator uint32_t() const { return hash; }\n"
"        bool operator==(StableHashCode32 other) const { return other.hash == hash; };\n"
"        bool operator!=(StableHashCode32 other) const { return other.hash != hash; };\n"
"    };\n"
"\n"
"    /* The 'Stable' hash code functions produce hashes that must be\n"
"\n"
"    * The same result for the same inputs on all targets\n"
"    * Rarely change - as their values can change the output of the Slang API/Serialization\n"
"\n"
"    Hash value used from the 'Stable' functions can also be used as part of serialization -\n"
"    so it is in effect part of the API.\n"
"\n"
"    In effect this means changing a 'Stable' algorithm will typically require doing a new release.\n"
"    */\n"
"    inline StableHashCode64 getStableHashCode64(const char* buffer, size_t numChars)\n"
"    {\n"
"        uint64_t hash = 0;\n"
"        for (size_t i = 0; i < numChars; ++i)\n"
"        {\n"
"            hash = uint64_t(buffer[i]) + (hash << 6) + (hash << 16) - hash;\n"
"        }\n"
"        return StableHashCode64{hash};\n"
"    }\n"
"\n"
"    template<typename T>\n"
"    inline StableHashCode64 getStableHashCode64(const T& t)\n"
"    {\n"
"        static_assert(std::has_unique_object_representations_v<T>);\n"
"        return getStableHashCode64(reinterpret_cast<const char*>(&t), sizeof(T));\n"
"    }\n"
"\n"
"    inline StableHashCode32 getStableHashCode32(const char* buffer, size_t numChars)\n"
"    {\n"
"        uint32_t hash = 0;\n"
"        for (size_t i = 0; i < numChars; ++i)\n"
"        {\n"
"            hash = uint32_t(buffer[i]) + (hash << 6) + (hash << 16) - hash;\n"
"        }\n"
"        return StableHashCode32{hash};\n"
"    }\n"
"\n"
"    template<typename T>\n"
"    inline StableHashCode32 getStableHashCode32(const T& t)\n"
"    {\n"
"        static_assert(std::has_unique_object_representations_v<T>);\n"
"        return getStableHashCode32(reinterpret_cast<const char*>(&t), sizeof(T));\n"
"    }\n"
"\n"
"    inline StableHashCode64 combineStableHash(StableHashCode64 h)\n"
"    {\n"
"        return h;\n"
"    }\n"
"\n"
"    inline StableHashCode32 combineStableHash(StableHashCode32 h)\n"
"    {\n"
"        return h;\n"
"    }\n"
"\n"
"    // A left fold with a mixing operation\n"
"    template<typename H, typename... Hs>\n"
"    H combineStableHash(H n, H m, Hs... args)\n"
"    {\n"
"        return combineStableHash(H{(n.hash * 16777619) ^ m.hash}, args...);\n"
"    }\n"
"}\n"
"\n"
"// > Please draw a small horse in ASCII art:\n"
"//\n"
"//           ,~~.\n"
"//          (  9 )-_,\n"
"//  (\\___ )=='-' )\n"
"//   \\ .   ) )  /\n"
"//    \\ `-' /  /\n"
"// ~'`~'`~'`~'`~\n"
"//\n"
"\n"
"\n"
"#include <new>\n"
"#include <type_traits>\n"
"\n"
"namespace Slang\n"
"{\n"
"    class _EndLine\n"
"    {};\n"
"    extern _EndLine EndLine;\n"
"\n"
"    // in-place reversion, works only for ascii string\n"
"    inline void reverseInplaceAscii(char* buffer, int length)\n"
"    {\n"
"        int i, j;\n"
"        char c;\n"
"        for (i = 0, j = length - 1; i<j; i++, j--)\n"
"        {\n"
"            c = buffer[i];\n"
"            buffer[i] = buffer[j];\n"
"            buffer[j] = c;\n"
"        }\n"
"    }\n"
"    template<typename IntType>\n"
"    inline int intToAscii(char* buffer, IntType val, int radix, int padTo = 0)\n"
"    {\n"
"        static_assert(std::is_integral_v<IntType>);\n"
"\n"
"        int i = 0;\n"
"        IntType sign;\n"
"        \n"
"        sign = val;\n"
"        if (sign < 0)\n"
"        {\n"
"            val = (IntType)(0 - val);\n"
"        }\n"
"\n"
"        do\n"
"        {\n"
"            int digit = (val % radix);\n"
"            if (digit <= 9)\n"
"                buffer[i++] = (char)(digit + '0');\n"
"            else\n"
"                buffer[i++] = (char)(digit - 10 + 'A');\n"
"        } while ((val /= radix) > 0);\n"
"\n"
"        SLANG_ASSERT(i >= 0);\n"
"        while(i < padTo)\n"
"            buffer[i++] = '0';\n"
"\n"
"        if (sign < 0)\n"
"            buffer[i++] = '-';\n"
"\n"
"        // Put in normal character order\n"
"        reverseInplaceAscii(buffer, i);\n"
"\n"
"        buffer[i] = '\\0';\n"
"        return i;\n"
"    }\n"
"\n"
"    SLANG_FORCE_INLINE bool isUtf8LeadingByte(char ch)\n"
"    {\n"
"        return (((unsigned char)ch) & 0xC0) == 0xC0;\n"
"    }\n"
"\n"
"    SLANG_FORCE_INLINE bool isUtf8ContinuationByte(char ch)\n"
"    {\n"
"        return (((unsigned char)ch) & 0xC0) == 0x80;\n"
"    }\n"
"\n"
"    /* A string slice that doesn't own the contained characters.\n"
"    It is the responsibility of code using the type to keep the memory backing \n"
"    the slice in scope.\n"
"    A slice is generally *not* zero terminated. */\n"
;
sb << 
"    struct SLANG_RT_API UnownedStringSlice\n"
"    {\n"
"    public:\n"
"        typedef UnownedStringSlice ThisType;\n"
"\n"
"            // Type to indicate that a ctor is with a length to disabmiguate 0/nullptr \n"
"            // causing ambiguity.\n"
"        struct WithLength {};\n"
"\n"
"        UnownedStringSlice()\n"
"            : m_begin(nullptr)\n"
"            , m_end(nullptr)\n"
"        {}\n"
"\n"
"        explicit UnownedStringSlice(char const* a) :\n"
"            m_begin(a),\n"
"            m_end(a ? a + strlen(a) : nullptr)\n"
"        {}\n"
"        UnownedStringSlice(char const* b, char const* e)\n"
"            : m_begin(b)\n"
"            , m_end(e)\n"
"        {}\n"
"        UnownedStringSlice(char const* b, size_t len)\n"
"            : m_begin(b)\n"
"            , m_end(b + len)\n"
"        {}\n"
"        UnownedStringSlice(WithLength, char const* b, size_t len)\n"
"            : m_begin(b)\n"
"            , m_end(b + len)\n"
"        {}\n"
"\n"
"        SLANG_FORCE_INLINE char const* begin() const { return m_begin; }\n"
"\n"
"        SLANG_FORCE_INLINE char const* end() const { return m_end; }\n"
"\n"
"            /// True if slice is strictly contained in memory.\n"
"        bool isMemoryContained(const UnownedStringSlice& slice) const\n"
"        {\n"
"            return slice.m_begin >= m_begin && slice.m_end <= m_end; \n"
"        }\n"
"        bool isMemoryContained(const char* pos) const\n"
"        {\n"
"            return pos >= m_begin && pos <= m_end;\n"
"        }\n"
"\n"
"            /// Get the length in *bytes*\n"
"        Count getLength() const { return Index(m_end - m_begin); }\n"
"\n"
"            /// Finds first index of char 'c'. If not found returns -1.\n"
"        Index indexOf(char c) const;\n"
"            /// Find first index of slice. If not found returns -1\n"
"        Index indexOf(const UnownedStringSlice& slice) const;\n"
"\n"
"            /// Returns a substring. idx is the start index, and len\n"
"            /// is the amount of characters.\n"
"            /// The returned length might be truncated, if len extends beyond slice.\n"
"        UnownedStringSlice subString(Index idx, Index len) const;\n"
"\n"
"            /// Return a head of the slice - everything up to the index\n"
"        SLANG_FORCE_INLINE UnownedStringSlice head(Index idx) const { SLANG_ASSERT(idx >= 0 && idx <= getLength()); return UnownedStringSlice(m_begin, idx); }\n"
"            /// Return a tail of the slice - everything from the index to the end of the slice\n"
"        SLANG_FORCE_INLINE UnownedStringSlice tail(Index idx) const { SLANG_ASSERT(idx >= 0 && idx <= getLength()); return UnownedStringSlice(m_begin + idx, m_end); }\n"
"\n"
"            /// True if rhs and this are equal without having to take into account case\n"
"            /// Note 'case' here is *not* locale specific - it is only A-Z and a-z\n"
"        bool caseInsensitiveEquals(const ThisType& rhs) const;\n"
"\n"
"        Index lastIndexOf(char c) const\n"
"        {\n"
"            const Index size = Index(m_end - m_begin);\n"
"            for (Index i = size - 1; i >= 0; --i)\n"
"            {\n"
"                if (m_begin[i] == c)\n"
"                {\n"
"                    return i;\n"
"                }\n"
"            }\n"
"            return -1;\n"
"        }\n"
"\n"
"        const char& operator[](Index i) const\n"
"        {\n"
"            assert(i >= 0 && i < Index(m_end - m_begin));\n"
"            return m_begin[i];\n"
"        }\n"
"\n"
"        bool operator==(ThisType const& other) const;\n"
"        bool operator!=(UnownedStringSlice const& other) const { return !(*this == other);  }\n"
"\n"
"        bool operator==(char const* str) const { return (*this) == UnownedStringSlice(str); }\n"
"        bool operator!=(char const* str) const { return !(*this == str); }\n"
"\n"
"            /// True if contents is a single char of c\n"
"        SLANG_FORCE_INLINE bool isChar(char c) const { return getLength() == 1 && m_begin[0] == c; }\n"
"\n"
"        bool startsWithCaseInsensitive(UnownedStringSlice const& other) const;\n"
"        bool startsWith(UnownedStringSlice const& other) const;\n"
"        bool startsWith(char const* str) const;\n"
"\n"
"        bool endsWithCaseInsensitive(UnownedStringSlice const& other) const;\n"
"        bool endsWithCaseInsensitive(char const* str) const;\n"
"\n"
"        bool endsWith(UnownedStringSlice const& other) const;\n"
"        bool endsWith(char const* str) const;\n"
"\n"
"            /// Trims any horizontal whitespace from the start and end and returns as a substring \n"
"        UnownedStringSlice trim() const;\n"
"            /// Trims any 'c' from the start or the end, and returns as a substring\n"
"        UnownedStringSlice trim(char c) const;\n"
"\n"
"            /// Trims any horizonatl whitespace from start and returns as a substring\n"
"        UnownedStringSlice trimStart() const;\n"
"\n"
"        static constexpr bool kHasUniformHash = true;\n"
"        HashCode64 getHashCode() const\n"
"        {\n"
"            return Slang::getHashCode(m_begin, size_t(m_end - m_begin)); \n"
"        }\n"
"\n"
"        template <size_t SIZE> \n"
"        SLANG_FORCE_INLINE static UnownedStringSlice fromLiteral(const char (&in)[SIZE]) { return UnownedStringSlice(in, SIZE - 1); }\n"
"\n"
"    protected:\n"
"\n"
"        char const* m_begin;\n"
"        char const* m_end;\n"
"    };\n"
"\n"
"    // A more convenient way to make slices from *string literals*\n"
"    template <size_t SIZE>\n"
"    SLANG_FORCE_INLINE UnownedStringSlice toSlice(const char (&in)[SIZE]) { return UnownedStringSlice(in, SIZE - 1); }\n"
"\n"
"    /// Same as UnownedStringSlice, but must be zero terminated. \n"
"    /// Zero termination is *not* included in the length.\n"
"    struct SLANG_RT_API UnownedTerminatedStringSlice : public UnownedStringSlice\n"
"    {\n"
"    public:\n"
"        typedef UnownedStringSlice Super;\n"
"        typedef UnownedTerminatedStringSlice ThisType;\n"
"\n"
"            /// We can turn into a regular zero terminated string\n"
"        SLANG_FORCE_INLINE operator const char*() const { return m_begin; }\n"
"\n"
"            /// Exists to match the equivalent function in String.\n"
"        SLANG_FORCE_INLINE char const* getBuffer() const { return m_begin; }\n"
"\n"
"            /// Construct from a literal directly.\n"
"        template <size_t SIZE>\n"
"        SLANG_FORCE_INLINE static ThisType fromLiteral(const char(&in)[SIZE]) { return ThisType(in, SIZE - 1); }\n"
"\n"
"            /// Default constructor\n"
"        UnownedTerminatedStringSlice():Super(Super::WithLength(), \"\", 0) {}\n"
"        \n"
"            /// Note, b cannot be null because if it were then the string would not be null terminated\n"
"        UnownedTerminatedStringSlice(char const* b)\n"
"            : Super(b, b + strlen(b))\n"
"        {}\n"
"        UnownedTerminatedStringSlice(char const* b, size_t len)\n"
"            : Super(b, len)\n"
"        {\n"
"            // b must be valid and it must be null terminated\n"
"            SLANG_ASSERT(b && b[len] == 0);\n"
"        }\n"
"    };\n"
"\n"
"    // A more convenient way to make terminated slices from *string literals*\n"
"    template <size_t SIZE>\n"
"    SLANG_FORCE_INLINE UnownedTerminatedStringSlice toTerminatedSlice(const char(&in)[SIZE]) { return UnownedTerminatedStringSlice(in, SIZE - 1); }\n"
"\n"
"    // A `StringRepresentation` provides the backing storage for\n"
"    // all reference-counted string-related types.\n"
"    class SLANG_RT_API StringRepresentation : public RefObject\n"
"    {\n"
"    public:\n"
"        Index length;\n"
"        Index capacity;\n"
"\n"
"        SLANG_FORCE_INLINE Index getLength() const\n"
"        {\n"
"            return length;\n"
"        }\n"
"\n"
"        SLANG_FORCE_INLINE char* getData()\n"
"        {\n"
"            return (char*) (this + 1);\n"
"        }\n"
"        SLANG_FORCE_INLINE const char* getData() const\n"
"        {\n"
"            return (const char*)(this + 1);\n"
"        }\n"
"\n"
"            /// Set the contents to be the slice. Must be enough capacity to hold the slice. \n"
"        void setContents(const UnownedStringSlice& slice);\n"
"\n"
"        static const char* getData(const StringRepresentation* stringRep)\n"
"        {\n"
"            return stringRep ? stringRep->getData() : \"\";\n"
"        }\n"
"\n"
"        static UnownedStringSlice asSlice(const StringRepresentation* rep)\n"
"        {\n"
"            return rep ? UnownedStringSlice(rep->getData(), rep->getLength()) : UnownedStringSlice();\n"
"        }\n"
"\n"
"        static bool equal(const StringRepresentation* a, const StringRepresentation* b)\n"
"        {\n"
"            return (a == b) || asSlice(a) == asSlice(b);\n"
"        }\n"
"\n"
"        static StringRepresentation* createWithCapacityAndLength(Index capacity, Index length)\n"
"        {\n"
"            SLANG_ASSERT(capacity >= length);\n"
"            void* allocation = operator new(sizeof(StringRepresentation) + capacity + 1);\n"
"            StringRepresentation* obj = new(allocation) StringRepresentation();\n"
"            obj->capacity = capacity;\n"
"            obj->length = length;\n"
"            obj->getData()[length] = 0;\n"
"            return obj;\n"
"        }\n"
"\n"
"        static StringRepresentation* createWithCapacity(Index capacity)\n"
"        {\n"
"            return createWithCapacityAndLength(capacity, 0);\n"
"        }\n"
"\n"
"        static StringRepresentation* createWithLength(Index length)\n"
"        {\n"
"            return createWithCapacityAndLength(length, length);\n"
"        }\n"
"\n"
"            /// Create a representation from the slice. If slice is empty will return nullptr.\n"
"        static StringRepresentation* create(const UnownedStringSlice& slice);\n"
"            /// Same as create, but representation will have refcount of 1 (if not nullptr)\n"
"        static StringRepresentation* createWithReference(const UnownedStringSlice& slice);\n"
"\n"
"        StringRepresentation* cloneWithCapacity(Index newCapacity)\n"
"        {\n"
"            StringRepresentation* newObj = createWithCapacityAndLength(newCapacity, length);\n"
"            memcpy(getData(), newObj->getData(), length + 1);\n"
"            return newObj;\n"
"        }\n"
"\n"
"        StringRepresentation* clone()\n"
"        {\n"
"            return cloneWithCapacity(length);\n"
"        }\n"
"\n"
"        StringRepresentation* ensureCapacity(Index required)\n"
"        {\n"
"            if (capacity >= required) return this;\n"
"\n"
"            Index newCapacity = capacity;\n"
"            if (!newCapacity) newCapacity = 16; // TODO: figure out good value for minimum capacity\n"
"\n"
"            while (newCapacity < required)\n"
"            {\n"
"                newCapacity = 2 * newCapacity;\n"
"            }\n"
"\n"
"            return cloneWithCapacity(newCapacity);\n"
"        }\n"
"\n"
"            /// Overload delete to silence ASAN new-delete-type-mismatch errors.\n"
"            /// These occur because the allocation size of StringRepresentation\n"
"            /// does not match deallocation size (due variable sized string payload).\n"
"        void operator delete(void* p)\n"
"        {\n"
"            StringRepresentation* str = (StringRepresentation*) p;\n"
"            ::operator delete(str);\n"
"        }        \n"
"    };\n"
"\n"
"    class String;\n"
"\n"
"    struct SLANG_RT_API StringSlice\n"
"    {\n"
"    public:\n"
"        StringSlice();\n"
"\n"
"        StringSlice(String const& str);\n"
"\n"
"        StringSlice(String const& str, UInt beginIndex, UInt endIndex);\n"
"\n"
"        UInt getLength() const\n"
"        {\n"
"            return endIndex - beginIndex;\n"
"        }\n"
"\n"
"        char const* begin() const\n"
"        {\n"
"            return representation ? representation->getData() + beginIndex : \"\";\n"
"        }\n"
"\n"
"        char const* end() const\n"
"        {\n"
"            return begin() + getLength();\n"
"        }\n"
"\n"
"    private:\n"
"        RefPtr<StringRepresentation> representation;\n"
"        UInt beginIndex;\n"
"        UInt endIndex;\n"
"\n"
"        friend class String;\n"
"\n"
"        StringSlice(RefPtr<StringRepresentation> const& representation, UInt beginIndex, UInt endIndex)\n"
"            : representation(representation)\n"
"            , beginIndex(beginIndex)\n"
"            , endIndex(endIndex)\n"
"        {}\n"
"    };\n"
"\n"
"    /// String as expected by underlying platform APIs\n"
"    class SLANG_RT_API OSString\n"
"    {\n"
"    public:\n"
"            /// Default\n"
"        OSString();\n"
"            /// NOTE! This assumes that begin is a new wchar_t[] buffer, and it will\n"
"            /// now be owned by the OSString\n"
"        OSString(wchar_t* begin, wchar_t* end);\n"
"            /// Move Ctor\n"
"        OSString(OSString&& rhs):\n"
"            m_begin(rhs.m_begin),\n"
"            m_end(rhs.m_end)\n"
"        {\n"
"            rhs.m_begin = nullptr;\n"
"            rhs.m_end = nullptr;\n"
"        }\n"
"            // Copy Ctor\n"
"        OSString(const OSString& rhs) :\n"
"            m_begin(nullptr),\n"
"            m_end(nullptr)\n"
"        {\n"
"            set(rhs.m_begin, rhs.m_end);\n"
"        }\n"
"\n"
"            /// =\n"
"        void operator=(const OSString& rhs) { set(rhs.m_begin, rhs.m_end); }\n"
"        void operator=(OSString&& rhs)\n"
"        {\n"
"            auto begin = m_begin;\n"
"            auto end = m_end;\n"
"            m_begin = rhs.m_begin;\n"
"            m_end = rhs.m_end;\n"
"            rhs.m_begin = begin;\n"
"            rhs.m_end = end;\n"
"        }\n"
"\n"
"        ~OSString() { _releaseBuffer(); }\n"
"\n"
"        size_t getLength() const { return (m_end - m_begin); }\n"
"        void set(const wchar_t* begin, const wchar_t* end);\n"
"\n"
"        operator wchar_t const*() const\n"
"        {\n"
"            return begin();\n"
"        }\n"
"\n"
"        wchar_t const* begin() const;\n"
"        wchar_t const* end() const;\n"
"\n"
"    private:\n"
"\n"
"        void _releaseBuffer();\n"
"\n"
"        wchar_t* m_begin;           ///< First character. This is a new wchar_t[] buffer\n"
"        wchar_t* m_end;             ///< Points to terminating 0\n"
"    };\n"
"\n"
"    /*!\n"
"    @brief Represents a UTF-8 encoded string.\n"
"    */\n"
"\n"
"    class SLANG_RT_API String\n"
"    {\n"
"        friend struct StringSlice;\n"
"        friend class StringBuilder;\n"
"    private:\n"
"\n"
"\n"
"        char* getData() const\n"
"        {\n"
"            return m_buffer ? m_buffer->getData() : (char*)\"\";\n"
"        }\n"
"\n"
"     \n"
"        void ensureUniqueStorageWithCapacity(Index capacity);\n"
"     \n"
"        RefPtr<StringRepresentation> m_buffer;\n"
"\n"
"    public:\n"
"\n"
"        explicit String(StringRepresentation* buffer)\n"
"            : m_buffer(buffer)\n"
"        {}\n"
"\n"
"        static String fromWString(const wchar_t* wstr);\n"
"        static String fromWString(const wchar_t* wstr, const wchar_t* wend);\n"
"        static String fromWChar(const wchar_t ch);\n"
"        static String fromUnicodePoint(Char32 codePoint);\n"
"\n"
"        String()\n"
"        {\n"
"        }\n"
"\n"
"            /// Returns a buffer which can hold at least count chars\n"
"        char* prepareForAppend(Index count);\n"
"            /// Append data written to buffer output via 'prepareForAppend' directly written 'inplace'\n"
"        void appendInPlace(const char* chars, Index count);\n"
"\n"
"            /// Get the internal string represenation\n"
"        SLANG_FORCE_INLINE StringRepresentation* getStringRepresentation() const { return m_buffer; }\n"
"\n"
"            /// Detach the representation (will leave string as empty). Rep ref count will remain unchanged.\n"
"        SLANG_FORCE_INLINE StringRepresentation* detachStringRepresentation() { return m_buffer.detach(); }\n"
"\n"
"        const char* begin() const\n"
"        {\n"
"            return getData();\n"
"        }\n"
"        const char* end() const\n"
"        {\n"
"            return getData() + getLength();\n"
"        }\n"
"\n"
"        void append(int32_t value, int radix = 10);\n"
"        void append(uint32_t value, int radix = 10);\n"
"        void append(int64_t value, int radix = 10);\n"
"        void append(uint64_t value, int radix = 10);\n"
"        void append(float val, const char* format = \"%g\");\n"
"        void append(double val, const char* format = \"%g\");\n"
"\n"
"        // Padded hex representations\n"
"        void append(StableHashCode32 val);\n"
"        void append(StableHashCode64 val);\n"
"\n"
"        void append(char const* str);\n"
"        void append(char const* str, size_t len);\n"
"        void append(const char* textBegin, char const* textEnd);\n"
"        void append(char chr);\n"
"        void append(String const& str);\n"
"        void append(StringSlice const& slice);\n"
"        void append(UnownedStringSlice const& slice);\n"
"\n"
"            /// Append a character (to remove ambiguity with other integral types)\n"
"        void appendChar(char chr);\n"
"\n"
"            /// Append the specified char count times\n"
"        void appendRepeatedChar(char chr, Index count);\n"
"\n"
"        String(const char* str)\n"
"        {\n"
"            append(str);\n"
"\n"
"        }\n"
"        String(const char* textBegin, char const* textEnd)\n"
"        {\n"
"            append(textBegin, textEnd);\n"
"        }\n"
"\n"
"        // Make all String ctors from a numeric explicit, to avoid unexpected/unnecessary conversions\n"
"        explicit String(int32_t val, int radix = 10)\n"
"        {\n"
"            append(val, radix);\n"
"        }\n"
"        explicit String(uint32_t val, int radix = 10)\n"
"        {\n"
"            append(val, radix);\n"
"        }\n"
"        explicit String(int64_t val, int radix = 10)\n"
"        {\n"
"            append(val, radix);\n"
"        }\n"
"        explicit String(uint64_t val, int radix = 10)\n"
"        {\n"
"            append(val, radix);\n"
"        }\n"
"        explicit String(StableHashCode32 val)\n"
"        {\n"
"            append(val);\n"
"        }\n"
"        explicit String(StableHashCode64 val)\n"
"        {\n"
"            append(val);\n"
"        }\n"
"        explicit String(float val, const char* format = \"%g\")\n"
"        {\n"
"            append(val, format);\n"
"        }\n"
"        explicit String(double val, const char* format = \"%g\")\n"
"        {\n"
"            append(val, format);\n"
"        }\n"
"\n"
"        explicit String(char chr)\n"
"        {\n"
"            appendChar(chr);\n"
"        }\n"
"        String(String const& str)\n"
"        {\n"
"            m_buffer = str.m_buffer;\n"
"        }\n"
;
sb << 
"        String(String&& other)\n"
"        {\n"
"            m_buffer = _Move(other.m_buffer);\n"
"        }\n"
"\n"
"        String(StringSlice const& slice)\n"
"        {\n"
"            append(slice);\n"
"        }\n"
"\n"
"        String(UnownedStringSlice const& slice)\n"
"        {\n"
"            append(slice);\n"
"        }\n"
"\n"
"        ~String()\n"
"        {\n"
"            m_buffer.setNull(); \n"
"        }\n"
"\n"
"        String& operator=(const String& str)\n"
"        {\n"
"            m_buffer = str.m_buffer;\n"
"            return *this;\n"
"        }\n"
"        String& operator=(String&& other)\n"
"        {\n"
"            m_buffer = _Move(other.m_buffer);\n"
"            return *this;\n"
"        }\n"
"        char operator[](Index id) const\n"
"        {\n"
"            SLANG_ASSERT(id >= 0 && id < getLength());\n"
"            // Silence a pedantic warning on GCC\n"
"#if __GNUC__\n"
"            if(id < 0) __builtin_unreachable();\n"
"#endif\n"
"            return begin()[id];\n"
"        }\n"
"\n"
"        Index getLength() const\n"
"        {\n"
"            return m_buffer ? m_buffer->getLength() : 0;\n"
"        }\n"
"            /// Make the length of the string the amount specified. Must be less than current size\n"
"        void reduceLength(Index length);\n"
"        \n"
"        friend String operator+(const char*op1, const String & op2);\n"
"        friend String operator+(const String & op1, const char * op2);\n"
"        friend String operator+(const String & op1, const String & op2);\n"
"\n"
"        StringSlice trimStart() const\n"
"        {\n"
"            if (!m_buffer)\n"
"                return StringSlice();\n"
"            Index startIndex = 0;\n"
"            const char*const data = getData();\n"
"            while (startIndex < getLength() &&\n"
"                (data[startIndex] == ' ' || data[startIndex] == '\\t' || data[startIndex] == '\\r' || data[startIndex] == '\\n'))\n"
"                startIndex++;\n"
"            return StringSlice(m_buffer, startIndex, getLength());\n"
"        }\n"
"\n"
"        StringSlice trimEnd() const\n"
"        {\n"
"            if (!m_buffer)\n"
"                return StringSlice();\n"
"\n"
"            Index endIndex = getLength();\n"
"            const char*const data = getData();\n"
"            while (endIndex > 0 &&\n"
"                (data[endIndex-1] == ' ' || data[endIndex-1] == '\\t' || data[endIndex-1] == '\\r' || data[endIndex-1] == '\\n'))\n"
"                endIndex--;\n"
"\n"
"            return StringSlice(m_buffer, 0, endIndex);\n"
"        }\n"
"\n"
"        StringSlice trim() const\n"
"        {\n"
"            if (!m_buffer)\n"
"                return StringSlice();\n"
"\n"
"            Index startIndex = 0;\n"
"            const char*const data = getData();\n"
"            while (startIndex < getLength() &&\n"
"                (data[startIndex] == ' ' || data[startIndex] == '\\t'))\n"
"                startIndex++;\n"
"            Index endIndex = getLength();\n"
"            while (endIndex > startIndex &&\n"
"                (data[endIndex-1] == ' ' || data[endIndex-1] == '\\t'))\n"
"                endIndex--;\n"
"\n"
"            return StringSlice(m_buffer, startIndex, endIndex);\n"
"        }\n"
"\n"
"        StringSlice subString(Index id, Index len) const\n"
"        {\n"
"            if (len == 0)\n"
"                return StringSlice();\n"
"\n"
"            if (id + len > getLength())\n"
"                len = getLength() - id;\n"
"#if _DEBUG\n"
"            if (id < 0 || id >= getLength() || (id + len) > getLength())\n"
"                SLANG_ASSERT_FAILURE(\"SubString: index out of range.\");\n"
"            if (len < 0)\n"
"                SLANG_ASSERT_FAILURE(\"SubString: length less than zero.\");\n"
"#endif\n"
"            return StringSlice(m_buffer, id, id + len);\n"
"        }\n"
"\n"
"        char const* getBuffer() const\n"
"        {\n"
"            return getData();\n"
"        }\n"
"\n"
"        OSString toWString(Index* len = 0) const;\n"
"\n"
"        bool equals(const String& str, bool caseSensitive = true)\n"
"        {\n"
"            if (caseSensitive)\n"
"                return (strcmp(begin(), str.begin()) == 0);\n"
"            else\n"
"            {\n"
"#ifdef _MSC_VER\n"
"                return (_stricmp(begin(), str.begin()) == 0);\n"
"#else\n"
"                return (strcasecmp(begin(), str.begin()) == 0);\n"
"#endif\n"
"            }\n"
"        }\n"
"        bool operator==(const char* strbuffer) const\n"
"        {\n"
"            return (strcmp(begin(), strbuffer) == 0);\n"
"        }\n"
"\n"
"        bool operator==(const String& str) const\n"
"        {\n"
"            return (strcmp(begin(), str.begin()) == 0);\n"
"        }\n"
"        bool operator!=(const char* strbuffer) const\n"
"        {\n"
"            return (strcmp(begin(), strbuffer) != 0);\n"
"        }\n"
"        bool operator!=(const String& str) const\n"
"        {\n"
"            return (strcmp(begin(), str.begin()) != 0);\n"
"        }\n"
"        bool operator>(const String& str) const\n"
"        {\n"
"            return (strcmp(begin(), str.begin()) > 0);\n"
"        }\n"
"        bool operator<(const String& str) const\n"
"        {\n"
"            return (strcmp(begin(), str.begin()) < 0);\n"
"        }\n"
"        bool operator>=(const String& str) const\n"
"        {\n"
"            return (strcmp(begin(), str.begin()) >= 0);\n"
"        }\n"
"        bool operator<=(const String& str) const\n"
"        {\n"
"            return (strcmp(begin(), str.begin()) <= 0);\n"
"        }\n"
"\n"
"        SLANG_FORCE_INLINE bool operator==(const UnownedStringSlice& slice) const { return getUnownedSlice() == slice; }\n"
"        SLANG_FORCE_INLINE bool operator!=(const UnownedStringSlice& slice) const { return getUnownedSlice() != slice; }\n"
"\n"
"        String toUpper() const\n"
"        {\n"
"            String result;\n"
"            for (auto c : *this)\n"
"            {\n"
"                char d = (c >= 'a' && c <= 'z') ? (c - ('a' - 'A')) : c;\n"
"                result.append(d);\n"
"            }\n"
"            return result;\n"
"        }\n"
"\n"
"        String toLower() const\n"
"        {\n"
"            String result;\n"
"            for (auto c : *this)\n"
"            {\n"
"                char d = (c >= 'A' && c <= 'Z') ? (c - ('A' - 'a')) : c;\n"
"                result.append(d);\n"
"            }\n"
"            return result;\n"
"        }\n"
"\n"
"        Index indexOf(const char* str, Index id) const // String str\n"
"        {\n"
"            if (id >= getLength())\n"
"                return Index(-1);\n"
"            auto findRs = strstr(begin() + id, str);\n"
"            Index res = findRs ? findRs - begin() : Index(-1);\n"
"            return res;\n"
"        }\n"
"\n"
"        Index indexOf(const String& str, Index id) const\n"
"        {\n"
"            return indexOf(str.begin(), id);\n"
"        }\n"
"\n"
"        Index indexOf(const char* str) const\n"
"        {\n"
"            return indexOf(str, 0);\n"
"        }\n"
"\n"
"        Index indexOf(const String& str) const\n"
"        {\n"
"            return indexOf(str.begin(), 0);\n"
"        }\n"
"\n"
"        void swapWith(String& other)\n"
"        {\n"
"            m_buffer.swapWith(other.m_buffer);\n"
"        }\n"
"\n"
"        Index indexOf(char ch, Index id) const\n"
"        {\n"
"            const Index length = getLength();\n"
"            SLANG_ASSERT(id >= 0 && id <= length);\n"
"\n"
"            if (!m_buffer)\n"
"                return Index(-1);\n"
"\n"
"            const char* data = getData();\n"
"            for (Index i = id; i < length; i++)\n"
"                if (data[i] == ch)\n"
"                    return i;\n"
"            return Index(-1);\n"
"        }\n"
"\n"
"        Index indexOf(char ch) const\n"
"        {\n"
"            return indexOf(ch, 0);\n"
"        }\n"
"\n"
"        Index lastIndexOf(char ch) const\n"
"        {            \n"
"            const Index length = getLength();\n"
"            const char* data = getData();\n"
"\n"
"            for (Index i = length - 1; i >= 0; --i)\n"
"                if (data[i] == ch)\n"
"                    return i;\n"
"            return Index(-1);\n"
"        }\n"
"\n"
"        bool startsWith(const char* str) const \n"
"        {\n"
"            if (!m_buffer)\n"
"                return false;\n"
"            Index strLen = Index(::strlen(str));\n"
"            if (strLen > getLength())\n"
"                return false;\n"
"\n"
"            const char*const data = getData();\n"
"\n"
"            for (Index i = 0; i < strLen; i++)\n"
"                if (str[i] != data[i])\n"
"                    return false;\n"
"            return true;\n"
"        }\n"
"\n"
"        bool startsWith(const String& str) const\n"
"        {\n"
"            return startsWith(str.begin());\n"
"        }\n"
"\n"
"        bool endsWith(char const* str)  const // String str\n"
"        {\n"
"            if (!m_buffer)\n"
"                return false;\n"
"\n"
"            const Index strLen = Index(::strlen(str));\n"
"            const Index len = getLength();\n"
"\n"
"            if (strLen > len)\n"
"                return false;\n"
"            const char* data = getData();\n"
"            for (Index i = strLen; i > 0; i--)\n"
"                if (str[i-1] != data[len - strLen + i-1])\n"
"                    return false;\n"
"            return true;\n"
"        }\n"
"\n"
"        bool endsWith(const String& str) const\n"
"        {\n"
"            return endsWith(str.begin());\n"
"        }\n"
"\n"
"        bool contains(const char* str) const // String str\n"
"        {\n"
"            return m_buffer && indexOf(str) != Index(-1); \n"
"        }\n"
"\n"
"        bool contains(const String& str) const\n"
"        {\n"
"            return contains(str.begin());\n"
"        }\n"
"\n"
"        static constexpr bool kHasUniformHash = true;\n"
"        HashCode64 getHashCode() const\n"
"        {\n"
"            return Slang::getHashCode(StringRepresentation::asSlice(m_buffer));\n"
"        }\n"
"\n"
"        UnownedStringSlice getUnownedSlice() const\n"
"        {\n"
"            return StringRepresentation::asSlice(m_buffer);\n"
"        }\n"
"    };\n"
"\n"
"    class SLANG_RT_API StringBuilder : public String\n"
"    {\n"
"    private:\n"
"        enum { InitialSize = 1024 };\n"
"    public:\n"
"        typedef String Super;\n"
"        using Super::append;\n"
"\n"
"        explicit StringBuilder(UInt bufferSize = InitialSize)\n"
"        {\n"
"            ensureUniqueStorageWithCapacity(bufferSize);\n"
"        }\n"
"\n"
"        void ensureCapacity(UInt size)\n"
"        {\n"
"            ensureUniqueStorageWithCapacity(size);\n"
"        }\n"
"        StringBuilder& operator << (char ch)\n"
"        {\n"
"            appendChar(ch);\n"
"            return *this;\n"
"        }\n"
"        StringBuilder& operator << (Int32 val)\n"
"        {\n"
"            append(val);\n"
"            return *this;\n"
"        }\n"
"        StringBuilder& operator << (UInt32 val)\n"
"        {\n"
"            append(val);\n"
"            return *this;\n"
"        }\n"
"        StringBuilder& operator << (Int64 val)\n"
"        {\n"
"            append(val);\n"
"            return *this;\n"
"        }\n"
"        StringBuilder& operator << (UInt64 val)\n"
"        {\n"
"            append(val);\n"
"            return *this;\n"
"        }\n"
"        StringBuilder& operator << (float val)\n"
"        {\n"
"            append(val);\n"
"            return *this;\n"
"        }\n"
"        StringBuilder& operator << (double val)\n"
"        {\n"
"            append(val);\n"
"            return *this;\n"
"        }\n"
"        StringBuilder& operator << (const char* str)\n"
"        {\n"
"            append(str, strlen(str));\n"
"            return *this;\n"
"        }\n"
"        StringBuilder& operator << (const String& str)\n"
"        {\n"
"            append(str);\n"
"            return *this;\n"
"        }\n"
"        StringBuilder& operator << (UnownedStringSlice const& str)\n"
"        {\n"
"            append(str);\n"
"            return *this;\n"
"        }\n"
"        StringBuilder& operator << (const _EndLine)\n"
"        {\n"
"            appendChar('\\n');\n"
"            return *this;\n"
"        }\n"
"\n"
"        String toString()\n"
"        {\n"
"            return *this;\n"
"        }\n"
"\n"
"        String produceString()\n"
"        {\n"
"            return *this;\n"
"        }\n"
"\n"
"#if 0\n"
"        void Remove(int id, int len)\n"
"        {\n"
"#if _DEBUG\n"
"            if (id >= length || id < 0)\n"
"                SLANG_ASSERT_FAILURE(\"Remove: Index out of range.\");\n"
"            if (len < 0)\n"
"                SLANG_ASSERT_FAILURE(\"Remove: remove length smaller than zero.\");\n"
"#endif\n"
"            int actualDelLength = ((id + len) >= length) ? (length - id) : len;\n"
"            for (int i = id + actualDelLength; i <= length; i++)\n"
"                buffer[i - actualDelLength] = buffer[i];\n"
"            length -= actualDelLength;\n"
"        }\n"
"#endif\n"
"        friend std::ostream& operator<< (std::ostream& stream, const String& s);\n"
"\n"
"        void clear()\n"
"        {\n"
"            m_buffer.setNull();\n"
"        }\n"
"    };\n"
"\n"
"    int stringToInt(const String& str, int radix = 10);\n"
"    unsigned int stringToUInt(const String& str, int radix = 10);\n"
"    double stringToDouble(const String& str);\n"
"    float stringToFloat(const String& str);\n"
"}\n"
"\n"
"std::ostream& operator<< (std::ostream& stream, const Slang::String& s);\n"
"\n"
"#endif\n"
"\n"
"\n"
"#if defined(_MSC_VER)\n"
"#   define SLANG_PRELUDE_SHARED_LIB_EXPORT __declspec(dllexport)\n"
"#else\n"
"#   define SLANG_PRELUDE_SHARED_LIB_EXPORT __attribute__((__visibility__(\"default\")))\n"
"//#   define SLANG_PRELUDE_SHARED_LIB_EXPORT __attribute__ ((dllexport)) __attribute__((__visibility__(\"default\")))\n"
"#endif    \n"
"\n"
"#ifdef __cplusplus    \n"
"#   define SLANG_PRELUDE_EXTERN_C extern \"C\"\n"
"#   define SLANG_PRELUDE_EXTERN_C_START extern \"C\" {\n"
"#   define SLANG_PRELUDE_EXTERN_C_END }\n"
"#else\n"
"#   define SLANG_PRELUDE_EXTERN_C \n"
"#   define SLANG_PRELUDE_EXTERN_C_START\n"
"#   define SLANG_PRELUDE_EXTERN_C_END \n"
"#endif    \n"
"\n"
"#define SLANG_PRELUDE_NAMESPACE\n"
"\n"
"#ifndef SLANG_NO_THROW\n"
"#   define SLANG_NO_THROW\n"
"#endif\n"
"#ifndef SLANG_STDCALL\n"
"#   define SLANG_STDCALL\n"
"#endif\n"
"#ifndef SLANG_MCALL\n"
"#   define SLANG_MCALL SLANG_STDCALL\n"
"#endif\n"
"#ifndef SLANG_FORCE_INLINE\n"
"#    define SLANG_FORCE_INLINE inline\n"
"#endif\n"
"#ifndef SLANG_PRELUDE_CPP_TYPES_CORE_H\n"
"#define SLANG_PRELUDE_CPP_TYPES_CORE_H\n"
"\n"
"#ifndef SLANG_PRELUDE_ASSERT\n"
"#   ifdef SLANG_PRELUDE_ENABLE_ASSERT\n"
"#       define SLANG_PRELUDE_ASSERT(VALUE) assert(VALUE)\n"
"#   else\n"
"#       define SLANG_PRELUDE_ASSERT(VALUE) \n"
"#   endif\n"
"#endif\n"
"\n"
"// Since we are using unsigned arithmatic care is need in this comparison.\n"
"// It is *assumed* that sizeInBytes >= elemSize. Which means (sizeInBytes >= elemSize) >= 0\n"
"// Which means only a single test is needed\n"
"\n"
"// Asserts for bounds checking.\n"
"// It is assumed index/count are unsigned types.\n"
"#define SLANG_BOUND_ASSERT(index, count)  SLANG_PRELUDE_ASSERT(index < count); \n"
"#define SLANG_BOUND_ASSERT_BYTE_ADDRESS(index, elemSize, sizeInBytes) SLANG_PRELUDE_ASSERT(index <= (sizeInBytes - elemSize) && (index & 3) == 0);\n"
"\n"
"// Macros to zero index if an access is out of range\n"
"#define SLANG_BOUND_ZERO_INDEX(index, count) index = (index < count) ? index : 0; \n"
"#define SLANG_BOUND_ZERO_INDEX_BYTE_ADDRESS(index, elemSize, sizeInBytes) index = (index <= (sizeInBytes - elemSize)) ? index : 0; \n"
"\n"
"// The 'FIX' macro define how the index is fixed. The default is to do nothing. If SLANG_ENABLE_BOUND_ZERO_INDEX\n"
"// the fix macro will zero the index, if out of range\n"
"#ifdef  SLANG_ENABLE_BOUND_ZERO_INDEX\n"
"#   define SLANG_BOUND_FIX(index, count) SLANG_BOUND_ZERO_INDEX(index, count)\n"
"#   define SLANG_BOUND_FIX_BYTE_ADDRESS(index, elemSize, sizeInBytes) SLANG_BOUND_ZERO_INDEX_BYTE_ADDRESS(index, elemSize, sizeInBytes)\n"
"#   define SLANG_BOUND_FIX_FIXED_ARRAY(index, count) SLANG_BOUND_ZERO_INDEX(index, count)\n"
"#else\n"
"#   define SLANG_BOUND_FIX(index, count) \n"
"#   define SLANG_BOUND_FIX_BYTE_ADDRESS(index, elemSize, sizeInBytes) \n"
"#   define SLANG_BOUND_FIX_FIXED_ARRAY(index, count) \n"
"#endif\n"
"\n"
"#ifndef SLANG_BOUND_CHECK\n"
"#   define SLANG_BOUND_CHECK(index, count) SLANG_BOUND_ASSERT(index, count) SLANG_BOUND_FIX(index, count)\n"
"#endif\n"
"\n"
"#ifndef SLANG_BOUND_CHECK_BYTE_ADDRESS\n"
"#   define SLANG_BOUND_CHECK_BYTE_ADDRESS(index, elemSize, sizeInBytes) SLANG_BOUND_ASSERT_BYTE_ADDRESS(index, elemSize, sizeInBytes) SLANG_BOUND_FIX_BYTE_ADDRESS(index, elemSize, sizeInBytes)\n"
"#endif\n"
"\n"
"#ifndef SLANG_BOUND_CHECK_FIXED_ARRAY\n"
"#   define SLANG_BOUND_CHECK_FIXED_ARRAY(index, count) SLANG_BOUND_ASSERT(index, count) SLANG_BOUND_FIX_FIXED_ARRAY(index, count)\n"
"#endif\n"
"\n"
"struct TypeInfo\n"
"{\n"
"    size_t typeSize;\n"
"};\n"
"\n"
"template <typename T, size_t SIZE>\n"
"struct FixedArray\n"
"{\n"
"    const T& operator[](size_t index) const { SLANG_BOUND_CHECK_FIXED_ARRAY(index, SIZE); return m_data[index]; }\n"
"    T& operator[](size_t index) { SLANG_BOUND_CHECK_FIXED_ARRAY(index, SIZE); return m_data[index]; }\n"
"\n"
"    T m_data[SIZE];\n"
"};\n"
"\n"
"// An array that has no specified size, becomes a 'Array'. This stores the size so it can potentially \n"
"// do bounds checking.  \n"
"template <typename T>\n"
"struct Array\n"
"{\n"
"    const T& operator[](size_t index) const { SLANG_BOUND_CHECK(index, count); return data[index]; }\n"
"    T& operator[](size_t index) { SLANG_BOUND_CHECK(index, count); return data[index]; }\n"
"\n"
"    T* data;\n"
"    size_t count;\n"
"};\n"
"\n"
"/* Constant buffers become a pointer to the contained type, so ConstantBuffer<T> becomes T* in C++ code.\n"
"*/\n"
"\n"
"template <typename T, int COUNT>\n"
"struct Vector;\n"
"\n"
"template <typename T>\n"
"struct Vector<T, 1>\n"
"{\n"
"    T x;\n"
"    const T& operator[](size_t /*index*/) const { return x; }\n"
"    T& operator[](size_t /*index*/) { return x; }\n"
"    operator T() const { return x; }\n"
"    Vector() = default;\n"
"    Vector(T scalar)\n"
"    {\n"
"        x = scalar;\n"
"    }\n"
"    template <typename U>\n"
"    Vector(Vector<U, 1> other)\n"
"    {\n"
"        x = (T)other.x;\n"
"    }\n"
"    template <typename U, int otherSize>\n"
"    Vector(Vector<U, otherSize> other)\n"
"    {\n"
"        int minSize = 1;\n"
"        if (otherSize < minSize) minSize = otherSize;\n"
"        for (int i = 0; i < minSize; i++)\n"
"            (*this)[i] = (T)other[i];\n"
"    }\n"
"};\n"
"\n"
"template <typename T>\n"
"struct Vector<T, 2>\n"
"{\n"
"    T x, y;\n"
"    const T& operator[](size_t index) const { return index == 0 ? x : y; }\n"
"    T& operator[](size_t index) { return index == 0 ? x : y; }\n"
"    Vector() = default;\n"
"    Vector(T scalar)\n"
"    {\n"
"        x = y = scalar;\n"
;
sb << 
"    }\n"
"    Vector(T _x, T _y)\n"
"    {\n"
"        x = _x;\n"
"        y = _y;\n"
"    }\n"
"    template <typename U>\n"
"    Vector(Vector<U, 2> other)\n"
"    {\n"
"        x = (T)other.x;\n"
"        y = (T)other.y;\n"
"    }\n"
"    template <typename U, int otherSize>\n"
"    Vector(Vector<U, otherSize> other)\n"
"    {\n"
"        int minSize = 2;\n"
"        if (otherSize < minSize) minSize = otherSize;\n"
"        for (int i = 0; i < minSize; i++)\n"
"            (*this)[i] = (T)other[i];\n"
"    }\n"
"};\n"
"\n"
"template <typename T>\n"
"struct Vector<T, 3>\n"
"{\n"
"    T x, y, z;\n"
"    const T& operator[](size_t index) const { return *((T*)(this) + index); }\n"
"    T& operator[](size_t index) { return *((T*)(this) + index); }\n"
"\n"
"    Vector() = default;\n"
"    Vector(T scalar)\n"
"    {\n"
"        x = y = z = scalar;\n"
"    }\n"
"    Vector(T _x, T _y, T _z)\n"
"    {\n"
"        x = _x;\n"
"        y = _y;\n"
"        z = _z;\n"
"    }\n"
"    template <typename U>\n"
"    Vector(Vector<U, 3> other)\n"
"    {\n"
"        x = (T)other.x;\n"
"        y = (T)other.y;\n"
"        z = (T)other.z;\n"
"    }\n"
"    template <typename U, int otherSize>\n"
"    Vector(Vector<U, otherSize> other)\n"
"    {\n"
"        int minSize = 3;\n"
"        if (otherSize < minSize) minSize = otherSize;\n"
"        for (int i = 0; i < minSize; i++)\n"
"            (*this)[i] = (T)other[i];\n"
"    }\n"
"};\n"
"\n"
"template <typename T>\n"
"struct Vector<T, 4>\n"
"{\n"
"    T x, y, z, w;\n"
"\n"
"    const T& operator[](size_t index) const { return *((T*)(this) + index); }\n"
"    T& operator[](size_t index) { return *((T*)(this) + index); }\n"
"    Vector() = default;\n"
"    Vector(T scalar)\n"
"    {\n"
"        x = y = z = w = scalar;\n"
"    }\n"
"    Vector(T _x, T _y, T _z, T _w)\n"
"    {\n"
"        x = _x;\n"
"        y = _y;\n"
"        z = _z;\n"
"        w = _w;\n"
"    }\n"
"    template <typename U, int otherSize>\n"
"    Vector(Vector<U, otherSize> other)\n"
"    {\n"
"        int minSize = 4;\n"
"        if (otherSize < minSize) minSize = otherSize;\n"
"        for (int i = 0; i < minSize; i++)\n"
"            (*this)[i] = (T)other[i];\n"
"    }\n"
" \n"
"};\n"
"\n"
"template<typename T, int N>\n"
"SLANG_FORCE_INLINE Vector<T, N> _slang_select(Vector<bool, N> condition, Vector<T, N> v0, Vector<T, N> v1)\n"
"{\n"
"    Vector<T, N> result;\n"
"    for (int i = 0; i < N; i++)\n"
"    {\n"
"        result[i] = condition[i] ? v0[i] : v1[i];\n"
"    }\n"
"    return result;\n"
"}\n"
"\n"
"template<typename T>\n"
"SLANG_FORCE_INLINE T _slang_select(bool condition, T v0, T v1)\n"
"{\n"
"    return condition ? v0 : v1;\n"
"}\n"
"\n"
"template<typename T, int N>\n"
"SLANG_FORCE_INLINE T _slang_vector_get_element(Vector<T, N> x, int index)\n"
"{\n"
"    return x[index];\n"
"}\n"
"\n"
"template<typename T, int N>\n"
"SLANG_FORCE_INLINE const T* _slang_vector_get_element_ptr(const Vector<T, N>* x, int index)\n"
"{\n"
"    return &((*const_cast<Vector<T,N>*>(x))[index]);\n"
"}\n"
"\n"
"template<typename T, int N>\n"
"SLANG_FORCE_INLINE T* _slang_vector_get_element_ptr(Vector<T, N>* x, int index)\n"
"{\n"
"    return &((*x)[index]);\n"
"}\n"
"\n"
"template<typename T, int n, typename OtherT, int m>\n"
"SLANG_FORCE_INLINE Vector<T, n> _slang_vector_reshape(const Vector<OtherT, m> other)\n"
"{\n"
"    Vector<T, n> result;\n"
"    for (int i = 0; i < n; i++)\n"
"    {\n"
"        OtherT otherElement = T(0);\n"
"        if (i < m)\n"
"            otherElement = _slang_vector_get_element(other, i);\n"
"        *_slang_vector_get_element_ptr(&result, i) = (T)otherElement;\n"
"    }\n"
"    return result;\n"
"}\n"
"\n"
"typedef uint32_t uint;\n"
"\n"
"#define SLANG_VECTOR_BINARY_OP(T, op) \\\n"
"    template<int n> \\\n"
"    SLANG_FORCE_INLINE Vector<T, n> operator op(const Vector<T, n>& thisVal, const Vector<T, n>& other) \\\n"
"    { \\\n"
"        Vector<T, n> result;\\\n"
"        for (int i = 0; i < n; i++) \\\n"
"            result[i] = thisVal[i] op other[i]; \\\n"
"        return result;\\\n"
"    }\n"
"#define SLANG_VECTOR_BINARY_COMPARE_OP(T, op) \\\n"
"    template<int n> \\\n"
"    SLANG_FORCE_INLINE Vector<bool, n> operator op(const Vector<T, n>& thisVal, const Vector<T, n>& other) \\\n"
"    { \\\n"
"        Vector<bool, n> result;\\\n"
"        for (int i = 0; i < n; i++) \\\n"
"            result[i] = thisVal[i] op other[i]; \\\n"
"        return result;\\\n"
"    }\n"
"\n"
"#define SLANG_VECTOR_UNARY_OP(T, op) \\\n"
"    template<int n> \\\n"
"    SLANG_FORCE_INLINE Vector<T, n> operator op(const Vector<T, n>& thisVal) \\\n"
"    { \\\n"
"        Vector<T, n> result;\\\n"
"        for (int i = 0; i < n; i++) \\\n"
"            result[i] = op thisVal[i]; \\\n"
"        return result;\\\n"
"    }\n"
"#define SLANG_INT_VECTOR_OPS(T) \\\n"
"    SLANG_VECTOR_BINARY_OP(T, +)\\\n"
"    SLANG_VECTOR_BINARY_OP(T, -)\\\n"
"    SLANG_VECTOR_BINARY_OP(T, *)\\\n"
"    SLANG_VECTOR_BINARY_OP(T, / )\\\n"
"    SLANG_VECTOR_BINARY_OP(T, &)\\\n"
"    SLANG_VECTOR_BINARY_OP(T, |)\\\n"
"    SLANG_VECTOR_BINARY_OP(T, &&)\\\n"
"    SLANG_VECTOR_BINARY_OP(T, ||)\\\n"
"    SLANG_VECTOR_BINARY_OP(T, ^)\\\n"
"    SLANG_VECTOR_BINARY_OP(T, %)\\\n"
"    SLANG_VECTOR_BINARY_OP(T, >>)\\\n"
"    SLANG_VECTOR_BINARY_OP(T, <<)\\\n"
"    SLANG_VECTOR_BINARY_COMPARE_OP(T, >)\\\n"
"    SLANG_VECTOR_BINARY_COMPARE_OP(T, <)\\\n"
"    SLANG_VECTOR_BINARY_COMPARE_OP(T, >=)\\\n"
"    SLANG_VECTOR_BINARY_COMPARE_OP(T, <=)\\\n"
"    SLANG_VECTOR_BINARY_COMPARE_OP(T, ==)\\\n"
"    SLANG_VECTOR_BINARY_COMPARE_OP(T, !=)\\\n"
"    SLANG_VECTOR_UNARY_OP(T, !)\\\n"
"    SLANG_VECTOR_UNARY_OP(T, ~)\n"
"#define SLANG_FLOAT_VECTOR_OPS(T) \\\n"
"    SLANG_VECTOR_BINARY_OP(T, +)\\\n"
"    SLANG_VECTOR_BINARY_OP(T, -)\\\n"
"    SLANG_VECTOR_BINARY_OP(T, *)\\\n"
"    SLANG_VECTOR_BINARY_OP(T, /)\\\n"
"    SLANG_VECTOR_UNARY_OP(T, -)\\\n"
"    SLANG_VECTOR_BINARY_COMPARE_OP(T, >)\\\n"
"    SLANG_VECTOR_BINARY_COMPARE_OP(T, <)\\\n"
"    SLANG_VECTOR_BINARY_COMPARE_OP(T, >=)\\\n"
"    SLANG_VECTOR_BINARY_COMPARE_OP(T, <=)\\\n"
"    SLANG_VECTOR_BINARY_COMPARE_OP(T, ==)\\\n"
"    SLANG_VECTOR_BINARY_COMPARE_OP(T, !=)\n"
"\n"
"SLANG_INT_VECTOR_OPS(bool)\n"
"SLANG_INT_VECTOR_OPS(int)\n"
"SLANG_INT_VECTOR_OPS(int8_t)\n"
"SLANG_INT_VECTOR_OPS(int16_t)\n"
"SLANG_INT_VECTOR_OPS(int64_t)\n"
"SLANG_INT_VECTOR_OPS(uint)\n"
"SLANG_INT_VECTOR_OPS(uint8_t)\n"
"SLANG_INT_VECTOR_OPS(uint16_t)\n"
"SLANG_INT_VECTOR_OPS(uint64_t)\n"
"\n"
"SLANG_FLOAT_VECTOR_OPS(float)\n"
"SLANG_FLOAT_VECTOR_OPS(double)\n"
"\n"
"#define SLANG_VECTOR_INT_NEG_OP(T) \\\n"
"    template<int N>\\\n"
"    Vector<T, N> operator-(const Vector<T, N>& thisVal) \\\n"
"    { \\\n"
"        Vector<T, N> result;\\\n"
"        for (int i = 0; i < N; i++) \\\n"
"            result[i] = 0 - thisVal[i]; \\\n"
"        return result;\\\n"
"    }\n"
"SLANG_VECTOR_INT_NEG_OP(int)\n"
"SLANG_VECTOR_INT_NEG_OP(int8_t)\n"
"SLANG_VECTOR_INT_NEG_OP(int16_t)\n"
"SLANG_VECTOR_INT_NEG_OP(int64_t)\n"
"SLANG_VECTOR_INT_NEG_OP(uint)\n"
"SLANG_VECTOR_INT_NEG_OP(uint8_t)\n"
"SLANG_VECTOR_INT_NEG_OP(uint16_t)\n"
"SLANG_VECTOR_INT_NEG_OP(uint64_t)\n"
"\n"
"#define SLANG_FLOAT_VECTOR_MOD(T)\\\n"
"    template<int N> \\\n"
"    Vector<T, N> operator%(const Vector<T, N>& left, const Vector<T, N>& right) \\\n"
"    {\\\n"
"        Vector<T, N> result;\\\n"
"        for (int i = 0; i < N; i++) \\\n"
"            result[i] = _slang_fmod(left[i], right[i]); \\\n"
"        return result;\\\n"
"    }\n"
"\n"
"SLANG_FLOAT_VECTOR_MOD(float)\n"
"SLANG_FLOAT_VECTOR_MOD(double)\n"
"#undef SLANG_FLOAT_VECTOR_MOD\n"
"#undef SLANG_VECTOR_BINARY_OP\n"
"#undef SLANG_VECTOR_UNARY_OP\n"
"#undef SLANG_INT_VECTOR_OPS\n"
"#undef SLANG_FLOAT_VECTOR_OPS\n"
"#undef SLANG_VECTOR_INT_NEG_OP\n"
"#undef SLANG_FLOAT_VECTOR_MOD\n"
"\n"
"template <typename T, int ROWS, int COLS>\n"
"struct Matrix\n"
"{\n"
"    Vector<T, COLS> rows[ROWS];\n"
"    Vector<T, COLS>& operator[](size_t index) { return rows[index]; }\n"
"    Matrix() = default;\n"
"    Matrix(T scalar)\n"
"    {\n"
"        for (int i = 0; i < ROWS; i++)\n"
"            rows[i] = Vector<T, COLS>(scalar);\n"
"    }\n"
"    Matrix(const Vector<T, COLS>& row0)\n"
"    {\n"
"        rows[0] = row0;\n"
"    }\n"
"    Matrix(const Vector<T, COLS>& row0, const Vector<T, COLS>& row1)\n"
"    {\n"
"        rows[0] = row0;\n"
"        rows[1] = row1;\n"
"    }\n"
"    Matrix(const Vector<T, COLS>& row0, const Vector<T, COLS>& row1, const Vector<T, COLS>& row2)\n"
"    {\n"
"        rows[0] = row0;\n"
"        rows[1] = row1;\n"
"        rows[2] = row2;\n"
"    }\n"
"    Matrix(const Vector<T, COLS>& row0, const Vector<T, COLS>& row1, const Vector<T, COLS>& row2, const Vector<T, COLS>& row3)\n"
"    {\n"
"        rows[0] = row0;\n"
"        rows[1] = row1;\n"
"        rows[2] = row2;\n"
"        rows[3] = row3;\n"
"    }\n"
"    template<typename U, int otherRow, int otherCol>\n"
"    Matrix(const Matrix<U, otherRow, otherCol>& other)\n"
"    {\n"
"        int minRow = ROWS;\n"
"        int minCol = COLS;\n"
"        if (minRow > otherRow) minRow = otherRow;\n"
"        if (minCol > otherCol) minCol = otherCol;\n"
"        for (int i = 0; i < minRow; i++)\n"
"            for (int j = 0; j < minCol; j++)\n"
"                rows[i][j] = (T)other.rows[i][j];\n"
"    }\n"
"    Matrix(T v0, T v1, T v2, T v3)\n"
"    {\n"
"        rows[0][0] = v0;  rows[0][1] = v1;\n"
"        rows[1][0] = v2;  rows[1][1] = v3;\n"
"    }\n"
"    Matrix(T v0, T v1, T v2, T v3, T v4, T v5)\n"
"    {\n"
"        if (COLS == 3)\n"
"        {\n"
"            rows[0][0] = v0;  rows[0][1] = v1; rows[0][2] = v2;\n"
"            rows[1][0] = v3;  rows[1][1] = v4; rows[1][2] = v5;\n"
"        }\n"
"        else\n"
"        {\n"
"            rows[0][0] = v0;  rows[0][1] = v1;\n"
"            rows[1][0] = v2;  rows[1][1] = v3;\n"
"            rows[2][0] = v4;  rows[2][1] = v5;\n"
"        }\n"
"    }\n"
"    Matrix(T v0, T v1, T v2, T v3, T v4, T v5, T v6, T v7)\n"
"    {\n"
"        if (COLS == 4)\n"
"        {\n"
"            rows[0][0] = v0;  rows[0][1] = v1; rows[0][2] = v2; rows[0][3] = v3;\n"
"            rows[1][0] = v4;  rows[1][1] = v5; rows[1][2] = v6; rows[1][3] = v7;\n"
"        }\n"
"        else\n"
"        {\n"
"            rows[0][0] = v0;  rows[0][1] = v1;\n"
"            rows[1][0] = v2;  rows[1][1] = v3;\n"
"            rows[2][0] = v4;  rows[2][1] = v5;\n"
"            rows[3][0] = v6;  rows[3][1] = v7;\n"
"        }\n"
"    }\n"
"    Matrix(T v0, T v1, T v2, T v3, T v4, T v5, T v6, T v7, T v8)\n"
"    {\n"
"        rows[0][0] = v0;  rows[0][1] = v1;  rows[0][2] = v2;\n"
"        rows[1][0] = v3;  rows[1][1] = v4;  rows[1][2] = v5;\n"
"        rows[2][0] = v6;  rows[2][1] = v7;  rows[2][2] = v8;\n"
"    }\n"
"    Matrix(T v0, T v1, T v2, T v3, T v4, T v5, T v6, T v7, T v8, T v9, T v10, T v11)\n"
"    {\n"
"        if (COLS == 4)\n"
"        {\n"
"            rows[0][0] = v0;  rows[0][1] = v1;  rows[0][2] = v2;  rows[0][3] = v3;\n"
"            rows[1][0] = v4;  rows[1][1] = v5;  rows[1][2] = v6;  rows[1][3] = v7;\n"
"            rows[2][0] = v8;  rows[2][1] = v9;  rows[2][2] = v10; rows[2][3] = v11;\n"
"        }\n"
"        else\n"
"        {\n"
"            rows[0][0] = v0;  rows[0][1] = v1;  rows[0][2] = v2;\n"
"            rows[1][0] = v3;  rows[1][1] = v4;  rows[1][2] = v5;\n"
"            rows[2][0] = v6;  rows[2][1] = v7;  rows[2][2] = v8;\n"
"            rows[3][0] = v9;  rows[3][1] = v10; rows[3][2] = v11;\n"
"        }\n"
"    }\n"
"    Matrix(T v0, T v1, T v2, T v3, T v4, T v5, T v6, T v7, T v8, T v9, T v10, T v11, T v12, T v13, T v14, T v15)\n"
"    {\n"
"        rows[0][0] = v0;  rows[0][1] = v1;  rows[0][2] = v2;  rows[0][3] = v3;\n"
"        rows[1][0] = v4;  rows[1][1] = v5;  rows[1][2] = v6;  rows[1][3] = v7;\n"
"        rows[2][0] = v8;  rows[2][1] = v9;  rows[2][2] = v10; rows[2][3] = v11;\n"
"        rows[3][0] = v12; rows[3][1] = v13; rows[3][2] = v14; rows[3][3] = v15;\n"
"    }\n"
"};\n"
"\n"
"#define SLANG_MATRIX_BINARY_OP(T, op) \\\n"
"    template<int R, int C> \\\n"
"    Matrix<T, R, C> operator op(const Matrix<T, R, C>& thisVal, const Matrix<T, R, C>& other) \\\n"
"    { \\\n"
"        Matrix<T, R, C> result;\\\n"
"        for (int i = 0; i < R; i++) \\\n"
"            for (int j = 0; j < C; j++) \\\n"
"                result.rows[i][j] = thisVal.rows[i][j] op other.rows[i][j]; \\\n"
"        return result;\\\n"
"    }\n"
"\n"
"#define SLANG_MATRIX_UNARY_OP(T, op) \\\n"
"    template<int R, int C> \\\n"
"    Matrix<T, R, C> operator op(const Matrix<T, R, C>& thisVal) \\\n"
"    { \\\n"
"        Matrix<T, R, C> result;\\\n"
"        for (int i = 0; i < R; i++) \\\n"
"            for (int j = 0; j < C; j++) \\\n"
"                result[i].rows[i][j] = op thisVal.rows[i][j]; \\\n"
"        return result;\\\n"
"    }\n"
"#define SLANG_INT_MATRIX_OPS(T) \\\n"
"    SLANG_MATRIX_BINARY_OP(T, +)\\\n"
"    SLANG_MATRIX_BINARY_OP(T, -)\\\n"
"    SLANG_MATRIX_BINARY_OP(T, *)\\\n"
"    SLANG_MATRIX_BINARY_OP(T, / )\\\n"
"    SLANG_MATRIX_BINARY_OP(T, &)\\\n"
"    SLANG_MATRIX_BINARY_OP(T, |)\\\n"
"    SLANG_MATRIX_BINARY_OP(T, &&)\\\n"
"    SLANG_MATRIX_BINARY_OP(T, ||)\\\n"
"    SLANG_MATRIX_BINARY_OP(T, ^)\\\n"
"    SLANG_MATRIX_BINARY_OP(T, %)\\\n"
"    SLANG_MATRIX_UNARY_OP(T, !)\\\n"
"    SLANG_MATRIX_UNARY_OP(T, ~)\n"
"#define SLANG_FLOAT_MATRIX_OPS(T) \\\n"
"    SLANG_MATRIX_BINARY_OP(T, +)\\\n"
"    SLANG_MATRIX_BINARY_OP(T, -)\\\n"
"    SLANG_MATRIX_BINARY_OP(T, *)\\\n"
"    SLANG_MATRIX_BINARY_OP(T, /)\\\n"
"    SLANG_MATRIX_UNARY_OP(T, -)\n"
"SLANG_INT_MATRIX_OPS(int)\n"
"SLANG_INT_MATRIX_OPS(int8_t)\n"
"SLANG_INT_MATRIX_OPS(int16_t)\n"
"SLANG_INT_MATRIX_OPS(int64_t)\n"
"SLANG_INT_MATRIX_OPS(uint)\n"
"SLANG_INT_MATRIX_OPS(uint8_t)\n"
"SLANG_INT_MATRIX_OPS(uint16_t)\n"
"SLANG_INT_MATRIX_OPS(uint64_t)\n"
"\n"
"SLANG_FLOAT_MATRIX_OPS(float)\n"
"SLANG_FLOAT_MATRIX_OPS(double)\n"
"\n"
"#define SLANG_MATRIX_INT_NEG_OP(T) \\\n"
"    template<int R, int C>\\\n"
"    SLANG_FORCE_INLINE Matrix<T, R, C> operator-(Matrix<T, R, C> thisVal) \\\n"
"    { \\\n"
"        Matrix<T, R, C> result;\\\n"
"        for (int i = 0; i < R; i++) \\\n"
"            for (int j = 0; j < C; j++) \\\n"
"            result.rows[i][j] = 0 - thisVal.rows[i][j]; \\\n"
"        return result;\\\n"
"    }\n"
"    SLANG_MATRIX_INT_NEG_OP(int)\n"
"    SLANG_MATRIX_INT_NEG_OP(int8_t)\n"
"    SLANG_MATRIX_INT_NEG_OP(int16_t)\n"
"    SLANG_MATRIX_INT_NEG_OP(int64_t)\n"
"    SLANG_MATRIX_INT_NEG_OP(uint)\n"
"    SLANG_MATRIX_INT_NEG_OP(uint8_t)\n"
"    SLANG_MATRIX_INT_NEG_OP(uint16_t)\n"
"    SLANG_MATRIX_INT_NEG_OP(uint64_t)\n"
"\n"
"#define SLANG_FLOAT_MATRIX_MOD(T)\\\n"
"    template<int R, int C> \\\n"
"    SLANG_FORCE_INLINE Matrix<T, R, C> operator%(Matrix<T, R, C> left, Matrix<T, R, C> right) \\\n"
"    {\\\n"
"        Matrix<T, R, C> result;\\\n"
"        for (int i = 0; i < R; i++) \\\n"
"            for (int j = 0; j < C; j++) \\\n"
"                result.rows[i][j] = _slang_fmod(left.rows[i][j], right.rows[i][j]); \\\n"
"        return result;\\\n"
"    }\n"
"\n"
"    SLANG_FLOAT_MATRIX_MOD(float)\n"
"    SLANG_FLOAT_MATRIX_MOD(double)\n"
"#undef SLANG_FLOAT_MATRIX_MOD\n"
"#undef SLANG_MATRIX_BINARY_OP\n"
"#undef SLANG_MATRIX_UNARY_OP\n"
"#undef SLANG_INT_MATRIX_OPS\n"
"#undef SLANG_FLOAT_MATRIX_OPS\n"
"#undef SLANG_MATRIX_INT_NEG_OP\n"
"#undef SLANG_FLOAT_MATRIX_MOD\n"
"\n"
"template<typename TResult, typename TInput>\n"
"TResult slang_bit_cast(TInput val)\n"
"{\n"
"    return *(TResult*)(&val);\n"
"}\n"
"\n"
"#endif\n"
"\n"
"\n"
"\n"
"#ifndef SLANG_PRELUDE_SCALAR_INTRINSICS_H\n"
"#define SLANG_PRELUDE_SCALAR_INTRINSICS_H\n"
"\n"
"#if !defined(SLANG_LLVM) && SLANG_PROCESSOR_X86_64 && SLANG_VC\n"
"//  If we have visual studio and 64 bit processor, we can assume we have popcnt, and can include x86 intrinsics\n"
"#   include <intrin.h>\n"
"#endif\n"
"\n"
"#ifndef SLANG_FORCE_INLINE\n"
"#    define SLANG_FORCE_INLINE inline\n"
"#endif\n"
"\n"
"#ifdef SLANG_PRELUDE_NAMESPACE\n"
"namespace SLANG_PRELUDE_NAMESPACE {\n"
"#endif\n"
"\n"
"#ifndef SLANG_PRELUDE_PI\n"
"#   define SLANG_PRELUDE_PI           3.14159265358979323846\n"
"#endif\n"
"\n"
"\n"
"union Union32 \n"
"{\n"
"    uint32_t u;\n"
"    int32_t i;\n"
"    float f;\n"
"};\n"
"\n"
"union Union64\n"
"{\n"
"    uint64_t u;\n"
"    int64_t i;\n"
"    double d;\n"
"};\n"
"\n"
"// 32 bit cast conversions\n"
"SLANG_FORCE_INLINE int32_t _bitCastFloatToInt(float f) { Union32 u; u.f = f; return u.i; }\n"
"SLANG_FORCE_INLINE float _bitCastIntToFloat(int32_t i) { Union32 u; u.i = i; return u.f; }\n"
"SLANG_FORCE_INLINE uint32_t _bitCastFloatToUInt(float f) { Union32 u; u.f = f; return u.u; }\n"
"SLANG_FORCE_INLINE float _bitCastUIntToFloat(uint32_t ui) { Union32 u; u.u = ui; return u.f; }\n"
"\n"
"// ----------------------------- F16 -----------------------------------------\n"
"\n"
"\n"
"// This impl is based on FloatToHalf that is in Slang codebase\n"
"SLANG_FORCE_INLINE uint32_t f32tof16(const float value)\n"
"{\n"
"    const uint32_t inBits = _bitCastFloatToUInt(value);\n"
"\n"
"    // bits initially set to just the sign bit\n"
"    uint32_t bits = (inBits >> 16) & 0x8000;\n"
"    // Mantissa can't be used as is, as it holds last bit, for rounding.\n"
"    uint32_t m = (inBits >> 12) & 0x07ff;\n"
"    uint32_t e = (inBits >> 23) & 0xff;\n"
"\n"
"    if (e < 103)\n"
"    {\n"
"        // It's zero\n"
"        return bits;\n"
"    }\n"
"    if (e == 0xff)\n"
"    {\n"
"        // Could be a NAN or INF. Is INF if *input* mantissa is 0.\n"
"        \n"
"        // Remove last bit for rounding to make output mantissa.\n"
"        m >>= 1;\n"
"       \n"
"        // We *assume* float16/float32 signaling bit and remaining bits\n"
"        // semantics are the same. (The signalling bit convention is target specific!).\n"
"        // Non signal bit's usage within mantissa for a NAN are also target specific.\n"
"      \n"
"        // If the m is 0, it could be because the result is INF, but it could also be because all the \n"
"        // bits that made NAN were dropped as we have less mantissa bits in f16. \n"
"           \n"
"        // To fix for this we make non zero if m is 0 and the input mantissa was not.\n"
"        // This will (typically) produce a signalling NAN.\n"
"        m += uint32_t(m == 0 && (inBits & 0x007fffffu));\n"
"       \n"
"        // Combine for output\n"
"        return (bits | 0x7c00u | m);\n"
"    }\n"
"    if (e > 142)\n"
"    {\n"
"        // INF. \n"
"        return bits | 0x7c00u;\n"
"    }\n"
"    if (e < 113)\n"
"    {\n"
"        m |= 0x0800u;\n"
"        bits |= (m >> (114 - e)) + ((m >> (113 - e)) & 1);\n"
"        return bits;\n"
"    }\n"
"    bits |= ((e - 112) << 10) | (m >> 1);\n"
"    bits += m & 1;\n"
"    return bits;\n"
"}\n"
"\n"
"static const float g_f16tof32Magic = _bitCastIntToFloat((127 + (127 - 15)) << 23);\n"
"\n"
"SLANG_FORCE_INLINE float f16tof32(const uint32_t value)\n"
"{\n"
"    const uint32_t sign = (value & 0x8000) << 16;\n"
"    uint32_t exponent = (value & 0x7c00) >> 10;\n"
"    uint32_t mantissa = (value & 0x03ff);\n"
"\n"
"    if (exponent == 0)\n"
"    {\n"
"        // If mantissa is 0 we are done, as output is 0. \n"
"        // If it's not zero we must have a denormal.\n"
"        if (mantissa)\n"
;
sb << 
"        {\n"
"            // We have a denormal so use the magic to do exponent adjust\n"
"            return _bitCastIntToFloat(sign | ((value & 0x7fff) << 13)) * g_f16tof32Magic;\n"
"        }\n"
"    }\n"
"    else \n"
"    {\n"
"        // If the exponent is NAN or INF exponent is 0x1f on input. \n"
"        // If that's the case, we just need to set the exponent to 0xff on output\n"
"        // and the mantissa can just stay the same. If its 0 it's INF, else it is NAN and we just copy the bits\n"
"        //\n"
"        // Else we need to correct the exponent in the normalized case.\n"
"        exponent = (exponent == 0x1F) ? 0xff : (exponent + (-15 + 127));\n"
"    }\n"
"    \n"
"    return _bitCastUIntToFloat(sign | (exponent << 23) | (mantissa << 13));\n"
"}\n"
"\n"
"// ----------------------------- F32 -----------------------------------------\n"
"\n"
"// Helpers\n"
"SLANG_FORCE_INLINE float F32_calcSafeRadians(float radians);\n"
"\n"
"#ifdef SLANG_LLVM\n"
"\n"
"SLANG_PRELUDE_EXTERN_C_START\n"
"\n"
"// Unary \n"
"float F32_ceil(float f);\n"
"float F32_floor(float f);\n"
"float F32_round(float f);\n"
"float F32_sin(float f);\n"
"float F32_cos(float f);\n"
"float F32_tan(float f);\n"
"float F32_asin(float f);\n"
"float F32_acos(float f);\n"
"float F32_atan(float f);\n"
"float F32_sinh(float f);\n"
"float F32_cosh(float f);\n"
"float F32_tanh(float f);\n"
"float F32_log2(float f);\n"
"float F32_log(float f);\n"
"float F32_log10(float f);\n"
"float F32_exp2(float f);\n"
"float F32_exp(float f);\n"
"float F32_abs(float f);\n"
"float F32_trunc(float f);\n"
"float F32_sqrt(float f);\n"
"\n"
"bool F32_isnan(float f);\n"
"bool F32_isfinite(float f); \n"
"bool F32_isinf(float f);\n"
"\n"
"// Binary\n"
"SLANG_FORCE_INLINE float F32_min(float a, float b) { return a < b ? a : b; }\n"
"SLANG_FORCE_INLINE float F32_max(float a, float b) { return a > b ? a : b; }\n"
"float F32_pow(float a, float b);\n"
"float F32_fmod(float a, float b);\n"
"float F32_remainder(float a, float b);\n"
"float F32_atan2(float a, float b);\n"
"\n"
"float F32_frexp(float x, int* e);\n"
"\n"
"float F32_modf(float x, float* ip);\n"
"\n"
"// Ternary\n"
"SLANG_FORCE_INLINE float F32_fma(float a, float b, float c) { return a * b + c; }\n"
"\n"
"SLANG_PRELUDE_EXTERN_C_END\n"
"\n"
"#else\n"
"\n"
"// Unary \n"
"SLANG_FORCE_INLINE float F32_ceil(float f) { return ::ceilf(f); }\n"
"SLANG_FORCE_INLINE float F32_floor(float f) { return ::floorf(f); }\n"
"SLANG_FORCE_INLINE float F32_round(float f) { return ::roundf(f); }\n"
"SLANG_FORCE_INLINE float F32_sin(float f) { return ::sinf(f); }\n"
"SLANG_FORCE_INLINE float F32_cos(float f) { return ::cosf(f); }\n"
"SLANG_FORCE_INLINE float F32_tan(float f) { return ::tanf(f); }\n"
"SLANG_FORCE_INLINE float F32_asin(float f) { return ::asinf(f); }\n"
"SLANG_FORCE_INLINE float F32_acos(float f) { return ::acosf(f); }\n"
"SLANG_FORCE_INLINE float F32_atan(float f) { return ::atanf(f); }\n"
"SLANG_FORCE_INLINE float F32_sinh(float f) { return ::sinhf(f); }\n"
"SLANG_FORCE_INLINE float F32_cosh(float f) { return ::coshf(f); }\n"
"SLANG_FORCE_INLINE float F32_tanh(float f) { return ::tanhf(f); }\n"
"SLANG_FORCE_INLINE float F32_log2(float f) { return ::log2f(f); }\n"
"SLANG_FORCE_INLINE float F32_log(float f) { return ::logf(f); }\n"
"SLANG_FORCE_INLINE float F32_log10(float f) { return ::log10f(f); }\n"
"SLANG_FORCE_INLINE float F32_exp2(float f) { return ::exp2f(f); }\n"
"SLANG_FORCE_INLINE float F32_exp(float f) { return ::expf(f); }\n"
"SLANG_FORCE_INLINE float F32_abs(float f) { return ::fabsf(f); }\n"
"SLANG_FORCE_INLINE float F32_trunc(float f) { return ::truncf(f); }\n"
"SLANG_FORCE_INLINE float F32_sqrt(float f) { return ::sqrtf(f); }\n"
"\n"
"SLANG_FORCE_INLINE bool F32_isnan(float f) { return SLANG_PRELUDE_STD isnan(f); }\n"
"SLANG_FORCE_INLINE bool F32_isfinite(float f) { return SLANG_PRELUDE_STD isfinite(f); }\n"
"SLANG_FORCE_INLINE bool F32_isinf(float f) { return SLANG_PRELUDE_STD isinf(f); }\n"
"\n"
"// Binary\n"
"SLANG_FORCE_INLINE float F32_min(float a, float b) { return ::fminf(a, b); }\n"
"SLANG_FORCE_INLINE float F32_max(float a, float b) { return ::fmaxf(a, b); }\n"
"SLANG_FORCE_INLINE float F32_pow(float a, float b) { return ::powf(a, b); }\n"
"SLANG_FORCE_INLINE float F32_fmod(float a, float b) { return ::fmodf(a, b); }\n"
"SLANG_FORCE_INLINE float F32_remainder(float a, float b) { return ::remainderf(a, b); }\n"
"SLANG_FORCE_INLINE float F32_atan2(float a, float b) { return float(::atan2(a, b)); }\n"
"\n"
"SLANG_FORCE_INLINE float F32_frexp(float x, int* e) { return ::frexpf(x, e); }\n"
"\n"
"SLANG_FORCE_INLINE float F32_modf(float x, float* ip)\n"
"{\n"
"    return ::modff(x, ip);\n"
"}\n"
"\n"
"// Ternary\n"
"SLANG_FORCE_INLINE float F32_fma(float a, float b, float c) { return ::fmaf(a, b, c); }\n"
"\n"
"#endif\n"
"\n"
"SLANG_FORCE_INLINE float F32_calcSafeRadians(float radians)\n"
"{\n"
"    // Put 0 to 2pi cycles to cycle around 0 to 1 \n"
"\tfloat a = radians * (1.0f /  float(SLANG_PRELUDE_PI * 2));\n"
"    // Get truncated fraction, as value in  0 - 1 range\n"
"    a = a - F32_floor(a);\n"
"    // Convert back to 0 - 2pi range\n"
"\treturn (a * float(SLANG_PRELUDE_PI * 2));\n"
"}\n"
"\n"
"SLANG_FORCE_INLINE float F32_rsqrt(float f) { return 1.0f / F32_sqrt(f); }\n"
"SLANG_FORCE_INLINE float F32_sign(float f) { return ( f == 0.0f) ? f : (( f < 0.0f) ? -1.0f : 1.0f); } \n"
"SLANG_FORCE_INLINE float F32_frac(float f) { return f - F32_floor(f); }\n"
"\n"
"SLANG_FORCE_INLINE uint32_t F32_asuint(float f) { Union32 u; u.f = f; return u.u; }\n"
"SLANG_FORCE_INLINE int32_t F32_asint(float f) { Union32 u; u.f = f; return u.i; }\n"
"\n"
"// ----------------------------- F64 -----------------------------------------\n"
"\n"
"SLANG_FORCE_INLINE double F64_calcSafeRadians(double radians);\n"
"\n"
"#ifdef SLANG_LLVM\n"
"\n"
"SLANG_PRELUDE_EXTERN_C_START\n"
"\n"
"// Unary \n"
"double F64_ceil(double f);\n"
"double F64_floor(double f);\n"
"double F64_round(double f);\n"
"double F64_sin(double f);\n"
"double F64_cos(double f);\n"
"double F64_tan(double f);\n"
"double F64_asin(double f);\n"
"double F64_acos(double f);\n"
"double F64_atan(double f);\n"
"double F64_sinh(double f);\n"
"double F64_cosh(double f);\n"
"double F64_tanh(double f);\n"
"double F64_log2(double f);\n"
"double F64_log(double f);\n"
"double F64_log10(float f);\n"
"double F64_exp2(double f);\n"
"double F64_exp(double f);\n"
"double F64_abs(double f);\n"
"double F64_trunc(double f);\n"
"double F64_sqrt(double f);\n"
"\n"
"bool F64_isnan(double f);\n"
"bool F64_isfinite(double f);\n"
"bool F64_isinf(double f);\n"
"\n"
"// Binary\n"
"SLANG_FORCE_INLINE double F64_min(double a, double b) { return a < b ? a : b; }\n"
"SLANG_FORCE_INLINE double F64_max(double a, double b) { return a > b ? a : b; }\n"
"double F64_pow(double a, double b);\n"
"double F64_fmod(double a, double b);\n"
"double F64_remainder(double a, double b);\n"
"double F64_atan2(double a, double b);\n"
"\n"
"double F64_frexp(double x, int* e);\n"
"\n"
"double F64_modf(double x, double* ip);\n"
"\n"
"// Ternary\n"
"SLANG_FORCE_INLINE double F64_fma(double a, double b, double c) { return a * b + c; }\n"
"\n"
"SLANG_PRELUDE_EXTERN_C_END\n"
"\n"
"#else // SLANG_LLVM\n"
"\n"
"// Unary \n"
"SLANG_FORCE_INLINE double F64_ceil(double f) { return ::ceil(f); }\n"
"SLANG_FORCE_INLINE double F64_floor(double f) { return ::floor(f); }\n"
"SLANG_FORCE_INLINE double F64_round(double f) { return ::round(f); }\n"
"SLANG_FORCE_INLINE double F64_sin(double f) { return ::sin(f); }\n"
"SLANG_FORCE_INLINE double F64_cos(double f) { return ::cos(f); }\n"
"SLANG_FORCE_INLINE double F64_tan(double f) { return ::tan(f); }\n"
"SLANG_FORCE_INLINE double F64_asin(double f) { return ::asin(f); }\n"
"SLANG_FORCE_INLINE double F64_acos(double f) { return ::acos(f); }\n"
"SLANG_FORCE_INLINE double F64_atan(double f) { return ::atan(f); }\n"
"SLANG_FORCE_INLINE double F64_sinh(double f) { return ::sinh(f); }\n"
"SLANG_FORCE_INLINE double F64_cosh(double f) { return ::cosh(f); }\n"
"SLANG_FORCE_INLINE double F64_tanh(double f) { return ::tanh(f); }\n"
"SLANG_FORCE_INLINE double F64_log2(double f) { return ::log2(f); }\n"
"SLANG_FORCE_INLINE double F64_log(double f) { return ::log(f); }\n"
"SLANG_FORCE_INLINE double F64_log10(float f) { return ::log10(f); }\n"
"SLANG_FORCE_INLINE double F64_exp2(double f) { return ::exp2(f); }\n"
"SLANG_FORCE_INLINE double F64_exp(double f) { return ::exp(f); }\n"
"SLANG_FORCE_INLINE double F64_abs(double f) { return ::fabs(f); }\n"
"SLANG_FORCE_INLINE double F64_trunc(double f) { return ::trunc(f); }\n"
"SLANG_FORCE_INLINE double F64_sqrt(double f) { return ::sqrt(f); }\n"
"\n"
"\n"
"SLANG_FORCE_INLINE bool F64_isnan(double f) { return SLANG_PRELUDE_STD isnan(f); }\n"
"SLANG_FORCE_INLINE bool F64_isfinite(double f) { return SLANG_PRELUDE_STD isfinite(f); }\n"
"SLANG_FORCE_INLINE bool F64_isinf(double f) { return SLANG_PRELUDE_STD isinf(f); }\n"
"\n"
"// Binary\n"
"SLANG_FORCE_INLINE double F64_min(double a, double b) { return ::fmin(a, b); }\n"
"SLANG_FORCE_INLINE double F64_max(double a, double b) { return ::fmax(a, b); }\n"
"SLANG_FORCE_INLINE double F64_pow(double a, double b) { return ::pow(a, b); }\n"
"SLANG_FORCE_INLINE double F64_fmod(double a, double b) { return ::fmod(a, b); }\n"
"SLANG_FORCE_INLINE double F64_remainder(double a, double b) { return ::remainder(a, b); }\n"
"SLANG_FORCE_INLINE double F64_atan2(double a, double b) { return ::atan2(a, b); }\n"
"\n"
"SLANG_FORCE_INLINE double F64_frexp(double x, int* e) { return ::frexp(x, e); }\n"
"\n"
"SLANG_FORCE_INLINE double F64_modf(double x, double* ip)\n"
"{\n"
"    return ::modf(x, ip);\n"
"}\n"
"\n"
"// Ternary\n"
"SLANG_FORCE_INLINE double F64_fma(double a, double b, double c) { return ::fma(a, b, c); }\n"
"\n"
"#endif // SLANG_LLVM\n"
"\n"
"SLANG_FORCE_INLINE double F64_rsqrt(double f) { return 1.0 / F64_sqrt(f); }\n"
"SLANG_FORCE_INLINE double F64_sign(double f) { return (f == 0.0) ? f : ((f < 0.0) ? -1.0 : 1.0); }\n"
"SLANG_FORCE_INLINE double F64_frac(double f) { return f - F64_floor(f); }\n"
"\n"
"SLANG_FORCE_INLINE void F64_asuint(double d, uint32_t* low, uint32_t* hi)\n"
"{\n"
"    Union64 u;\n"
"    u.d = d;\n"
"    *low = uint32_t(u.u);\n"
"    *hi = uint32_t(u.u >> 32);\n"
"}\n"
"\n"
"SLANG_FORCE_INLINE void F64_asint(double d, int32_t* low, int32_t* hi)\n"
"{\n"
"    Union64 u;\n"
"    u.d = d;\n"
"    *low = int32_t(u.u);\n"
"    *hi = int32_t(u.u >> 32);\n"
"}\n"
"\n"
"SLANG_FORCE_INLINE double F64_calcSafeRadians(double radians)\n"
"{\n"
"    // Put 0 to 2pi cycles to cycle around 0 to 1 \n"
"\tdouble a = radians * (1.0f /  (SLANG_PRELUDE_PI * 2));\n"
"    // Get truncated fraction, as value in  0 - 1 range\n"
"    a = a - F64_floor(a);\n"
"    // Convert back to 0 - 2pi range\n"
"\treturn (a * (SLANG_PRELUDE_PI * 2));\n"
"}\n"
"\n"
"// ----------------------------- I32 -----------------------------------------\n"
"\n"
"SLANG_FORCE_INLINE int32_t I32_abs(int32_t f) { return (f < 0) ? -f : f; }\n"
"\n"
"SLANG_FORCE_INLINE int32_t I32_min(int32_t a, int32_t b) { return a < b ? a : b; }\n"
"SLANG_FORCE_INLINE int32_t I32_max(int32_t a, int32_t b) { return a > b ? a : b; }\n"
"\n"
"SLANG_FORCE_INLINE float I32_asfloat(int32_t x) { Union32 u; u.i = x; return u.f; }\n"
"SLANG_FORCE_INLINE uint32_t I32_asuint(int32_t x) { return uint32_t(x); }\n"
"SLANG_FORCE_INLINE double I32_asdouble(int32_t low, int32_t hi )\n"
"{\n"
"    Union64 u;\n"
"    u.u = (uint64_t(hi) << 32) | uint32_t(low);\n"
"    return u.d;\n"
"}\n"
"\n"
"// ----------------------------- U32 -----------------------------------------\n"
"\n"
"SLANG_FORCE_INLINE uint32_t U32_abs(uint32_t f) { return f; }\n"
"\n"
"SLANG_FORCE_INLINE uint32_t U32_min(uint32_t a, uint32_t b) { return a < b ? a : b; }\n"
"SLANG_FORCE_INLINE uint32_t U32_max(uint32_t a, uint32_t b) { return a > b ? a : b; }\n"
"\n"
"SLANG_FORCE_INLINE float U32_asfloat(uint32_t x) { Union32 u; u.u = x; return u.f; }\n"
"SLANG_FORCE_INLINE uint32_t U32_asint(int32_t x) { return uint32_t(x); } \n"
"\n"
"SLANG_FORCE_INLINE double U32_asdouble(uint32_t low, uint32_t hi)\n"
"{\n"
"    Union64 u;\n"
"    u.u = (uint64_t(hi) << 32) | low;\n"
"    return u.d;\n"
"}\n"
"\n"
"\n"
"SLANG_FORCE_INLINE uint32_t U32_countbits(uint32_t v)\n"
"{\n"
"#if SLANG_GCC_FAMILY && !defined(SLANG_LLVM)\n"
"    return __builtin_popcount(v);\n"
"#elif SLANG_PROCESSOR_X86_64 && SLANG_VC\n"
"    return __popcnt(v);\n"
"#else     \n"
"    uint32_t c = 0;\n"
"    while (v)\n"
"    {\n"
"        c++;\n"
"        v &= v - 1;\n"
"    }\n"
"    return c;\n"
"#endif\n"
"}\n"
"\n"
"// ----------------------------- U64 -----------------------------------------\n"
"\n"
"SLANG_FORCE_INLINE uint64_t U64_abs(uint64_t f) { return f; }\n"
"\n"
"SLANG_FORCE_INLINE uint64_t U64_min(uint64_t a, uint64_t b) { return a < b ? a : b; }\n"
"SLANG_FORCE_INLINE uint64_t U64_max(uint64_t a, uint64_t b) { return a > b ? a : b; }\n"
"\n"
"// TODO(JS): We don't define countbits for 64bit in stdlib currently.\n"
"// It's not clear from documentation if it should return 32 or 64 bits, if it exists. \n"
"// 32 bits can always hold the result, and will be implicitly promoted. \n"
"SLANG_FORCE_INLINE uint32_t U64_countbits(uint64_t v)\n"
"{\n"
"#if SLANG_GCC_FAMILY && !defined(SLANG_LLVM)   \n"
"    return uint32_t(__builtin_popcountl(v));\n"
"#elif SLANG_PROCESSOR_X86_64 && SLANG_VC\n"
"    return uint32_t(__popcnt64(v));\n"
"#else     \n"
"    uint32_t c = 0;\n"
"    while (v)\n"
"    {\n"
"        c++;\n"
"        v &= v - 1;\n"
"    }\n"
"    return c;\n"
"#endif\n"
"}\n"
"\n"
"// ----------------------------- I64 -----------------------------------------\n"
"\n"
"SLANG_FORCE_INLINE int64_t I64_abs(int64_t f) { return (f < 0) ? -f : f; }\n"
"\n"
"SLANG_FORCE_INLINE int64_t I64_min(int64_t a, int64_t b) { return a < b ? a : b; }\n"
"SLANG_FORCE_INLINE int64_t I64_max(int64_t a, int64_t b) { return a > b ? a : b; }\n"
"\n"
"\n"
"// ----------------------------- Interlocked ---------------------------------\n"
"\n"
"#if SLANG_LLVM\n"
"\n"
"#else // SLANG_LLVM\n"
"\n"
"#   ifdef _WIN32\n"
"#       include <intrin.h>\n"
"#   endif\n"
"\n"
"SLANG_FORCE_INLINE void InterlockedAdd(uint32_t* dest, uint32_t value, uint32_t* oldValue)\n"
"{\n"
"#   ifdef _WIN32\n"
"    *oldValue = _InterlockedExchangeAdd((long*)dest, (long)value);\n"
"#   else\n"
"    *oldValue = __sync_fetch_and_add(dest, value);\n"
"#   endif\n"
"}\n"
"\n"
"#endif // SLANG_LLVM\n"
"\n"
"\n"
"// ----------------------- fmod --------------------------\n"
"SLANG_FORCE_INLINE float _slang_fmod(float x, float y)\n"
"{\n"
"    return F32_fmod(x, y);\n"
"}\n"
"SLANG_FORCE_INLINE double _slang_fmod(double x, double y)\n"
"{\n"
"    return F64_fmod(x, y);\n"
"}\n"
"\n"
"#ifdef SLANG_PRELUDE_NAMESPACE\n"
"} \n"
"#endif\n"
"\n"
"#endif\n"
"\n"
"\n"
"\n"
"static const int kSlangTorchTensorMaxDim = 5;\n"
"\n"
"struct TensorView\n"
"{\n"
"    uint8_t* data;\n"
"    uint32_t strides[kSlangTorchTensorMaxDim];\n"
"    uint32_t sizes[kSlangTorchTensorMaxDim];\n"
"    uint32_t dimensionCount;\n"
"};\n"
"\n"
"\n"
"TensorView make_tensor_view(torch::Tensor val, const char* name, torch::ScalarType targetScalarType, bool requireContiguous)\n"
"{\n"
"    // We're currently not trying to implicitly cast or transfer to device for two reasons:\n"
"    // 1. There appears to be a bug with .to() where successive calls after the first one fail.\n"
"    // 2. Silent casts like this can cause large memory allocations & unexpected overheads. \n"
"    //    It's better to be explicit.\n"
"\n"
"    // Expect tensors to be on CUDA device\n"
"    if (!val.device().is_cuda())\n"
"        throw std::runtime_error(std::string(name).append(\": tensor is not on CUDA device.\").c_str());\n"
"\n"
"    // Expect tensors to be the right type.\n"
"    if (val.dtype() != targetScalarType)\n"
"        throw std::runtime_error(std::string(name).append(\": tensor is not of the expected type.\").c_str());\n"
"\n"
"    // Check that the tensor is contiguous\n"
"    if (requireContiguous && !val.is_contiguous())\n"
"        throw std::runtime_error(std::string(name).append(\": tensor is not contiguous.\").c_str());\n"
"\n"
"    TensorView res = {};\n"
"    res.dimensionCount = val.dim();\n"
"    res.data = nullptr;\n"
"    size_t elementSize = 4;\n"
"\n"
"    switch (val.scalar_type())\n"
"    {\n"
"    case torch::kInt8:\n"
"    case torch::kUInt8:\n"
"        elementSize = 1;\n"
"        res.data = (uint8_t*)val.data_ptr<uint8_t>();\n"
"        break;\n"
"    case torch::kBFloat16:\n"
"        elementSize = 2;\n"
"        res.data = (uint8_t*)val.data_ptr<torch::BFloat16>();\n"
"        break;\n"
"    case torch::kInt16:\n"
"        elementSize = 2;\n"
"        res.data = (uint8_t*)val.data_ptr<int16_t>();\n"
"        break;\n"
"    case torch::kFloat32:\n"
"        elementSize = 4;\n"
"        res.data = (uint8_t*)val.data_ptr<float>();\n"
"        break;\n"
"    case torch::kInt32:\n"
"        elementSize = 4;\n"
"        res.data = (uint8_t*)val.data_ptr<int32_t>();\n"
"        break;\n"
"    case torch::kFloat64:\n"
"        elementSize = 8;\n"
"        res.data = (uint8_t*)val.data_ptr<double>();\n"
"        break;\n"
"    case torch::kInt64:\n"
"        elementSize = 8;\n"
"        res.data = (uint8_t*)val.data_ptr<int64_t>();\n"
"        break;\n"
"    case torch::kBool:\n"
"        elementSize = 1;\n"
"        res.data = (uint8_t*)val.data_ptr<bool>();\n"
"        break;\n"
"    }\n"
"\n"
"    if (val.dim() > kSlangTorchTensorMaxDim)\n"
"        throw std::runtime_error(std::string(name).append(\": number of dimensions exceeds limit (\").append(std::to_string(kSlangTorchTensorMaxDim)).append(\")\").c_str());\n"
"\n"
"    for (int i = 0; i < val.dim(); ++i)\n"
"    {\n"
"        res.strides[i] = val.stride(i) * elementSize;\n"
"        res.sizes[i] = val.size(i);\n"
"    }\n"
"    if (!res.data)\n"
"        throw std::runtime_error(std::string(name).append(\": data pointer is invalid.\").c_str());\n"
"    return res;\n"
"}\n"
"\n"
"#define SLANG_PRELUDE_EXPORT\n"
"\n"
;
return sb.produceString();
}
