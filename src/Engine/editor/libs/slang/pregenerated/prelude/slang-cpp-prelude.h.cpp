// generated code; do not edit
#include "../source/core/slang-basic.h"
Slang::String get_slang_cpp_prelude()
{
Slang::StringBuilder sb;
sb << 
"#ifndef SLANG_CPP_PRELUDE_H\n"
"#define SLANG_CPP_PRELUDE_H\n"
"\n"
"// Because the signiture of isnan, isfinite, and is isinf changed in C++, we use the macro\n"
"// to use the version in the std namespace. \n"
"// https://stackoverflow.com/questions/39130040/cmath-hides-isnan-in-math-h-in-c14-c11\n"
" \n"
"#ifdef SLANG_LLVM\n"
"#ifndef SLANG_LLVM_H\n"
"#define SLANG_LLVM_H\n"
"\n"
"// TODO(JS): \n"
"// Disable exception declspecs, as not supported on LLVM without some extra options.\n"
"// We could enable with `-fms-extensions`\n"
"#define SLANG_DISABLE_EXCEPTIONS 1\n"
"\n"
"#ifndef SLANG_PRELUDE_ASSERT\n"
"#   ifdef SLANG_PRELUDE_ENABLE_ASSERT\n"
"extern \"C\" void assertFailure(const char* msg);\n"
"#       define SLANG_PRELUDE_EXPECT(VALUE, MSG) if(VALUE) {} else assertFailure(\"assertion failed: '\" MSG \"'\")\n"
"#       define SLANG_PRELUDE_ASSERT(VALUE) SLANG_PRELUDE_EXPECT(VALUE, #VALUE)\n"
"#   else // SLANG_PRELUDE_ENABLE_ASSERT\n"
"#       define SLANG_PRELUDE_EXPECT(VALUE, MSG)\n"
"#       define SLANG_PRELUDE_ASSERT(x) \n"
"#   endif // SLANG_PRELUDE_ENABLE_ASSERT\n"
"#endif\n"
"\n"
"/*\n"
"Taken from stddef.h \n"
"*/\n"
"\n"
"typedef __PTRDIFF_TYPE__ ptrdiff_t;\n"
"typedef __SIZE_TYPE__ size_t;\n"
"typedef __SIZE_TYPE__ rsize_t;\n"
"\n"
"//typedef __WCHAR_TYPE__ wchar_t;\n"
"\n"
"#if defined(__need_NULL)\n"
"#undef NULL\n"
"#ifdef __cplusplus\n"
"#  if !defined(__MINGW32__) && !defined(_MSC_VER)\n"
"#    define NULL __null\n"
"#  else\n"
"#    define NULL 0\n"
"#  endif\n"
"#else\n"
"#  define NULL ((void*)0)\n"
"#endif\n"
"#ifdef __cplusplus\n"
"#if defined(_MSC_EXTENSIONS) && defined(_NATIVE_NULLPTR_SUPPORTED)\n"
"namespace std { typedef decltype(nullptr) nullptr_t; }\n"
"using ::std::nullptr_t;\n"
"#endif\n"
"#endif\n"
"#undef __need_NULL\n"
"#endif /* defined(__need_NULL) */\n"
"\n"
"\n"
"/*\n"
"The following are taken verbatim from stdint.h from Clang in LLVM. Only 8/16/32/64 types are needed. \n"
"*/\n"
"\n"
"// LLVM/Clang types such that we can use LLVM/Clang without headers for C++ output from Slang\n"
"\n"
"#ifdef __INT64_TYPE__\n"
"# ifndef __int8_t_defined /* glibc sys/types.h also defines int64_t*/\n"
"typedef __INT64_TYPE__ int64_t;\n"
"# endif /* __int8_t_defined */\n"
"typedef __UINT64_TYPE__ uint64_t;\n"
"# define __int_least64_t int64_t\n"
"# define __uint_least64_t uint64_t\n"
"#endif /* __INT64_TYPE__ */\n"
"\n"
"#ifdef __int_least64_t\n"
"typedef __int_least64_t int_least64_t;\n"
"typedef __uint_least64_t uint_least64_t;\n"
"typedef __int_least64_t int_fast64_t;\n"
"typedef __uint_least64_t uint_fast64_t;\n"
"#endif /* __int_least64_t */\n"
"\n"
"#ifdef __INT32_TYPE__\n"
"\n"
"# ifndef __int8_t_defined /* glibc sys/types.h also defines int32_t*/\n"
"typedef __INT32_TYPE__ int32_t;\n"
"# endif /* __int8_t_defined */\n"
"\n"
"# ifndef __uint32_t_defined  /* more glibc compatibility */\n"
"# define __uint32_t_defined\n"
"typedef __UINT32_TYPE__ uint32_t;\n"
"# endif /* __uint32_t_defined */\n"
"\n"
"# define __int_least32_t int32_t\n"
"# define __uint_least32_t uint32_t\n"
"#endif /* __INT32_TYPE__ */\n"
"\n"
"#ifdef __int_least32_t\n"
"typedef __int_least32_t int_least32_t;\n"
"typedef __uint_least32_t uint_least32_t;\n"
"typedef __int_least32_t int_fast32_t;\n"
"typedef __uint_least32_t uint_fast32_t;\n"
"#endif /* __int_least32_t */\n"
"\n"
"#ifdef __INT16_TYPE__\n"
"#ifndef __int8_t_defined /* glibc sys/types.h also defines int16_t*/\n"
"typedef __INT16_TYPE__ int16_t;\n"
"#endif /* __int8_t_defined */\n"
"typedef __UINT16_TYPE__ uint16_t;\n"
"# define __int_least16_t int16_t\n"
"# define __uint_least16_t uint16_t\n"
"#endif /* __INT16_TYPE__ */\n"
"\n"
"#ifdef __int_least16_t\n"
"typedef __int_least16_t int_least16_t;\n"
"typedef __uint_least16_t uint_least16_t;\n"
"typedef __int_least16_t int_fast16_t;\n"
"typedef __uint_least16_t uint_fast16_t;\n"
"#endif /* __int_least16_t */\n"
"\n"
"#ifdef __INT8_TYPE__\n"
"#ifndef __int8_t_defined  /* glibc sys/types.h also defines int8_t*/\n"
"typedef __INT8_TYPE__ int8_t;\n"
"#endif /* __int8_t_defined */\n"
"typedef __UINT8_TYPE__ uint8_t;\n"
"# define __int_least8_t int8_t\n"
"# define __uint_least8_t uint8_t\n"
"#endif /* __INT8_TYPE__ */\n"
"\n"
"#ifdef __int_least8_t\n"
"typedef __int_least8_t int_least8_t;\n"
"typedef __uint_least8_t uint_least8_t;\n"
"typedef __int_least8_t int_fast8_t;\n"
"typedef __uint_least8_t uint_fast8_t;\n"
"#endif /* __int_least8_t */\n"
"\n"
"/* prevent glibc sys/types.h from defining conflicting types */\n"
"#ifndef __int8_t_defined\n"
"# define __int8_t_defined\n"
"#endif /* __int8_t_defined */\n"
"\n"
"/* C99 7.18.1.4 Integer types capable of holding object pointers.\n"
" */\n"
"#define __stdint_join3(a,b,c) a ## b ## c\n"
"\n"
"#ifndef _INTPTR_T\n"
"#ifndef __intptr_t_defined\n"
"typedef __INTPTR_TYPE__ intptr_t;\n"
"#define __intptr_t_defined\n"
"#define _INTPTR_T\n"
"#endif\n"
"#endif\n"
"\n"
"#ifndef _UINTPTR_T\n"
"typedef __UINTPTR_TYPE__ uintptr_t;\n"
"#define _UINTPTR_T\n"
"#endif\n"
"\n"
"/* C99 7.18.1.5 Greatest-width integer types.\n"
" */\n"
"typedef __INTMAX_TYPE__  intmax_t;\n"
"typedef __UINTMAX_TYPE__ uintmax_t;\n"
"\n"
"/* C99 7.18.4 Macros for minimum-width integer constants.\n"
" *\n"
" * The standard requires that integer constant macros be defined for all the\n"
" * minimum-width types defined above. As 8-, 16-, 32-, and 64-bit minimum-width\n"
" * types are required, the corresponding integer constant macros are defined\n"
" * here. This implementation also defines minimum-width types for every other\n"
" * integer width that the target implements, so corresponding macros are\n"
" * defined below, too.\n"
" *\n"
" * These macros are defined using the same successive-shrinking approach as\n"
" * the type definitions above. It is likewise important that macros are defined\n"
" * in order of decending width.\n"
" *\n"
" * Note that C++ should not check __STDC_CONSTANT_MACROS here, contrary to the\n"
" * claims of the C standard (see C++ 18.3.1p2, [cstdint.syn]).\n"
" */\n"
"\n"
"#define __int_c_join(a, b) a ## b\n"
"#define __int_c(v, suffix) __int_c_join(v, suffix)\n"
"#define __uint_c(v, suffix) __int_c_join(v##U, suffix)\n"
"\n"
"#ifdef __INT64_TYPE__\n"
"# ifdef __INT64_C_SUFFIX__\n"
"#  define __int64_c_suffix __INT64_C_SUFFIX__\n"
"# else\n"
"#  undef __int64_c_suffix\n"
"# endif /* __INT64_C_SUFFIX__ */\n"
"#endif /* __INT64_TYPE__ */\n"
"\n"
"#ifdef __int_least64_t\n"
"# ifdef __int64_c_suffix\n"
"#  define INT64_C(v) __int_c(v, __int64_c_suffix)\n"
"#  define UINT64_C(v) __uint_c(v, __int64_c_suffix)\n"
"# else\n"
"#  define INT64_C(v) v\n"
"#  define UINT64_C(v) v ## U\n"
"# endif /* __int64_c_suffix */\n"
"#endif /* __int_least64_t */\n"
"\n"
"\n"
"#ifdef __INT32_TYPE__\n"
"# ifdef __INT32_C_SUFFIX__\n"
"#  define __int32_c_suffix __INT32_C_SUFFIX__\n"
"#else\n"
"#  undef __int32_c_suffix\n"
"# endif /* __INT32_C_SUFFIX__ */\n"
"#endif /* __INT32_TYPE__ */\n"
"\n"
"#ifdef __int_least32_t\n"
"# ifdef __int32_c_suffix\n"
"#  define INT32_C(v) __int_c(v, __int32_c_suffix)\n"
"#  define UINT32_C(v) __uint_c(v, __int32_c_suffix)\n"
"# else\n"
"#  define INT32_C(v) v\n"
"#  define UINT32_C(v) v ## U\n"
"# endif /* __int32_c_suffix */\n"
"#endif /* __int_least32_t */\n"
"\n"
"#ifdef __INT16_TYPE__\n"
"# ifdef __INT16_C_SUFFIX__\n"
"#  define __int16_c_suffix __INT16_C_SUFFIX__\n"
"#else\n"
"#  undef __int16_c_suffix\n"
"# endif /* __INT16_C_SUFFIX__ */\n"
"#endif /* __INT16_TYPE__ */\n"
"\n"
"#ifdef __int_least16_t\n"
"# ifdef __int16_c_suffix\n"
"#  define INT16_C(v) __int_c(v, __int16_c_suffix)\n"
"#  define UINT16_C(v) __uint_c(v, __int16_c_suffix)\n"
"# else\n"
"#  define INT16_C(v) v\n"
"#  define UINT16_C(v) v ## U\n"
"# endif /* __int16_c_suffix */\n"
"#endif /* __int_least16_t */\n"
"\n"
"\n"
"#ifdef __INT8_TYPE__\n"
"# ifdef __INT8_C_SUFFIX__\n"
"#  define __int8_c_suffix __INT8_C_SUFFIX__\n"
"#else\n"
"#  undef  __int8_c_suffix\n"
"# endif /* __INT8_C_SUFFIX__ */\n"
"#endif /* __INT8_TYPE__ */\n"
"\n"
"#ifdef __int_least8_t\n"
"# ifdef __int8_c_suffix\n"
"#  define INT8_C(v) __int_c(v, __int8_c_suffix)\n"
"#  define UINT8_C(v) __uint_c(v, __int8_c_suffix)\n"
"# else\n"
"#  define INT8_C(v) v\n"
"#  define UINT8_C(v) v ## U\n"
"# endif /* __int8_c_suffix */\n"
"#endif /* __int_least8_t */\n"
"\n"
"/* C99 7.18.2.1 Limits of exact-width integer types.\n"
" * C99 7.18.2.2 Limits of minimum-width integer types.\n"
" * C99 7.18.2.3 Limits of fastest minimum-width integer types.\n"
" *\n"
" * The presence of limit macros are completely optional in C99.  This\n"
" * implementation defines limits for all of the types (exact- and\n"
" * minimum-width) that it defines above, using the limits of the minimum-width\n"
" * type for any types that do not have exact-width representations.\n"
" *\n"
" * As in the type definitions, this section takes an approach of\n"
" * successive-shrinking to determine which limits to use for the standard (8,\n"
" * 16, 32, 64) bit widths when they don't have exact representations. It is\n"
" * therefore important that the definitions be kept in order of decending\n"
" * widths.\n"
" *\n"
" * Note that C++ should not check __STDC_LIMIT_MACROS here, contrary to the\n"
" * claims of the C standard (see C++ 18.3.1p2, [cstdint.syn]).\n"
" */\n"
"\n"
"#ifdef __INT64_TYPE__\n"
"# define INT64_MAX           INT64_C( 9223372036854775807)\n"
"# define INT64_MIN         (-INT64_C( 9223372036854775807)-1)\n"
"# define UINT64_MAX         UINT64_C(18446744073709551615)\n"
"# define __INT_LEAST64_MIN   INT64_MIN\n"
"# define __INT_LEAST64_MAX   INT64_MAX\n"
"# define __UINT_LEAST64_MAX UINT64_MAX\n"
"#endif /* __INT64_TYPE__ */\n"
"\n"
"#ifdef __INT_LEAST64_MIN\n"
"# define INT_LEAST64_MIN   __INT_LEAST64_MIN\n"
"# define INT_LEAST64_MAX   __INT_LEAST64_MAX\n"
"# define UINT_LEAST64_MAX __UINT_LEAST64_MAX\n"
"# define INT_FAST64_MIN    __INT_LEAST64_MIN\n"
"# define INT_FAST64_MAX    __INT_LEAST64_MAX\n"
"# define UINT_FAST64_MAX  __UINT_LEAST64_MAX\n"
"#endif /* __INT_LEAST64_MIN */\n"
"\n"
"#ifdef __INT32_TYPE__\n"
"# define INT32_MAX           INT32_C(2147483647)\n"
"# define INT32_MIN         (-INT32_C(2147483647)-1)\n"
"# define UINT32_MAX         UINT32_C(4294967295)\n"
"# define __INT_LEAST32_MIN   INT32_MIN\n"
"# define __INT_LEAST32_MAX   INT32_MAX\n"
"# define __UINT_LEAST32_MAX UINT32_MAX\n"
"#endif /* __INT32_TYPE__ */\n"
"\n"
"#ifdef __INT_LEAST32_MIN\n"
"# define INT_LEAST32_MIN   __INT_LEAST32_MIN\n"
"# define INT_LEAST32_MAX   __INT_LEAST32_MAX\n"
"# define UINT_LEAST32_MAX __UINT_LEAST32_MAX\n"
"# define INT_FAST32_MIN    __INT_LEAST32_MIN\n"
"# define INT_FAST32_MAX    __INT_LEAST32_MAX\n"
"# define UINT_FAST32_MAX  __UINT_LEAST32_MAX\n"
"#endif /* __INT_LEAST32_MIN */\n"
"\n"
"#ifdef __INT16_TYPE__\n"
"#define INT16_MAX            INT16_C(32767)\n"
"#define INT16_MIN          (-INT16_C(32767)-1)\n"
"#define UINT16_MAX          UINT16_C(65535)\n"
"# define __INT_LEAST16_MIN   INT16_MIN\n"
"# define __INT_LEAST16_MAX   INT16_MAX\n"
"# define __UINT_LEAST16_MAX UINT16_MAX\n"
"#endif /* __INT16_TYPE__ */\n"
"\n"
"#ifdef __INT_LEAST16_MIN\n"
"# define INT_LEAST16_MIN   __INT_LEAST16_MIN\n"
"# define INT_LEAST16_MAX   __INT_LEAST16_MAX\n"
"# define UINT_LEAST16_MAX __UINT_LEAST16_MAX\n"
"# define INT_FAST16_MIN    __INT_LEAST16_MIN\n"
"# define INT_FAST16_MAX    __INT_LEAST16_MAX\n"
"# define UINT_FAST16_MAX  __UINT_LEAST16_MAX\n"
"#endif /* __INT_LEAST16_MIN */\n"
"\n"
"\n"
"#ifdef __INT8_TYPE__\n"
"# define INT8_MAX            INT8_C(127)\n"
"# define INT8_MIN          (-INT8_C(127)-1)\n"
"# define UINT8_MAX          UINT8_C(255)\n"
"# define __INT_LEAST8_MIN    INT8_MIN\n"
"# define __INT_LEAST8_MAX    INT8_MAX\n"
"# define __UINT_LEAST8_MAX  UINT8_MAX\n"
"#endif /* __INT8_TYPE__ */\n"
"\n"
"#ifdef __INT_LEAST8_MIN\n"
"# define INT_LEAST8_MIN   __INT_LEAST8_MIN\n"
"# define INT_LEAST8_MAX   __INT_LEAST8_MAX\n"
"# define UINT_LEAST8_MAX __UINT_LEAST8_MAX\n"
"# define INT_FAST8_MIN    __INT_LEAST8_MIN\n"
"# define INT_FAST8_MAX    __INT_LEAST8_MAX\n"
"# define UINT_FAST8_MAX  __UINT_LEAST8_MAX\n"
"#endif /* __INT_LEAST8_MIN */\n"
"\n"
"/* Some utility macros */\n"
"#define  __INTN_MIN(n)  __stdint_join3( INT, n, _MIN)\n"
"#define  __INTN_MAX(n)  __stdint_join3( INT, n, _MAX)\n"
"#define __UINTN_MAX(n)  __stdint_join3(UINT, n, _MAX)\n"
"#define  __INTN_C(n, v) __stdint_join3( INT, n, _C(v))\n"
"#define __UINTN_C(n, v) __stdint_join3(UINT, n, _C(v))\n"
"\n"
"/* C99 7.18.2.4 Limits of integer types capable of holding object pointers. */\n"
"/* C99 7.18.3 Limits of other integer types. */\n"
"\n"
"#define  INTPTR_MIN  (-__INTPTR_MAX__-1)\n"
"#define  INTPTR_MAX    __INTPTR_MAX__\n"
"#define UINTPTR_MAX   __UINTPTR_MAX__\n"
"#define PTRDIFF_MIN (-__PTRDIFF_MAX__-1)\n"
"#define PTRDIFF_MAX   __PTRDIFF_MAX__\n"
"#define    SIZE_MAX      __SIZE_MAX__\n"
"\n"
"/* ISO9899:2011 7.20 (C11 Annex K): Define RSIZE_MAX if __STDC_WANT_LIB_EXT1__\n"
" * is enabled. */\n"
"#if defined(__STDC_WANT_LIB_EXT1__) && __STDC_WANT_LIB_EXT1__ >= 1\n"
"#define   RSIZE_MAX            (SIZE_MAX >> 1)\n"
"#endif\n"
"\n"
"/* C99 7.18.2.5 Limits of greatest-width integer types. */\n"
"#define  INTMAX_MIN (-__INTMAX_MAX__-1)\n"
"#define  INTMAX_MAX   __INTMAX_MAX__\n"
"#define UINTMAX_MAX  __UINTMAX_MAX__\n"
"\n"
"/* C99 7.18.3 Limits of other integer types. */\n"
"#define SIG_ATOMIC_MIN __INTN_MIN(__SIG_ATOMIC_WIDTH__)\n"
"#define SIG_ATOMIC_MAX __INTN_MAX(__SIG_ATOMIC_WIDTH__)\n"
"#ifdef __WINT_UNSIGNED__\n"
"# define WINT_MIN       __UINTN_C(__WINT_WIDTH__, 0)\n"
"# define WINT_MAX       __UINTN_MAX(__WINT_WIDTH__)\n"
"#else\n"
"# define WINT_MIN       __INTN_MIN(__WINT_WIDTH__)\n"
"# define WINT_MAX       __INTN_MAX(__WINT_WIDTH__)\n"
"#endif\n"
"\n"
"#ifndef WCHAR_MAX\n"
"# define WCHAR_MAX __WCHAR_MAX__\n"
"#endif\n"
"#ifndef WCHAR_MIN\n"
"# if __WCHAR_MAX__ == __INTN_MAX(__WCHAR_WIDTH__)\n"
"#  define WCHAR_MIN __INTN_MIN(__WCHAR_WIDTH__)\n"
"# else\n"
"#  define WCHAR_MIN __UINTN_C(__WCHAR_WIDTH__, 0)\n"
"# endif\n"
"#endif\n"
"\n"
"/* 7.18.4.2 Macros for greatest-width integer constants. */\n"
"#define  INTMAX_C(v) __int_c(v,  __INTMAX_C_SUFFIX__)\n"
"#define UINTMAX_C(v) __int_c(v, __UINTMAX_C_SUFFIX__)\n"
"\n"
"\n"
"#endif // SLANG_LLVM_H\n"
"\n"
"\n"
"\n"
"#else // SLANG_LLVM\n"
"#   if SLANG_GCC_FAMILY && __GNUC__ < 6\n"
"#       include <cmath>\n"
"#       define SLANG_PRELUDE_STD std::\n"
"#   else\n"
"#       include <math.h>\n"
"#       define SLANG_PRELUDE_STD\n"
"#   endif\n"
"\n"
"#   include <assert.h>\n"
"#   include <stdlib.h>\n"
"#   include <string.h>\n"
"#   include <stdint.h>\n"
"#endif // SLANG_LLVM\n"
"\n"
"#if defined(_MSC_VER)\n"
"#   define SLANG_PRELUDE_SHARED_LIB_EXPORT __declspec(dllexport)\n"
"#else\n"
"#   define SLANG_PRELUDE_SHARED_LIB_EXPORT __attribute__((__visibility__(\"default\")))\n"
"//#   define SLANG_PRELUDE_SHARED_LIB_EXPORT __attribute__ ((dllexport)) __attribute__((__visibility__(\"default\")))\n"
"#endif    \n"
"\n"
"#ifdef __cplusplus    \n"
"#   define SLANG_PRELUDE_EXTERN_C extern \"C\"\n"
"#   define SLANG_PRELUDE_EXTERN_C_START extern \"C\" {\n"
"#   define SLANG_PRELUDE_EXTERN_C_END }\n"
"#else\n"
"#   define SLANG_PRELUDE_EXTERN_C \n"
"#   define SLANG_PRELUDE_EXTERN_C_START\n"
"#   define SLANG_PRELUDE_EXTERN_C_END \n"
"#endif    \n"
"\n"
"#define SLANG_PRELUDE_EXPORT SLANG_PRELUDE_EXTERN_C SLANG_PRELUDE_SHARED_LIB_EXPORT\n"
"#define SLANG_PRELUDE_EXPORT_START SLANG_PRELUDE_EXTERN_C_START SLANG_PRELUDE_SHARED_LIB_EXPORT\n"
"#define SLANG_PRELUDE_EXPORT_END SLANG_PRELUDE_EXTERN_C_END\n"
"\n"
"#ifndef INFINITY\n"
"// Must overflow for double\n"
"#   define INFINITY float(1e+300 * 1e+300)\n"
"#endif\n"
"\n"
"#ifndef SLANG_INFINITY\n"
"#   define SLANG_INFINITY   INFINITY\n"
"#endif\n"
"\n"
"// Detect the compiler type\n"
"\n"
"#ifndef SLANG_COMPILER\n"
"#    define SLANG_COMPILER\n"
"\n"
"/*\n"
"Compiler defines, see http://sourceforge.net/p/predef/wiki/Compilers/\n"
"NOTE that SLANG_VC holds the compiler version - not just 1 or 0\n"
"*/\n"
"#    if defined(_MSC_VER)\n"
"#        if _MSC_VER >= 1900\n"
"#            define SLANG_VC 14\n"
"#        elif _MSC_VER >= 1800\n"
"#            define SLANG_VC 12\n"
"#        elif _MSC_VER >= 1700\n"
"#            define SLANG_VC 11\n"
"#        elif _MSC_VER >= 1600\n"
"#            define SLANG_VC 10\n"
"#        elif _MSC_VER >= 1500\n"
"#            define SLANG_VC 9\n"
"#        else\n"
"#            error \"unknown version of Visual C++ compiler\"\n"
"#        endif\n"
"#    elif defined(__clang__)\n"
"#        define SLANG_CLANG 1\n"
"#    elif defined(__SNC__)\n"
"#        define SLANG_SNC 1\n"
"#    elif defined(__ghs__)\n"
"#        define SLANG_GHS 1\n"
"#    elif defined(__GNUC__) /* note: __clang__, __SNC__, or __ghs__ imply __GNUC__ */\n"
"#        define SLANG_GCC 1\n"
"#    else\n"
"#        error \"unknown compiler\"\n"
"#    endif\n"
"/*\n"
"Any compilers not detected by the above logic are now now explicitly zeroed out.\n"
"*/\n"
"#    ifndef SLANG_VC\n"
"#        define SLANG_VC 0\n"
"#    endif\n"
"#    ifndef SLANG_CLANG\n"
"#        define SLANG_CLANG 0\n"
"#    endif\n"
"#    ifndef SLANG_SNC\n"
"#        define SLANG_SNC 0\n"
"#    endif\n"
"#    ifndef SLANG_GHS\n"
"#        define SLANG_GHS 0\n"
"#    endif\n"
"#    ifndef SLANG_GCC\n"
"#        define SLANG_GCC 0\n"
"#    endif\n"
"#endif /* SLANG_COMPILER */\n"
"\n"
"/*\n"
"The following section attempts to detect the target platform being compiled for.\n"
"\n"
"If an application defines `SLANG_PLATFORM` before including this header,\n"
"they take responsibility for setting any compiler-dependent macros\n"
"used later in the file.\n"
"\n"
"Most applications should not need to touch this section.\n"
"*/\n"
"#ifndef SLANG_PLATFORM\n"
"#    define SLANG_PLATFORM\n"
"/**\n"
"Operating system defines, see http://sourceforge.net/p/predef/wiki/OperatingSystems/\n"
"*/\n"
"#    if defined(WINAPI_FAMILY) && WINAPI_FAMILY == WINAPI_PARTITION_APP\n"
"#        define SLANG_WINRT 1 /* Windows Runtime, either on Windows RT or Windows 8 */\n"
"#    elif defined(XBOXONE)\n"
"#        define SLANG_XBOXONE 1\n"
"#    elif defined(_WIN64) /* note: XBOXONE implies _WIN64 */\n"
"#        define SLANG_WIN64 1\n"
"#    elif defined(_M_PPC)\n"
"#        define SLANG_X360 1\n"
"#    elif defined(_WIN32) /* note: _M_PPC implies _WIN32 */\n"
"#        define SLANG_WIN32 1\n"
"#    elif defined(__ANDROID__)\n"
"#        define SLANG_ANDROID 1\n"
"#    elif defined(__linux__) || defined(__CYGWIN__) /* note: __ANDROID__ implies __linux__ */\n"
"#        define SLANG_LINUX 1\n"
"#    elif defined(__APPLE__) && !defined(SLANG_LLVM)\n"
"#        include \"TargetConditionals.h\"\n"
"#        if TARGET_OS_MAC\n"
"#            define SLANG_OSX 1\n"
"#        else\n"
"#            define SLANG_IOS 1\n"
"#        endif\n"
"#    elif defined(__APPLE__)\n"
"// On `slang-llvm` we can't inclue \"TargetConditionals.h\" in general, so for now assume its OSX.\n"
"#       define SLANG_OSX 1\n"
"#    elif defined(__CELLOS_LV2__)\n"
"#        define SLANG_PS3 1\n"
"#    elif defined(__ORBIS__)\n"
;
sb << 
"#        define SLANG_PS4 1\n"
"#    elif defined(__SNC__) && defined(__arm__)\n"
"#        define SLANG_PSP2 1\n"
"#    elif defined(__ghs__)\n"
"#        define SLANG_WIIU 1\n"
"#    else\n"
"#        error \"unknown target platform\"\n"
"#    endif\n"
"\n"
"\n"
"/*\n"
"Any platforms not detected by the above logic are now now explicitly zeroed out.\n"
"*/\n"
"#    ifndef SLANG_WINRT\n"
"#        define SLANG_WINRT 0\n"
"#    endif\n"
"#    ifndef SLANG_XBOXONE\n"
"#        define SLANG_XBOXONE 0\n"
"#    endif\n"
"#    ifndef SLANG_WIN64\n"
"#        define SLANG_WIN64 0\n"
"#    endif\n"
"#    ifndef SLANG_X360\n"
"#        define SLANG_X360 0\n"
"#    endif\n"
"#    ifndef SLANG_WIN32\n"
"#        define SLANG_WIN32 0\n"
"#    endif\n"
"#    ifndef SLANG_ANDROID\n"
"#        define SLANG_ANDROID 0\n"
"#    endif\n"
"#    ifndef SLANG_LINUX\n"
"#        define SLANG_LINUX 0\n"
"#    endif\n"
"#    ifndef SLANG_IOS\n"
"#        define SLANG_IOS 0\n"
"#    endif\n"
"#    ifndef SLANG_OSX\n"
"#        define SLANG_OSX 0\n"
"#    endif\n"
"#    ifndef SLANG_PS3\n"
"#        define SLANG_PS3 0\n"
"#    endif\n"
"#    ifndef SLANG_PS4\n"
"#        define SLANG_PS4 0\n"
"#    endif\n"
"#    ifndef SLANG_PSP2\n"
"#        define SLANG_PSP2 0\n"
"#    endif\n"
"#    ifndef SLANG_WIIU\n"
"#        define SLANG_WIIU 0\n"
"#    endif\n"
"#endif /* SLANG_PLATFORM */\n"
"\n"
"/* Shorthands for \"families\" of compilers/platforms */\n"
"#define SLANG_GCC_FAMILY (SLANG_CLANG || SLANG_SNC || SLANG_GHS || SLANG_GCC)\n"
"#define SLANG_WINDOWS_FAMILY (SLANG_WINRT || SLANG_WIN32 || SLANG_WIN64)\n"
"#define SLANG_MICROSOFT_FAMILY (SLANG_XBOXONE || SLANG_X360 || SLANG_WINDOWS_FAMILY)\n"
"#define SLANG_LINUX_FAMILY (SLANG_LINUX || SLANG_ANDROID)\n"
"#define SLANG_APPLE_FAMILY (SLANG_IOS || SLANG_OSX)                  /* equivalent to #if __APPLE__ */\n"
"#define SLANG_UNIX_FAMILY (SLANG_LINUX_FAMILY || SLANG_APPLE_FAMILY) /* shortcut for unix/posix platforms */\n"
"\n"
"// GCC Specific\n"
"#if SLANG_GCC_FAMILY\n"
"#\tdefine SLANG_ALIGN_OF(T)\t__alignof__(T)\n"
"\n"
"#   define SLANG_BREAKPOINT(id) __builtin_trap()\n"
"\n"
"// Use this macro instead of offsetof, because gcc produces warning if offsetof is used on a \n"
"// non POD type, even though it produces the correct result\n"
"#   define SLANG_OFFSET_OF(T, ELEMENT) (size_t(&((T*)1)->ELEMENT) - 1)\n"
"#endif // SLANG_GCC_FAMILY\n"
"\n"
"// Microsoft VC specific\n"
"#if SLANG_VC\n"
"#   define SLANG_ALIGN_OF(T) __alignof(T)\n"
"\n"
"#\tdefine SLANG_BREAKPOINT(id) __debugbreak();\n"
"\n"
"#endif // SLANG_VC\n"
"\n"
"// Default impls\n"
"\n"
"#ifndef SLANG_OFFSET_OF\n"
"#   define SLANG_OFFSET_OF(X, Y) offsetof(X, Y)\n"
"#endif\n"
"\n"
"#ifndef SLANG_BREAKPOINT\n"
"// Make it crash with a write to 0!\n"
"#   define SLANG_BREAKPOINT(id) (*((int*)0) = int(id));\n"
"#endif\n"
"\n"
"// If slang.h has been included we don't need any of these definitions\n"
"#ifndef SLANG_H\n"
"\n"
"/* Macro for declaring if a method is no throw. Should be set before the return parameter. */\n"
"#ifndef SLANG_NO_THROW\n"
"#   if SLANG_WINDOWS_FAMILY && !defined(SLANG_DISABLE_EXCEPTIONS)\n"
"#       define SLANG_NO_THROW __declspec(nothrow)\n"
"#   endif\n"
"#endif\n"
"#ifndef SLANG_NO_THROW\n"
"#   define SLANG_NO_THROW\n"
"#endif\n"
"\n"
"/* The `SLANG_STDCALL` and `SLANG_MCALL` defines are used to set the calling\n"
"convention for interface methods.\n"
"*/\n"
"#ifndef SLANG_STDCALL\n"
"#   if SLANG_MICROSOFT_FAMILY\n"
"#       define SLANG_STDCALL __stdcall\n"
"#   else\n"
"#       define SLANG_STDCALL\n"
"#   endif\n"
"#endif\n"
"#ifndef SLANG_MCALL\n"
"#   define SLANG_MCALL SLANG_STDCALL\n"
"#endif\n"
"\n"
"#ifndef SLANG_FORCE_INLINE\n"
"#    define SLANG_FORCE_INLINE inline\n"
"#endif\n"
"\n"
"// TODO(JS): Should these be in slang-cpp-types.h? \n"
"// They are more likely to clash with slang.h\n"
"\n"
"struct SlangUUID\n"
"{\n"
"    uint32_t data1;\n"
"    uint16_t data2;\n"
"    uint16_t data3;\n"
"    uint8_t  data4[8];\n"
"};\n"
"\n"
"typedef int32_t SlangResult;\n"
"\n"
"struct ISlangUnknown\n"
"{\n"
"    virtual SLANG_NO_THROW SlangResult SLANG_MCALL queryInterface(SlangUUID const& uuid, void** outObject) = 0;\n"
"    virtual SLANG_NO_THROW uint32_t SLANG_MCALL addRef() = 0;\n"
"    virtual SLANG_NO_THROW uint32_t SLANG_MCALL release() = 0;\n"
"};\n"
"\n"
"#define SLANG_COM_INTERFACE(a, b, c, d0, d1, d2, d3, d4, d5, d6, d7) \\\n"
"    public: \\\n"
"    SLANG_FORCE_INLINE static const SlangUUID& getTypeGuid() \\\n"
"    { \\\n"
"        static const SlangUUID guid = { a, b, c, d0, d1, d2, d3, d4, d5, d6, d7 }; \\\n"
"        return guid; \\\n"
"    }\n"
"#endif // SLANG_H\n"
"\n"
"// Includes\n"
"\n"
"#ifndef SLANG_PRELUDE_SCALAR_INTRINSICS_H\n"
"#define SLANG_PRELUDE_SCALAR_INTRINSICS_H\n"
"\n"
"#if !defined(SLANG_LLVM) && SLANG_PROCESSOR_X86_64 && SLANG_VC\n"
"//  If we have visual studio and 64 bit processor, we can assume we have popcnt, and can include x86 intrinsics\n"
"#   include <intrin.h>\n"
"#endif\n"
"\n"
"#ifndef SLANG_FORCE_INLINE\n"
"#    define SLANG_FORCE_INLINE inline\n"
"#endif\n"
"\n"
"#ifdef SLANG_PRELUDE_NAMESPACE\n"
"namespace SLANG_PRELUDE_NAMESPACE {\n"
"#endif\n"
"\n"
"#ifndef SLANG_PRELUDE_PI\n"
"#   define SLANG_PRELUDE_PI           3.14159265358979323846\n"
"#endif\n"
"\n"
"\n"
"union Union32 \n"
"{\n"
"    uint32_t u;\n"
"    int32_t i;\n"
"    float f;\n"
"};\n"
"\n"
"union Union64\n"
"{\n"
"    uint64_t u;\n"
"    int64_t i;\n"
"    double d;\n"
"};\n"
"\n"
"// 32 bit cast conversions\n"
"SLANG_FORCE_INLINE int32_t _bitCastFloatToInt(float f) { Union32 u; u.f = f; return u.i; }\n"
"SLANG_FORCE_INLINE float _bitCastIntToFloat(int32_t i) { Union32 u; u.i = i; return u.f; }\n"
"SLANG_FORCE_INLINE uint32_t _bitCastFloatToUInt(float f) { Union32 u; u.f = f; return u.u; }\n"
"SLANG_FORCE_INLINE float _bitCastUIntToFloat(uint32_t ui) { Union32 u; u.u = ui; return u.f; }\n"
"\n"
"// ----------------------------- F16 -----------------------------------------\n"
"\n"
"\n"
"// This impl is based on FloatToHalf that is in Slang codebase\n"
"SLANG_FORCE_INLINE uint32_t f32tof16(const float value)\n"
"{\n"
"    const uint32_t inBits = _bitCastFloatToUInt(value);\n"
"\n"
"    // bits initially set to just the sign bit\n"
"    uint32_t bits = (inBits >> 16) & 0x8000;\n"
"    // Mantissa can't be used as is, as it holds last bit, for rounding.\n"
"    uint32_t m = (inBits >> 12) & 0x07ff;\n"
"    uint32_t e = (inBits >> 23) & 0xff;\n"
"\n"
"    if (e < 103)\n"
"    {\n"
"        // It's zero\n"
"        return bits;\n"
"    }\n"
"    if (e == 0xff)\n"
"    {\n"
"        // Could be a NAN or INF. Is INF if *input* mantissa is 0.\n"
"        \n"
"        // Remove last bit for rounding to make output mantissa.\n"
"        m >>= 1;\n"
"       \n"
"        // We *assume* float16/float32 signaling bit and remaining bits\n"
"        // semantics are the same. (The signalling bit convention is target specific!).\n"
"        // Non signal bit's usage within mantissa for a NAN are also target specific.\n"
"      \n"
"        // If the m is 0, it could be because the result is INF, but it could also be because all the \n"
"        // bits that made NAN were dropped as we have less mantissa bits in f16. \n"
"           \n"
"        // To fix for this we make non zero if m is 0 and the input mantissa was not.\n"
"        // This will (typically) produce a signalling NAN.\n"
"        m += uint32_t(m == 0 && (inBits & 0x007fffffu));\n"
"       \n"
"        // Combine for output\n"
"        return (bits | 0x7c00u | m);\n"
"    }\n"
"    if (e > 142)\n"
"    {\n"
"        // INF. \n"
"        return bits | 0x7c00u;\n"
"    }\n"
"    if (e < 113)\n"
"    {\n"
"        m |= 0x0800u;\n"
"        bits |= (m >> (114 - e)) + ((m >> (113 - e)) & 1);\n"
"        return bits;\n"
"    }\n"
"    bits |= ((e - 112) << 10) | (m >> 1);\n"
"    bits += m & 1;\n"
"    return bits;\n"
"}\n"
"\n"
"static const float g_f16tof32Magic = _bitCastIntToFloat((127 + (127 - 15)) << 23);\n"
"\n"
"SLANG_FORCE_INLINE float f16tof32(const uint32_t value)\n"
"{\n"
"    const uint32_t sign = (value & 0x8000) << 16;\n"
"    uint32_t exponent = (value & 0x7c00) >> 10;\n"
"    uint32_t mantissa = (value & 0x03ff);\n"
"\n"
"    if (exponent == 0)\n"
"    {\n"
"        // If mantissa is 0 we are done, as output is 0. \n"
"        // If it's not zero we must have a denormal.\n"
"        if (mantissa)\n"
"        {\n"
"            // We have a denormal so use the magic to do exponent adjust\n"
"            return _bitCastIntToFloat(sign | ((value & 0x7fff) << 13)) * g_f16tof32Magic;\n"
"        }\n"
"    }\n"
"    else \n"
"    {\n"
"        // If the exponent is NAN or INF exponent is 0x1f on input. \n"
"        // If that's the case, we just need to set the exponent to 0xff on output\n"
"        // and the mantissa can just stay the same. If its 0 it's INF, else it is NAN and we just copy the bits\n"
"        //\n"
"        // Else we need to correct the exponent in the normalized case.\n"
"        exponent = (exponent == 0x1F) ? 0xff : (exponent + (-15 + 127));\n"
"    }\n"
"    \n"
"    return _bitCastUIntToFloat(sign | (exponent << 23) | (mantissa << 13));\n"
"}\n"
"\n"
"// ----------------------------- F32 -----------------------------------------\n"
"\n"
"// Helpers\n"
"SLANG_FORCE_INLINE float F32_calcSafeRadians(float radians);\n"
"\n"
"#ifdef SLANG_LLVM\n"
"\n"
"SLANG_PRELUDE_EXTERN_C_START\n"
"\n"
"// Unary \n"
"float F32_ceil(float f);\n"
"float F32_floor(float f);\n"
"float F32_round(float f);\n"
"float F32_sin(float f);\n"
"float F32_cos(float f);\n"
"float F32_tan(float f);\n"
"float F32_asin(float f);\n"
"float F32_acos(float f);\n"
"float F32_atan(float f);\n"
"float F32_sinh(float f);\n"
"float F32_cosh(float f);\n"
"float F32_tanh(float f);\n"
"float F32_log2(float f);\n"
"float F32_log(float f);\n"
"float F32_log10(float f);\n"
"float F32_exp2(float f);\n"
"float F32_exp(float f);\n"
"float F32_abs(float f);\n"
"float F32_trunc(float f);\n"
"float F32_sqrt(float f);\n"
"\n"
"bool F32_isnan(float f);\n"
"bool F32_isfinite(float f); \n"
"bool F32_isinf(float f);\n"
"\n"
"// Binary\n"
"SLANG_FORCE_INLINE float F32_min(float a, float b) { return a < b ? a : b; }\n"
"SLANG_FORCE_INLINE float F32_max(float a, float b) { return a > b ? a : b; }\n"
"float F32_pow(float a, float b);\n"
"float F32_fmod(float a, float b);\n"
"float F32_remainder(float a, float b);\n"
"float F32_atan2(float a, float b);\n"
"\n"
"float F32_frexp(float x, int* e);\n"
"\n"
"float F32_modf(float x, float* ip);\n"
"\n"
"// Ternary\n"
"SLANG_FORCE_INLINE float F32_fma(float a, float b, float c) { return a * b + c; }\n"
"\n"
"SLANG_PRELUDE_EXTERN_C_END\n"
"\n"
"#else\n"
"\n"
"// Unary \n"
"SLANG_FORCE_INLINE float F32_ceil(float f) { return ::ceilf(f); }\n"
"SLANG_FORCE_INLINE float F32_floor(float f) { return ::floorf(f); }\n"
"SLANG_FORCE_INLINE float F32_round(float f) { return ::roundf(f); }\n"
"SLANG_FORCE_INLINE float F32_sin(float f) { return ::sinf(f); }\n"
"SLANG_FORCE_INLINE float F32_cos(float f) { return ::cosf(f); }\n"
"SLANG_FORCE_INLINE float F32_tan(float f) { return ::tanf(f); }\n"
"SLANG_FORCE_INLINE float F32_asin(float f) { return ::asinf(f); }\n"
"SLANG_FORCE_INLINE float F32_acos(float f) { return ::acosf(f); }\n"
"SLANG_FORCE_INLINE float F32_atan(float f) { return ::atanf(f); }\n"
"SLANG_FORCE_INLINE float F32_sinh(float f) { return ::sinhf(f); }\n"
"SLANG_FORCE_INLINE float F32_cosh(float f) { return ::coshf(f); }\n"
"SLANG_FORCE_INLINE float F32_tanh(float f) { return ::tanhf(f); }\n"
"SLANG_FORCE_INLINE float F32_log2(float f) { return ::log2f(f); }\n"
"SLANG_FORCE_INLINE float F32_log(float f) { return ::logf(f); }\n"
"SLANG_FORCE_INLINE float F32_log10(float f) { return ::log10f(f); }\n"
"SLANG_FORCE_INLINE float F32_exp2(float f) { return ::exp2f(f); }\n"
"SLANG_FORCE_INLINE float F32_exp(float f) { return ::expf(f); }\n"
"SLANG_FORCE_INLINE float F32_abs(float f) { return ::fabsf(f); }\n"
"SLANG_FORCE_INLINE float F32_trunc(float f) { return ::truncf(f); }\n"
"SLANG_FORCE_INLINE float F32_sqrt(float f) { return ::sqrtf(f); }\n"
"\n"
"SLANG_FORCE_INLINE bool F32_isnan(float f) { return SLANG_PRELUDE_STD isnan(f); }\n"
"SLANG_FORCE_INLINE bool F32_isfinite(float f) { return SLANG_PRELUDE_STD isfinite(f); }\n"
"SLANG_FORCE_INLINE bool F32_isinf(float f) { return SLANG_PRELUDE_STD isinf(f); }\n"
"\n"
"// Binary\n"
"SLANG_FORCE_INLINE float F32_min(float a, float b) { return ::fminf(a, b); }\n"
"SLANG_FORCE_INLINE float F32_max(float a, float b) { return ::fmaxf(a, b); }\n"
"SLANG_FORCE_INLINE float F32_pow(float a, float b) { return ::powf(a, b); }\n"
"SLANG_FORCE_INLINE float F32_fmod(float a, float b) { return ::fmodf(a, b); }\n"
"SLANG_FORCE_INLINE float F32_remainder(float a, float b) { return ::remainderf(a, b); }\n"
"SLANG_FORCE_INLINE float F32_atan2(float a, float b) { return float(::atan2(a, b)); }\n"
"\n"
"SLANG_FORCE_INLINE float F32_frexp(float x, int* e) { return ::frexpf(x, e); }\n"
"\n"
"SLANG_FORCE_INLINE float F32_modf(float x, float* ip)\n"
"{\n"
"    return ::modff(x, ip);\n"
"}\n"
"\n"
"// Ternary\n"
"SLANG_FORCE_INLINE float F32_fma(float a, float b, float c) { return ::fmaf(a, b, c); }\n"
"\n"
"#endif\n"
"\n"
"SLANG_FORCE_INLINE float F32_calcSafeRadians(float radians)\n"
"{\n"
"    // Put 0 to 2pi cycles to cycle around 0 to 1 \n"
"\tfloat a = radians * (1.0f /  float(SLANG_PRELUDE_PI * 2));\n"
"    // Get truncated fraction, as value in  0 - 1 range\n"
"    a = a - F32_floor(a);\n"
"    // Convert back to 0 - 2pi range\n"
"\treturn (a * float(SLANG_PRELUDE_PI * 2));\n"
"}\n"
"\n"
"SLANG_FORCE_INLINE float F32_rsqrt(float f) { return 1.0f / F32_sqrt(f); }\n"
"SLANG_FORCE_INLINE float F32_sign(float f) { return ( f == 0.0f) ? f : (( f < 0.0f) ? -1.0f : 1.0f); } \n"
"SLANG_FORCE_INLINE float F32_frac(float f) { return f - F32_floor(f); }\n"
"\n"
"SLANG_FORCE_INLINE uint32_t F32_asuint(float f) { Union32 u; u.f = f; return u.u; }\n"
"SLANG_FORCE_INLINE int32_t F32_asint(float f) { Union32 u; u.f = f; return u.i; }\n"
"\n"
"// ----------------------------- F64 -----------------------------------------\n"
"\n"
"SLANG_FORCE_INLINE double F64_calcSafeRadians(double radians);\n"
"\n"
"#ifdef SLANG_LLVM\n"
"\n"
"SLANG_PRELUDE_EXTERN_C_START\n"
"\n"
"// Unary \n"
"double F64_ceil(double f);\n"
"double F64_floor(double f);\n"
"double F64_round(double f);\n"
"double F64_sin(double f);\n"
"double F64_cos(double f);\n"
"double F64_tan(double f);\n"
"double F64_asin(double f);\n"
"double F64_acos(double f);\n"
"double F64_atan(double f);\n"
"double F64_sinh(double f);\n"
"double F64_cosh(double f);\n"
"double F64_tanh(double f);\n"
"double F64_log2(double f);\n"
"double F64_log(double f);\n"
"double F64_log10(float f);\n"
"double F64_exp2(double f);\n"
"double F64_exp(double f);\n"
"double F64_abs(double f);\n"
"double F64_trunc(double f);\n"
"double F64_sqrt(double f);\n"
"\n"
"bool F64_isnan(double f);\n"
"bool F64_isfinite(double f);\n"
"bool F64_isinf(double f);\n"
"\n"
"// Binary\n"
"SLANG_FORCE_INLINE double F64_min(double a, double b) { return a < b ? a : b; }\n"
"SLANG_FORCE_INLINE double F64_max(double a, double b) { return a > b ? a : b; }\n"
"double F64_pow(double a, double b);\n"
"double F64_fmod(double a, double b);\n"
"double F64_remainder(double a, double b);\n"
"double F64_atan2(double a, double b);\n"
"\n"
"double F64_frexp(double x, int* e);\n"
"\n"
"double F64_modf(double x, double* ip);\n"
"\n"
"// Ternary\n"
"SLANG_FORCE_INLINE double F64_fma(double a, double b, double c) { return a * b + c; }\n"
"\n"
"SLANG_PRELUDE_EXTERN_C_END\n"
"\n"
"#else // SLANG_LLVM\n"
"\n"
"// Unary \n"
"SLANG_FORCE_INLINE double F64_ceil(double f) { return ::ceil(f); }\n"
"SLANG_FORCE_INLINE double F64_floor(double f) { return ::floor(f); }\n"
"SLANG_FORCE_INLINE double F64_round(double f) { return ::round(f); }\n"
"SLANG_FORCE_INLINE double F64_sin(double f) { return ::sin(f); }\n"
"SLANG_FORCE_INLINE double F64_cos(double f) { return ::cos(f); }\n"
"SLANG_FORCE_INLINE double F64_tan(double f) { return ::tan(f); }\n"
"SLANG_FORCE_INLINE double F64_asin(double f) { return ::asin(f); }\n"
"SLANG_FORCE_INLINE double F64_acos(double f) { return ::acos(f); }\n"
"SLANG_FORCE_INLINE double F64_atan(double f) { return ::atan(f); }\n"
"SLANG_FORCE_INLINE double F64_sinh(double f) { return ::sinh(f); }\n"
"SLANG_FORCE_INLINE double F64_cosh(double f) { return ::cosh(f); }\n"
"SLANG_FORCE_INLINE double F64_tanh(double f) { return ::tanh(f); }\n"
"SLANG_FORCE_INLINE double F64_log2(double f) { return ::log2(f); }\n"
"SLANG_FORCE_INLINE double F64_log(double f) { return ::log(f); }\n"
"SLANG_FORCE_INLINE double F64_log10(float f) { return ::log10(f); }\n"
"SLANG_FORCE_INLINE double F64_exp2(double f) { return ::exp2(f); }\n"
"SLANG_FORCE_INLINE double F64_exp(double f) { return ::exp(f); }\n"
"SLANG_FORCE_INLINE double F64_abs(double f) { return ::fabs(f); }\n"
"SLANG_FORCE_INLINE double F64_trunc(double f) { return ::trunc(f); }\n"
"SLANG_FORCE_INLINE double F64_sqrt(double f) { return ::sqrt(f); }\n"
"\n"
"\n"
"SLANG_FORCE_INLINE bool F64_isnan(double f) { return SLANG_PRELUDE_STD isnan(f); }\n"
"SLANG_FORCE_INLINE bool F64_isfinite(double f) { return SLANG_PRELUDE_STD isfinite(f); }\n"
"SLANG_FORCE_INLINE bool F64_isinf(double f) { return SLANG_PRELUDE_STD isinf(f); }\n"
"\n"
"// Binary\n"
"SLANG_FORCE_INLINE double F64_min(double a, double b) { return ::fmin(a, b); }\n"
"SLANG_FORCE_INLINE double F64_max(double a, double b) { return ::fmax(a, b); }\n"
"SLANG_FORCE_INLINE double F64_pow(double a, double b) { return ::pow(a, b); }\n"
"SLANG_FORCE_INLINE double F64_fmod(double a, double b) { return ::fmod(a, b); }\n"
"SLANG_FORCE_INLINE double F64_remainder(double a, double b) { return ::remainder(a, b); }\n"
"SLANG_FORCE_INLINE double F64_atan2(double a, double b) { return ::atan2(a, b); }\n"
"\n"
"SLANG_FORCE_INLINE double F64_frexp(double x, int* e) { return ::frexp(x, e); }\n"
"\n"
"SLANG_FORCE_INLINE double F64_modf(double x, double* ip)\n"
"{\n"
"    return ::modf(x, ip);\n"
"}\n"
"\n"
"// Ternary\n"
"SLANG_FORCE_INLINE double F64_fma(double a, double b, double c) { return ::fma(a, b, c); }\n"
"\n"
"#endif // SLANG_LLVM\n"
"\n"
"SLANG_FORCE_INLINE double F64_rsqrt(double f) { return 1.0 / F64_sqrt(f); }\n"
"SLANG_FORCE_INLINE double F64_sign(double f) { return (f == 0.0) ? f : ((f < 0.0) ? -1.0 : 1.0); }\n"
"SLANG_FORCE_INLINE double F64_frac(double f) { return f - F64_floor(f); }\n"
"\n"
"SLANG_FORCE_INLINE void F64_asuint(double d, uint32_t* low, uint32_t* hi)\n"
"{\n"
"    Union64 u;\n"
"    u.d = d;\n"
"    *low = uint32_t(u.u);\n"
"    *hi = uint32_t(u.u >> 32);\n"
"}\n"
"\n"
"SLANG_FORCE_INLINE void F64_asint(double d, int32_t* low, int32_t* hi)\n"
"{\n"
"    Union64 u;\n"
"    u.d = d;\n"
"    *low = int32_t(u.u);\n"
"    *hi = int32_t(u.u >> 32);\n"
"}\n"
"\n"
"SLANG_FORCE_INLINE double F64_calcSafeRadians(double radians)\n"
"{\n"
;
sb << 
"    // Put 0 to 2pi cycles to cycle around 0 to 1 \n"
"\tdouble a = radians * (1.0f /  (SLANG_PRELUDE_PI * 2));\n"
"    // Get truncated fraction, as value in  0 - 1 range\n"
"    a = a - F64_floor(a);\n"
"    // Convert back to 0 - 2pi range\n"
"\treturn (a * (SLANG_PRELUDE_PI * 2));\n"
"}\n"
"\n"
"// ----------------------------- I32 -----------------------------------------\n"
"\n"
"SLANG_FORCE_INLINE int32_t I32_abs(int32_t f) { return (f < 0) ? -f : f; }\n"
"\n"
"SLANG_FORCE_INLINE int32_t I32_min(int32_t a, int32_t b) { return a < b ? a : b; }\n"
"SLANG_FORCE_INLINE int32_t I32_max(int32_t a, int32_t b) { return a > b ? a : b; }\n"
"\n"
"SLANG_FORCE_INLINE float I32_asfloat(int32_t x) { Union32 u; u.i = x; return u.f; }\n"
"SLANG_FORCE_INLINE uint32_t I32_asuint(int32_t x) { return uint32_t(x); }\n"
"SLANG_FORCE_INLINE double I32_asdouble(int32_t low, int32_t hi )\n"
"{\n"
"    Union64 u;\n"
"    u.u = (uint64_t(hi) << 32) | uint32_t(low);\n"
"    return u.d;\n"
"}\n"
"\n"
"// ----------------------------- U32 -----------------------------------------\n"
"\n"
"SLANG_FORCE_INLINE uint32_t U32_abs(uint32_t f) { return f; }\n"
"\n"
"SLANG_FORCE_INLINE uint32_t U32_min(uint32_t a, uint32_t b) { return a < b ? a : b; }\n"
"SLANG_FORCE_INLINE uint32_t U32_max(uint32_t a, uint32_t b) { return a > b ? a : b; }\n"
"\n"
"SLANG_FORCE_INLINE float U32_asfloat(uint32_t x) { Union32 u; u.u = x; return u.f; }\n"
"SLANG_FORCE_INLINE uint32_t U32_asint(int32_t x) { return uint32_t(x); } \n"
"\n"
"SLANG_FORCE_INLINE double U32_asdouble(uint32_t low, uint32_t hi)\n"
"{\n"
"    Union64 u;\n"
"    u.u = (uint64_t(hi) << 32) | low;\n"
"    return u.d;\n"
"}\n"
"\n"
"\n"
"SLANG_FORCE_INLINE uint32_t U32_countbits(uint32_t v)\n"
"{\n"
"#if SLANG_GCC_FAMILY && !defined(SLANG_LLVM)\n"
"    return __builtin_popcount(v);\n"
"#elif SLANG_PROCESSOR_X86_64 && SLANG_VC\n"
"    return __popcnt(v);\n"
"#else     \n"
"    uint32_t c = 0;\n"
"    while (v)\n"
"    {\n"
"        c++;\n"
"        v &= v - 1;\n"
"    }\n"
"    return c;\n"
"#endif\n"
"}\n"
"\n"
"// ----------------------------- U64 -----------------------------------------\n"
"\n"
"SLANG_FORCE_INLINE uint64_t U64_abs(uint64_t f) { return f; }\n"
"\n"
"SLANG_FORCE_INLINE uint64_t U64_min(uint64_t a, uint64_t b) { return a < b ? a : b; }\n"
"SLANG_FORCE_INLINE uint64_t U64_max(uint64_t a, uint64_t b) { return a > b ? a : b; }\n"
"\n"
"// TODO(JS): We don't define countbits for 64bit in stdlib currently.\n"
"// It's not clear from documentation if it should return 32 or 64 bits, if it exists. \n"
"// 32 bits can always hold the result, and will be implicitly promoted. \n"
"SLANG_FORCE_INLINE uint32_t U64_countbits(uint64_t v)\n"
"{\n"
"#if SLANG_GCC_FAMILY && !defined(SLANG_LLVM)   \n"
"    return uint32_t(__builtin_popcountl(v));\n"
"#elif SLANG_PROCESSOR_X86_64 && SLANG_VC\n"
"    return uint32_t(__popcnt64(v));\n"
"#else     \n"
"    uint32_t c = 0;\n"
"    while (v)\n"
"    {\n"
"        c++;\n"
"        v &= v - 1;\n"
"    }\n"
"    return c;\n"
"#endif\n"
"}\n"
"\n"
"// ----------------------------- I64 -----------------------------------------\n"
"\n"
"SLANG_FORCE_INLINE int64_t I64_abs(int64_t f) { return (f < 0) ? -f : f; }\n"
"\n"
"SLANG_FORCE_INLINE int64_t I64_min(int64_t a, int64_t b) { return a < b ? a : b; }\n"
"SLANG_FORCE_INLINE int64_t I64_max(int64_t a, int64_t b) { return a > b ? a : b; }\n"
"\n"
"\n"
"// ----------------------------- Interlocked ---------------------------------\n"
"\n"
"#if SLANG_LLVM\n"
"\n"
"#else // SLANG_LLVM\n"
"\n"
"#   ifdef _WIN32\n"
"#       include <intrin.h>\n"
"#   endif\n"
"\n"
"SLANG_FORCE_INLINE void InterlockedAdd(uint32_t* dest, uint32_t value, uint32_t* oldValue)\n"
"{\n"
"#   ifdef _WIN32\n"
"    *oldValue = _InterlockedExchangeAdd((long*)dest, (long)value);\n"
"#   else\n"
"    *oldValue = __sync_fetch_and_add(dest, value);\n"
"#   endif\n"
"}\n"
"\n"
"#endif // SLANG_LLVM\n"
"\n"
"\n"
"// ----------------------- fmod --------------------------\n"
"SLANG_FORCE_INLINE float _slang_fmod(float x, float y)\n"
"{\n"
"    return F32_fmod(x, y);\n"
"}\n"
"SLANG_FORCE_INLINE double _slang_fmod(double x, double y)\n"
"{\n"
"    return F64_fmod(x, y);\n"
"}\n"
"\n"
"#ifdef SLANG_PRELUDE_NAMESPACE\n"
"} \n"
"#endif\n"
"\n"
"#endif\n"
"\n"
"#ifndef SLANG_PRELUDE_CPP_TYPES_H\n"
"#define SLANG_PRELUDE_CPP_TYPES_H\n"
"\n"
"#ifdef SLANG_PRELUDE_NAMESPACE\n"
"namespace SLANG_PRELUDE_NAMESPACE {\n"
"#endif\n"
"\n"
"#ifndef SLANG_FORCE_INLINE\n"
"#    define SLANG_FORCE_INLINE inline\n"
"#endif\n"
"\n"
"#ifndef SLANG_PRELUDE_CPP_TYPES_CORE_H\n"
"#define SLANG_PRELUDE_CPP_TYPES_CORE_H\n"
"\n"
"#ifndef SLANG_PRELUDE_ASSERT\n"
"#   ifdef SLANG_PRELUDE_ENABLE_ASSERT\n"
"#       define SLANG_PRELUDE_ASSERT(VALUE) assert(VALUE)\n"
"#   else\n"
"#       define SLANG_PRELUDE_ASSERT(VALUE) \n"
"#   endif\n"
"#endif\n"
"\n"
"// Since we are using unsigned arithmatic care is need in this comparison.\n"
"// It is *assumed* that sizeInBytes >= elemSize. Which means (sizeInBytes >= elemSize) >= 0\n"
"// Which means only a single test is needed\n"
"\n"
"// Asserts for bounds checking.\n"
"// It is assumed index/count are unsigned types.\n"
"#define SLANG_BOUND_ASSERT(index, count)  SLANG_PRELUDE_ASSERT(index < count); \n"
"#define SLANG_BOUND_ASSERT_BYTE_ADDRESS(index, elemSize, sizeInBytes) SLANG_PRELUDE_ASSERT(index <= (sizeInBytes - elemSize) && (index & 3) == 0);\n"
"\n"
"// Macros to zero index if an access is out of range\n"
"#define SLANG_BOUND_ZERO_INDEX(index, count) index = (index < count) ? index : 0; \n"
"#define SLANG_BOUND_ZERO_INDEX_BYTE_ADDRESS(index, elemSize, sizeInBytes) index = (index <= (sizeInBytes - elemSize)) ? index : 0; \n"
"\n"
"// The 'FIX' macro define how the index is fixed. The default is to do nothing. If SLANG_ENABLE_BOUND_ZERO_INDEX\n"
"// the fix macro will zero the index, if out of range\n"
"#ifdef  SLANG_ENABLE_BOUND_ZERO_INDEX\n"
"#   define SLANG_BOUND_FIX(index, count) SLANG_BOUND_ZERO_INDEX(index, count)\n"
"#   define SLANG_BOUND_FIX_BYTE_ADDRESS(index, elemSize, sizeInBytes) SLANG_BOUND_ZERO_INDEX_BYTE_ADDRESS(index, elemSize, sizeInBytes)\n"
"#   define SLANG_BOUND_FIX_FIXED_ARRAY(index, count) SLANG_BOUND_ZERO_INDEX(index, count)\n"
"#else\n"
"#   define SLANG_BOUND_FIX(index, count) \n"
"#   define SLANG_BOUND_FIX_BYTE_ADDRESS(index, elemSize, sizeInBytes) \n"
"#   define SLANG_BOUND_FIX_FIXED_ARRAY(index, count) \n"
"#endif\n"
"\n"
"#ifndef SLANG_BOUND_CHECK\n"
"#   define SLANG_BOUND_CHECK(index, count) SLANG_BOUND_ASSERT(index, count) SLANG_BOUND_FIX(index, count)\n"
"#endif\n"
"\n"
"#ifndef SLANG_BOUND_CHECK_BYTE_ADDRESS\n"
"#   define SLANG_BOUND_CHECK_BYTE_ADDRESS(index, elemSize, sizeInBytes) SLANG_BOUND_ASSERT_BYTE_ADDRESS(index, elemSize, sizeInBytes) SLANG_BOUND_FIX_BYTE_ADDRESS(index, elemSize, sizeInBytes)\n"
"#endif\n"
"\n"
"#ifndef SLANG_BOUND_CHECK_FIXED_ARRAY\n"
"#   define SLANG_BOUND_CHECK_FIXED_ARRAY(index, count) SLANG_BOUND_ASSERT(index, count) SLANG_BOUND_FIX_FIXED_ARRAY(index, count)\n"
"#endif\n"
"\n"
"struct TypeInfo\n"
"{\n"
"    size_t typeSize;\n"
"};\n"
"\n"
"template <typename T, size_t SIZE>\n"
"struct FixedArray\n"
"{\n"
"    const T& operator[](size_t index) const { SLANG_BOUND_CHECK_FIXED_ARRAY(index, SIZE); return m_data[index]; }\n"
"    T& operator[](size_t index) { SLANG_BOUND_CHECK_FIXED_ARRAY(index, SIZE); return m_data[index]; }\n"
"\n"
"    T m_data[SIZE];\n"
"};\n"
"\n"
"// An array that has no specified size, becomes a 'Array'. This stores the size so it can potentially \n"
"// do bounds checking.  \n"
"template <typename T>\n"
"struct Array\n"
"{\n"
"    const T& operator[](size_t index) const { SLANG_BOUND_CHECK(index, count); return data[index]; }\n"
"    T& operator[](size_t index) { SLANG_BOUND_CHECK(index, count); return data[index]; }\n"
"\n"
"    T* data;\n"
"    size_t count;\n"
"};\n"
"\n"
"/* Constant buffers become a pointer to the contained type, so ConstantBuffer<T> becomes T* in C++ code.\n"
"*/\n"
"\n"
"template <typename T, int COUNT>\n"
"struct Vector;\n"
"\n"
"template <typename T>\n"
"struct Vector<T, 1>\n"
"{\n"
"    T x;\n"
"    const T& operator[](size_t /*index*/) const { return x; }\n"
"    T& operator[](size_t /*index*/) { return x; }\n"
"    operator T() const { return x; }\n"
"    Vector() = default;\n"
"    Vector(T scalar)\n"
"    {\n"
"        x = scalar;\n"
"    }\n"
"    template <typename U>\n"
"    Vector(Vector<U, 1> other)\n"
"    {\n"
"        x = (T)other.x;\n"
"    }\n"
"    template <typename U, int otherSize>\n"
"    Vector(Vector<U, otherSize> other)\n"
"    {\n"
"        int minSize = 1;\n"
"        if (otherSize < minSize) minSize = otherSize;\n"
"        for (int i = 0; i < minSize; i++)\n"
"            (*this)[i] = (T)other[i];\n"
"    }\n"
"};\n"
"\n"
"template <typename T>\n"
"struct Vector<T, 2>\n"
"{\n"
"    T x, y;\n"
"    const T& operator[](size_t index) const { return index == 0 ? x : y; }\n"
"    T& operator[](size_t index) { return index == 0 ? x : y; }\n"
"    Vector() = default;\n"
"    Vector(T scalar)\n"
"    {\n"
"        x = y = scalar;\n"
"    }\n"
"    Vector(T _x, T _y)\n"
"    {\n"
"        x = _x;\n"
"        y = _y;\n"
"    }\n"
"    template <typename U>\n"
"    Vector(Vector<U, 2> other)\n"
"    {\n"
"        x = (T)other.x;\n"
"        y = (T)other.y;\n"
"    }\n"
"    template <typename U, int otherSize>\n"
"    Vector(Vector<U, otherSize> other)\n"
"    {\n"
"        int minSize = 2;\n"
"        if (otherSize < minSize) minSize = otherSize;\n"
"        for (int i = 0; i < minSize; i++)\n"
"            (*this)[i] = (T)other[i];\n"
"    }\n"
"};\n"
"\n"
"template <typename T>\n"
"struct Vector<T, 3>\n"
"{\n"
"    T x, y, z;\n"
"    const T& operator[](size_t index) const { return *((T*)(this) + index); }\n"
"    T& operator[](size_t index) { return *((T*)(this) + index); }\n"
"\n"
"    Vector() = default;\n"
"    Vector(T scalar)\n"
"    {\n"
"        x = y = z = scalar;\n"
"    }\n"
"    Vector(T _x, T _y, T _z)\n"
"    {\n"
"        x = _x;\n"
"        y = _y;\n"
"        z = _z;\n"
"    }\n"
"    template <typename U>\n"
"    Vector(Vector<U, 3> other)\n"
"    {\n"
"        x = (T)other.x;\n"
"        y = (T)other.y;\n"
"        z = (T)other.z;\n"
"    }\n"
"    template <typename U, int otherSize>\n"
"    Vector(Vector<U, otherSize> other)\n"
"    {\n"
"        int minSize = 3;\n"
"        if (otherSize < minSize) minSize = otherSize;\n"
"        for (int i = 0; i < minSize; i++)\n"
"            (*this)[i] = (T)other[i];\n"
"    }\n"
"};\n"
"\n"
"template <typename T>\n"
"struct Vector<T, 4>\n"
"{\n"
"    T x, y, z, w;\n"
"\n"
"    const T& operator[](size_t index) const { return *((T*)(this) + index); }\n"
"    T& operator[](size_t index) { return *((T*)(this) + index); }\n"
"    Vector() = default;\n"
"    Vector(T scalar)\n"
"    {\n"
"        x = y = z = w = scalar;\n"
"    }\n"
"    Vector(T _x, T _y, T _z, T _w)\n"
"    {\n"
"        x = _x;\n"
"        y = _y;\n"
"        z = _z;\n"
"        w = _w;\n"
"    }\n"
"    template <typename U, int otherSize>\n"
"    Vector(Vector<U, otherSize> other)\n"
"    {\n"
"        int minSize = 4;\n"
"        if (otherSize < minSize) minSize = otherSize;\n"
"        for (int i = 0; i < minSize; i++)\n"
"            (*this)[i] = (T)other[i];\n"
"    }\n"
" \n"
"};\n"
"\n"
"template<typename T, int N>\n"
"SLANG_FORCE_INLINE Vector<T, N> _slang_select(Vector<bool, N> condition, Vector<T, N> v0, Vector<T, N> v1)\n"
"{\n"
"    Vector<T, N> result;\n"
"    for (int i = 0; i < N; i++)\n"
"    {\n"
"        result[i] = condition[i] ? v0[i] : v1[i];\n"
"    }\n"
"    return result;\n"
"}\n"
"\n"
"template<typename T>\n"
"SLANG_FORCE_INLINE T _slang_select(bool condition, T v0, T v1)\n"
"{\n"
"    return condition ? v0 : v1;\n"
"}\n"
"\n"
"template<typename T, int N>\n"
"SLANG_FORCE_INLINE T _slang_vector_get_element(Vector<T, N> x, int index)\n"
"{\n"
"    return x[index];\n"
"}\n"
"\n"
"template<typename T, int N>\n"
"SLANG_FORCE_INLINE const T* _slang_vector_get_element_ptr(const Vector<T, N>* x, int index)\n"
"{\n"
"    return &((*const_cast<Vector<T,N>*>(x))[index]);\n"
"}\n"
"\n"
"template<typename T, int N>\n"
"SLANG_FORCE_INLINE T* _slang_vector_get_element_ptr(Vector<T, N>* x, int index)\n"
"{\n"
"    return &((*x)[index]);\n"
"}\n"
"\n"
"template<typename T, int n, typename OtherT, int m>\n"
"SLANG_FORCE_INLINE Vector<T, n> _slang_vector_reshape(const Vector<OtherT, m> other)\n"
"{\n"
"    Vector<T, n> result;\n"
"    for (int i = 0; i < n; i++)\n"
"    {\n"
"        OtherT otherElement = T(0);\n"
"        if (i < m)\n"
"            otherElement = _slang_vector_get_element(other, i);\n"
"        *_slang_vector_get_element_ptr(&result, i) = (T)otherElement;\n"
"    }\n"
"    return result;\n"
"}\n"
"\n"
"typedef uint32_t uint;\n"
"\n"
"#define SLANG_VECTOR_BINARY_OP(T, op) \\\n"
"    template<int n> \\\n"
"    SLANG_FORCE_INLINE Vector<T, n> operator op(const Vector<T, n>& thisVal, const Vector<T, n>& other) \\\n"
"    { \\\n"
"        Vector<T, n> result;\\\n"
"        for (int i = 0; i < n; i++) \\\n"
"            result[i] = thisVal[i] op other[i]; \\\n"
"        return result;\\\n"
"    }\n"
"#define SLANG_VECTOR_BINARY_COMPARE_OP(T, op) \\\n"
"    template<int n> \\\n"
"    SLANG_FORCE_INLINE Vector<bool, n> operator op(const Vector<T, n>& thisVal, const Vector<T, n>& other) \\\n"
"    { \\\n"
"        Vector<bool, n> result;\\\n"
"        for (int i = 0; i < n; i++) \\\n"
"            result[i] = thisVal[i] op other[i]; \\\n"
"        return result;\\\n"
"    }\n"
"\n"
"#define SLANG_VECTOR_UNARY_OP(T, op) \\\n"
"    template<int n> \\\n"
"    SLANG_FORCE_INLINE Vector<T, n> operator op(const Vector<T, n>& thisVal) \\\n"
"    { \\\n"
"        Vector<T, n> result;\\\n"
"        for (int i = 0; i < n; i++) \\\n"
"            result[i] = op thisVal[i]; \\\n"
"        return result;\\\n"
"    }\n"
"#define SLANG_INT_VECTOR_OPS(T) \\\n"
"    SLANG_VECTOR_BINARY_OP(T, +)\\\n"
"    SLANG_VECTOR_BINARY_OP(T, -)\\\n"
"    SLANG_VECTOR_BINARY_OP(T, *)\\\n"
"    SLANG_VECTOR_BINARY_OP(T, / )\\\n"
"    SLANG_VECTOR_BINARY_OP(T, &)\\\n"
"    SLANG_VECTOR_BINARY_OP(T, |)\\\n"
"    SLANG_VECTOR_BINARY_OP(T, &&)\\\n"
"    SLANG_VECTOR_BINARY_OP(T, ||)\\\n"
"    SLANG_VECTOR_BINARY_OP(T, ^)\\\n"
"    SLANG_VECTOR_BINARY_OP(T, %)\\\n"
"    SLANG_VECTOR_BINARY_OP(T, >>)\\\n"
"    SLANG_VECTOR_BINARY_OP(T, <<)\\\n"
"    SLANG_VECTOR_BINARY_COMPARE_OP(T, >)\\\n"
"    SLANG_VECTOR_BINARY_COMPARE_OP(T, <)\\\n"
"    SLANG_VECTOR_BINARY_COMPARE_OP(T, >=)\\\n"
"    SLANG_VECTOR_BINARY_COMPARE_OP(T, <=)\\\n"
"    SLANG_VECTOR_BINARY_COMPARE_OP(T, ==)\\\n"
"    SLANG_VECTOR_BINARY_COMPARE_OP(T, !=)\\\n"
"    SLANG_VECTOR_UNARY_OP(T, !)\\\n"
"    SLANG_VECTOR_UNARY_OP(T, ~)\n"
"#define SLANG_FLOAT_VECTOR_OPS(T) \\\n"
"    SLANG_VECTOR_BINARY_OP(T, +)\\\n"
"    SLANG_VECTOR_BINARY_OP(T, -)\\\n"
"    SLANG_VECTOR_BINARY_OP(T, *)\\\n"
"    SLANG_VECTOR_BINARY_OP(T, /)\\\n"
"    SLANG_VECTOR_UNARY_OP(T, -)\\\n"
"    SLANG_VECTOR_BINARY_COMPARE_OP(T, >)\\\n"
"    SLANG_VECTOR_BINARY_COMPARE_OP(T, <)\\\n"
"    SLANG_VECTOR_BINARY_COMPARE_OP(T, >=)\\\n"
"    SLANG_VECTOR_BINARY_COMPARE_OP(T, <=)\\\n"
"    SLANG_VECTOR_BINARY_COMPARE_OP(T, ==)\\\n"
"    SLANG_VECTOR_BINARY_COMPARE_OP(T, !=)\n"
"\n"
"SLANG_INT_VECTOR_OPS(bool)\n"
"SLANG_INT_VECTOR_OPS(int)\n"
"SLANG_INT_VECTOR_OPS(int8_t)\n"
"SLANG_INT_VECTOR_OPS(int16_t)\n"
"SLANG_INT_VECTOR_OPS(int64_t)\n"
"SLANG_INT_VECTOR_OPS(uint)\n"
"SLANG_INT_VECTOR_OPS(uint8_t)\n"
"SLANG_INT_VECTOR_OPS(uint16_t)\n"
"SLANG_INT_VECTOR_OPS(uint64_t)\n"
"\n"
"SLANG_FLOAT_VECTOR_OPS(float)\n"
"SLANG_FLOAT_VECTOR_OPS(double)\n"
"\n"
"#define SLANG_VECTOR_INT_NEG_OP(T) \\\n"
"    template<int N>\\\n"
"    Vector<T, N> operator-(const Vector<T, N>& thisVal) \\\n"
"    { \\\n"
"        Vector<T, N> result;\\\n"
"        for (int i = 0; i < N; i++) \\\n"
"            result[i] = 0 - thisVal[i]; \\\n"
"        return result;\\\n"
"    }\n"
"SLANG_VECTOR_INT_NEG_OP(int)\n"
"SLANG_VECTOR_INT_NEG_OP(int8_t)\n"
"SLANG_VECTOR_INT_NEG_OP(int16_t)\n"
"SLANG_VECTOR_INT_NEG_OP(int64_t)\n"
"SLANG_VECTOR_INT_NEG_OP(uint)\n"
"SLANG_VECTOR_INT_NEG_OP(uint8_t)\n"
"SLANG_VECTOR_INT_NEG_OP(uint16_t)\n"
"SLANG_VECTOR_INT_NEG_OP(uint64_t)\n"
"\n"
"#define SLANG_FLOAT_VECTOR_MOD(T)\\\n"
"    template<int N> \\\n"
"    Vector<T, N> operator%(const Vector<T, N>& left, const Vector<T, N>& right) \\\n"
"    {\\\n"
"        Vector<T, N> result;\\\n"
"        for (int i = 0; i < N; i++) \\\n"
"            result[i] = _slang_fmod(left[i], right[i]); \\\n"
"        return result;\\\n"
"    }\n"
"\n"
"SLANG_FLOAT_VECTOR_MOD(float)\n"
"SLANG_FLOAT_VECTOR_MOD(double)\n"
"#undef SLANG_FLOAT_VECTOR_MOD\n"
"#undef SLANG_VECTOR_BINARY_OP\n"
"#undef SLANG_VECTOR_UNARY_OP\n"
"#undef SLANG_INT_VECTOR_OPS\n"
"#undef SLANG_FLOAT_VECTOR_OPS\n"
"#undef SLANG_VECTOR_INT_NEG_OP\n"
"#undef SLANG_FLOAT_VECTOR_MOD\n"
"\n"
"template <typename T, int ROWS, int COLS>\n"
"struct Matrix\n"
"{\n"
"    Vector<T, COLS> rows[ROWS];\n"
"    Vector<T, COLS>& operator[](size_t index) { return rows[index]; }\n"
"    Matrix() = default;\n"
"    Matrix(T scalar)\n"
"    {\n"
"        for (int i = 0; i < ROWS; i++)\n"
"            rows[i] = Vector<T, COLS>(scalar);\n"
"    }\n"
"    Matrix(const Vector<T, COLS>& row0)\n"
"    {\n"
"        rows[0] = row0;\n"
"    }\n"
"    Matrix(const Vector<T, COLS>& row0, const Vector<T, COLS>& row1)\n"
"    {\n"
"        rows[0] = row0;\n"
"        rows[1] = row1;\n"
"    }\n"
"    Matrix(const Vector<T, COLS>& row0, const Vector<T, COLS>& row1, const Vector<T, COLS>& row2)\n"
"    {\n"
"        rows[0] = row0;\n"
"        rows[1] = row1;\n"
"        rows[2] = row2;\n"
"    }\n"
"    Matrix(const Vector<T, COLS>& row0, const Vector<T, COLS>& row1, const Vector<T, COLS>& row2, const Vector<T, COLS>& row3)\n"
"    {\n"
"        rows[0] = row0;\n"
"        rows[1] = row1;\n"
"        rows[2] = row2;\n"
"        rows[3] = row3;\n"
"    }\n"
"    template<typename U, int otherRow, int otherCol>\n"
"    Matrix(const Matrix<U, otherRow, otherCol>& other)\n"
"    {\n"
"        int minRow = ROWS;\n"
"        int minCol = COLS;\n"
"        if (minRow > otherRow) minRow = otherRow;\n"
"        if (minCol > otherCol) minCol = otherCol;\n"
"        for (int i = 0; i < minRow; i++)\n"
"            for (int j = 0; j < minCol; j++)\n"
"                rows[i][j] = (T)other.rows[i][j];\n"
"    }\n"
"    Matrix(T v0, T v1, T v2, T v3)\n"
"    {\n"
"        rows[0][0] = v0;  rows[0][1] = v1;\n"
"        rows[1][0] = v2;  rows[1][1] = v3;\n"
"    }\n"
"    Matrix(T v0, T v1, T v2, T v3, T v4, T v5)\n"
"    {\n"
"        if (COLS == 3)\n"
"        {\n"
"            rows[0][0] = v0;  rows[0][1] = v1; rows[0][2] = v2;\n"
"            rows[1][0] = v3;  rows[1][1] = v4; rows[1][2] = v5;\n"
"        }\n"
"        else\n"
"        {\n"
"            rows[0][0] = v0;  rows[0][1] = v1;\n"
"            rows[1][0] = v2;  rows[1][1] = v3;\n"
"            rows[2][0] = v4;  rows[2][1] = v5;\n"
"        }\n"
"    }\n"
"    Matrix(T v0, T v1, T v2, T v3, T v4, T v5, T v6, T v7)\n"
"    {\n"
"        if (COLS == 4)\n"
"        {\n"
"            rows[0][0] = v0;  rows[0][1] = v1; rows[0][2] = v2; rows[0][3] = v3;\n"
;
sb << 
"            rows[1][0] = v4;  rows[1][1] = v5; rows[1][2] = v6; rows[1][3] = v7;\n"
"        }\n"
"        else\n"
"        {\n"
"            rows[0][0] = v0;  rows[0][1] = v1;\n"
"            rows[1][0] = v2;  rows[1][1] = v3;\n"
"            rows[2][0] = v4;  rows[2][1] = v5;\n"
"            rows[3][0] = v6;  rows[3][1] = v7;\n"
"        }\n"
"    }\n"
"    Matrix(T v0, T v1, T v2, T v3, T v4, T v5, T v6, T v7, T v8)\n"
"    {\n"
"        rows[0][0] = v0;  rows[0][1] = v1;  rows[0][2] = v2;\n"
"        rows[1][0] = v3;  rows[1][1] = v4;  rows[1][2] = v5;\n"
"        rows[2][0] = v6;  rows[2][1] = v7;  rows[2][2] = v8;\n"
"    }\n"
"    Matrix(T v0, T v1, T v2, T v3, T v4, T v5, T v6, T v7, T v8, T v9, T v10, T v11)\n"
"    {\n"
"        if (COLS == 4)\n"
"        {\n"
"            rows[0][0] = v0;  rows[0][1] = v1;  rows[0][2] = v2;  rows[0][3] = v3;\n"
"            rows[1][0] = v4;  rows[1][1] = v5;  rows[1][2] = v6;  rows[1][3] = v7;\n"
"            rows[2][0] = v8;  rows[2][1] = v9;  rows[2][2] = v10; rows[2][3] = v11;\n"
"        }\n"
"        else\n"
"        {\n"
"            rows[0][0] = v0;  rows[0][1] = v1;  rows[0][2] = v2;\n"
"            rows[1][0] = v3;  rows[1][1] = v4;  rows[1][2] = v5;\n"
"            rows[2][0] = v6;  rows[2][1] = v7;  rows[2][2] = v8;\n"
"            rows[3][0] = v9;  rows[3][1] = v10; rows[3][2] = v11;\n"
"        }\n"
"    }\n"
"    Matrix(T v0, T v1, T v2, T v3, T v4, T v5, T v6, T v7, T v8, T v9, T v10, T v11, T v12, T v13, T v14, T v15)\n"
"    {\n"
"        rows[0][0] = v0;  rows[0][1] = v1;  rows[0][2] = v2;  rows[0][3] = v3;\n"
"        rows[1][0] = v4;  rows[1][1] = v5;  rows[1][2] = v6;  rows[1][3] = v7;\n"
"        rows[2][0] = v8;  rows[2][1] = v9;  rows[2][2] = v10; rows[2][3] = v11;\n"
"        rows[3][0] = v12; rows[3][1] = v13; rows[3][2] = v14; rows[3][3] = v15;\n"
"    }\n"
"};\n"
"\n"
"#define SLANG_MATRIX_BINARY_OP(T, op) \\\n"
"    template<int R, int C> \\\n"
"    Matrix<T, R, C> operator op(const Matrix<T, R, C>& thisVal, const Matrix<T, R, C>& other) \\\n"
"    { \\\n"
"        Matrix<T, R, C> result;\\\n"
"        for (int i = 0; i < R; i++) \\\n"
"            for (int j = 0; j < C; j++) \\\n"
"                result.rows[i][j] = thisVal.rows[i][j] op other.rows[i][j]; \\\n"
"        return result;\\\n"
"    }\n"
"\n"
"#define SLANG_MATRIX_UNARY_OP(T, op) \\\n"
"    template<int R, int C> \\\n"
"    Matrix<T, R, C> operator op(const Matrix<T, R, C>& thisVal) \\\n"
"    { \\\n"
"        Matrix<T, R, C> result;\\\n"
"        for (int i = 0; i < R; i++) \\\n"
"            for (int j = 0; j < C; j++) \\\n"
"                result[i].rows[i][j] = op thisVal.rows[i][j]; \\\n"
"        return result;\\\n"
"    }\n"
"#define SLANG_INT_MATRIX_OPS(T) \\\n"
"    SLANG_MATRIX_BINARY_OP(T, +)\\\n"
"    SLANG_MATRIX_BINARY_OP(T, -)\\\n"
"    SLANG_MATRIX_BINARY_OP(T, *)\\\n"
"    SLANG_MATRIX_BINARY_OP(T, / )\\\n"
"    SLANG_MATRIX_BINARY_OP(T, &)\\\n"
"    SLANG_MATRIX_BINARY_OP(T, |)\\\n"
"    SLANG_MATRIX_BINARY_OP(T, &&)\\\n"
"    SLANG_MATRIX_BINARY_OP(T, ||)\\\n"
"    SLANG_MATRIX_BINARY_OP(T, ^)\\\n"
"    SLANG_MATRIX_BINARY_OP(T, %)\\\n"
"    SLANG_MATRIX_UNARY_OP(T, !)\\\n"
"    SLANG_MATRIX_UNARY_OP(T, ~)\n"
"#define SLANG_FLOAT_MATRIX_OPS(T) \\\n"
"    SLANG_MATRIX_BINARY_OP(T, +)\\\n"
"    SLANG_MATRIX_BINARY_OP(T, -)\\\n"
"    SLANG_MATRIX_BINARY_OP(T, *)\\\n"
"    SLANG_MATRIX_BINARY_OP(T, /)\\\n"
"    SLANG_MATRIX_UNARY_OP(T, -)\n"
"SLANG_INT_MATRIX_OPS(int)\n"
"SLANG_INT_MATRIX_OPS(int8_t)\n"
"SLANG_INT_MATRIX_OPS(int16_t)\n"
"SLANG_INT_MATRIX_OPS(int64_t)\n"
"SLANG_INT_MATRIX_OPS(uint)\n"
"SLANG_INT_MATRIX_OPS(uint8_t)\n"
"SLANG_INT_MATRIX_OPS(uint16_t)\n"
"SLANG_INT_MATRIX_OPS(uint64_t)\n"
"\n"
"SLANG_FLOAT_MATRIX_OPS(float)\n"
"SLANG_FLOAT_MATRIX_OPS(double)\n"
"\n"
"#define SLANG_MATRIX_INT_NEG_OP(T) \\\n"
"    template<int R, int C>\\\n"
"    SLANG_FORCE_INLINE Matrix<T, R, C> operator-(Matrix<T, R, C> thisVal) \\\n"
"    { \\\n"
"        Matrix<T, R, C> result;\\\n"
"        for (int i = 0; i < R; i++) \\\n"
"            for (int j = 0; j < C; j++) \\\n"
"            result.rows[i][j] = 0 - thisVal.rows[i][j]; \\\n"
"        return result;\\\n"
"    }\n"
"    SLANG_MATRIX_INT_NEG_OP(int)\n"
"    SLANG_MATRIX_INT_NEG_OP(int8_t)\n"
"    SLANG_MATRIX_INT_NEG_OP(int16_t)\n"
"    SLANG_MATRIX_INT_NEG_OP(int64_t)\n"
"    SLANG_MATRIX_INT_NEG_OP(uint)\n"
"    SLANG_MATRIX_INT_NEG_OP(uint8_t)\n"
"    SLANG_MATRIX_INT_NEG_OP(uint16_t)\n"
"    SLANG_MATRIX_INT_NEG_OP(uint64_t)\n"
"\n"
"#define SLANG_FLOAT_MATRIX_MOD(T)\\\n"
"    template<int R, int C> \\\n"
"    SLANG_FORCE_INLINE Matrix<T, R, C> operator%(Matrix<T, R, C> left, Matrix<T, R, C> right) \\\n"
"    {\\\n"
"        Matrix<T, R, C> result;\\\n"
"        for (int i = 0; i < R; i++) \\\n"
"            for (int j = 0; j < C; j++) \\\n"
"                result.rows[i][j] = _slang_fmod(left.rows[i][j], right.rows[i][j]); \\\n"
"        return result;\\\n"
"    }\n"
"\n"
"    SLANG_FLOAT_MATRIX_MOD(float)\n"
"    SLANG_FLOAT_MATRIX_MOD(double)\n"
"#undef SLANG_FLOAT_MATRIX_MOD\n"
"#undef SLANG_MATRIX_BINARY_OP\n"
"#undef SLANG_MATRIX_UNARY_OP\n"
"#undef SLANG_INT_MATRIX_OPS\n"
"#undef SLANG_FLOAT_MATRIX_OPS\n"
"#undef SLANG_MATRIX_INT_NEG_OP\n"
"#undef SLANG_FLOAT_MATRIX_MOD\n"
"\n"
"template<typename TResult, typename TInput>\n"
"TResult slang_bit_cast(TInput val)\n"
"{\n"
"    return *(TResult*)(&val);\n"
"}\n"
"\n"
"#endif\n"
"\n"
"\n"
"\n"
"\n"
"typedef Vector<float, 2> float2;\n"
"typedef Vector<float, 3> float3;\n"
"typedef Vector<float, 4> float4;\n"
"\n"
"typedef Vector<int32_t, 2> int2;\n"
"typedef Vector<int32_t, 3> int3;\n"
"typedef Vector<int32_t, 4> int4;\n"
"\n"
"typedef Vector<uint32_t, 2> uint2;\n"
"typedef Vector<uint32_t, 3> uint3;\n"
"typedef Vector<uint32_t, 4> uint4;\n"
"\n"
"// We can just map `NonUniformResourceIndex` type directly to the index type on CPU, as CPU does not require\n"
"// any special handling around such accesses.\n"
"typedef size_t NonUniformResourceIndex;\n"
"\n"
"// ----------------------------- ResourceType -----------------------------------------\n"
"\n"
"// https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/sm5-object-structuredbuffer-getdimensions\n"
"// Missing  Load(_In_  int  Location, _Out_ uint Status);\n"
"\n"
"template <typename T>\n"
"struct RWStructuredBuffer\n"
"{\n"
"    SLANG_FORCE_INLINE T& operator[](size_t index) const { SLANG_BOUND_CHECK(index, count); return data[index]; }\n"
"    const T& Load(size_t index) const { SLANG_BOUND_CHECK(index, count); return data[index]; }  \n"
"    void GetDimensions(uint32_t* outNumStructs, uint32_t* outStride) { *outNumStructs = uint32_t(count); *outStride = uint32_t(sizeof(T)); }\n"
"  \n"
"    T* data;\n"
"    size_t count;\n"
"};\n"
"\n"
"template <typename T>\n"
"struct StructuredBuffer\n"
"{\n"
"    SLANG_FORCE_INLINE const T& operator[](size_t index) const { SLANG_BOUND_CHECK(index, count); return data[index]; }\n"
"    const T& Load(size_t index) const { SLANG_BOUND_CHECK(index, count); return data[index]; }\n"
"    void GetDimensions(uint32_t* outNumStructs, uint32_t* outStride) { *outNumStructs = uint32_t(count); *outStride = uint32_t(sizeof(T)); }\n"
"    \n"
"    T* data;\n"
"    size_t count;\n"
"};\n"
"\n"
"\n"
"template <typename T>\n"
"struct RWBuffer\n"
"{\n"
"    SLANG_FORCE_INLINE T& operator[](size_t index) const { SLANG_BOUND_CHECK(index, count); return data[index]; }\n"
"    const T& Load(size_t index) const { SLANG_BOUND_CHECK(index, count); return data[index]; }\n"
"    void GetDimensions(uint32_t* outCount) { *outCount = uint32_t(count); }\n"
"    \n"
"    T* data;\n"
"    size_t count;\n"
"};\n"
"\n"
"template <typename T>\n"
"struct Buffer\n"
"{\n"
"    SLANG_FORCE_INLINE const T& operator[](size_t index) const { SLANG_BOUND_CHECK(index, count); return data[index]; }\n"
"    const T& Load(size_t index) const { SLANG_BOUND_CHECK(index, count); return data[index]; }\n"
"    void GetDimensions(uint32_t* outCount) { *outCount = uint32_t(count); }\n"
"    \n"
"    T* data;\n"
"    size_t count;\n"
"};\n"
"\n"
"// Missing  Load(_In_  int  Location, _Out_ uint Status);\n"
"struct ByteAddressBuffer\n"
"{\n"
"    void GetDimensions(uint32_t* outDim) const { *outDim = uint32_t(sizeInBytes); }\n"
"    uint32_t Load(size_t index) const \n"
"    { \n"
"        SLANG_BOUND_CHECK_BYTE_ADDRESS(index, 4, sizeInBytes);\n"
"        return data[index >> 2]; \n"
"    }\n"
"    uint2 Load2(size_t index) const \n"
"    { \n"
"        SLANG_BOUND_CHECK_BYTE_ADDRESS(index, 8, sizeInBytes);\n"
"        const size_t dataIdx = index >> 2; \n"
"        return uint2{data[dataIdx], data[dataIdx + 1]}; \n"
"    }\n"
"    uint3 Load3(size_t index) const \n"
"    { \n"
"        SLANG_BOUND_CHECK_BYTE_ADDRESS(index, 12, sizeInBytes);\n"
"        const size_t dataIdx = index >> 2; \n"
"        return uint3{data[dataIdx], data[dataIdx + 1], data[dataIdx + 2]}; \n"
"    }\n"
"    uint4 Load4(size_t index) const \n"
"    { \n"
"        SLANG_BOUND_CHECK_BYTE_ADDRESS(index, 16, sizeInBytes);\n"
"        const size_t dataIdx = index >> 2; \n"
"        return uint4{data[dataIdx], data[dataIdx + 1], data[dataIdx + 2], data[dataIdx + 3]}; \n"
"    }\n"
"    template<typename T>\n"
"    T Load(size_t index) const\n"
"    {\n"
"        SLANG_BOUND_CHECK_BYTE_ADDRESS(index, sizeof(T), sizeInBytes);\n"
"        return *(const T*)(((const char*)data) + index);\n"
"    }\n"
"    \n"
"    const uint32_t* data;\n"
"    size_t sizeInBytes;  //< Must be multiple of 4\n"
"};\n"
"\n"
"// https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/sm5-object-rwbyteaddressbuffer\n"
"// Missing support for Atomic operations \n"
"// Missing support for Load with status\n"
"struct RWByteAddressBuffer\n"
"{\n"
"    void GetDimensions(uint32_t* outDim) const { *outDim = uint32_t(sizeInBytes); }\n"
"    \n"
"    uint32_t Load(size_t index) const \n"
"    { \n"
"        SLANG_BOUND_CHECK_BYTE_ADDRESS(index, 4, sizeInBytes);\n"
"        return data[index >> 2]; \n"
"    }\n"
"    uint2 Load2(size_t index) const \n"
"    { \n"
"        SLANG_BOUND_CHECK_BYTE_ADDRESS(index, 8, sizeInBytes);\n"
"        const size_t dataIdx = index >> 2; \n"
"        return uint2{data[dataIdx], data[dataIdx + 1]}; \n"
"    }\n"
"    uint3 Load3(size_t index) const \n"
"    { \n"
"        SLANG_BOUND_CHECK_BYTE_ADDRESS(index, 12, sizeInBytes);\n"
"        const size_t dataIdx = index >> 2; \n"
"        return uint3{data[dataIdx], data[dataIdx + 1], data[dataIdx + 2]}; \n"
"    }\n"
"    uint4 Load4(size_t index) const \n"
"    { \n"
"        SLANG_BOUND_CHECK_BYTE_ADDRESS(index, 16, sizeInBytes);\n"
"        const size_t dataIdx = index >> 2; \n"
"        return uint4{data[dataIdx], data[dataIdx + 1], data[dataIdx + 2], data[dataIdx + 3]}; \n"
"    }\n"
"    template<typename T>\n"
"    T Load(size_t index) const\n"
"    {\n"
"        SLANG_BOUND_CHECK_BYTE_ADDRESS(index, sizeof(T), sizeInBytes);\n"
"        return *(const T*)(((const char*)data) + index);\n"
"    }\n"
"\n"
"    void Store(size_t index, uint32_t v) const \n"
"    { \n"
"        SLANG_BOUND_CHECK_BYTE_ADDRESS(index, 4, sizeInBytes);\n"
"        data[index >> 2] = v; \n"
"    }\n"
"    void Store2(size_t index, uint2 v) const \n"
"    { \n"
"        SLANG_BOUND_CHECK_BYTE_ADDRESS(index, 8, sizeInBytes);\n"
"        const size_t dataIdx = index >> 2; \n"
"        data[dataIdx + 0] = v.x;\n"
"        data[dataIdx + 1] = v.y;\n"
"    }\n"
"    void Store3(size_t index, uint3 v) const \n"
"    {  \n"
"        SLANG_BOUND_CHECK_BYTE_ADDRESS(index, 12, sizeInBytes);\n"
"        const size_t dataIdx = index >> 2; \n"
"        data[dataIdx + 0] = v.x;\n"
"        data[dataIdx + 1] = v.y;\n"
"        data[dataIdx + 2] = v.z;\n"
"    }\n"
"    void Store4(size_t index, uint4 v) const \n"
"    { \n"
"        SLANG_BOUND_CHECK_BYTE_ADDRESS(index, 16, sizeInBytes);\n"
"        const size_t dataIdx = index >> 2; \n"
"        data[dataIdx + 0] = v.x;\n"
"        data[dataIdx + 1] = v.y;\n"
"        data[dataIdx + 2] = v.z;\n"
"        data[dataIdx + 3] = v.w;\n"
"    }\n"
"    template<typename T>\n"
"    void Store(size_t index, T const& value) const\n"
"    {\n"
"        SLANG_BOUND_CHECK_BYTE_ADDRESS(index, sizeof(T), sizeInBytes);\n"
"        *(T*)(((char*)data) + index) = value;\n"
"    }\n"
"\n"
"    uint32_t* data;\n"
"    size_t sizeInBytes; //< Must be multiple of 4 \n"
"};\n"
"\n"
"struct ISamplerState;\n"
"struct ISamplerComparisonState;\n"
"\n"
"struct SamplerState\n"
"{\n"
"    ISamplerState* state;\n"
"};\n"
"\n"
"struct SamplerComparisonState\n"
"{\n"
"    ISamplerComparisonState* state;\n"
"};\n"
"\n"
"#ifndef SLANG_RESOURCE_SHAPE\n"
"#    define SLANG_RESOURCE_SHAPE\n"
"typedef unsigned int SlangResourceShape;\n"
"enum\n"
"{\n"
"    SLANG_RESOURCE_BASE_SHAPE_MASK = 0x0F,\n"
"\n"
"    SLANG_RESOURCE_NONE = 0x00,\n"
"\n"
"    SLANG_TEXTURE_1D = 0x01,\n"
"    SLANG_TEXTURE_2D = 0x02,\n"
"    SLANG_TEXTURE_3D = 0x03,\n"
"    SLANG_TEXTURE_CUBE = 0x04,\n"
"    SLANG_TEXTURE_BUFFER = 0x05,\n"
"\n"
"    SLANG_STRUCTURED_BUFFER = 0x06,\n"
"    SLANG_BYTE_ADDRESS_BUFFER = 0x07,\n"
"    SLANG_RESOURCE_UNKNOWN = 0x08,\n"
"    SLANG_ACCELERATION_STRUCTURE = 0x09,\n"
"\n"
"    SLANG_RESOURCE_EXT_SHAPE_MASK = 0xF0,\n"
"\n"
"    SLANG_TEXTURE_FEEDBACK_FLAG = 0x10,\n"
"    SLANG_TEXTURE_ARRAY_FLAG = 0x40,\n"
"    SLANG_TEXTURE_MULTISAMPLE_FLAG = 0x80,\n"
"\n"
"    SLANG_TEXTURE_1D_ARRAY = SLANG_TEXTURE_1D | SLANG_TEXTURE_ARRAY_FLAG,\n"
"    SLANG_TEXTURE_2D_ARRAY = SLANG_TEXTURE_2D | SLANG_TEXTURE_ARRAY_FLAG,\n"
"    SLANG_TEXTURE_CUBE_ARRAY = SLANG_TEXTURE_CUBE | SLANG_TEXTURE_ARRAY_FLAG,\n"
"\n"
"    SLANG_TEXTURE_2D_MULTISAMPLE = SLANG_TEXTURE_2D | SLANG_TEXTURE_MULTISAMPLE_FLAG,\n"
"    SLANG_TEXTURE_2D_MULTISAMPLE_ARRAY =\n"
"        SLANG_TEXTURE_2D | SLANG_TEXTURE_MULTISAMPLE_FLAG | SLANG_TEXTURE_ARRAY_FLAG,\n"
"};\n"
"#endif\n"
"\n"
"// \n"
"struct TextureDimensions\n"
"{\n"
"    void reset()\n"
"    {\n"
"        shape = 0;\n"
"        width = height = depth = 0;\n"
"        numberOfLevels = 0;\n"
"        arrayElementCount = 0;\n"
"    }\n"
"    int getDimSizes(uint32_t outDims[4]) const\n"
"    {\n"
"        const auto baseShape = (shape & SLANG_RESOURCE_BASE_SHAPE_MASK);\n"
"        int count = 0;\n"
"        switch (baseShape)\n"
"        {\n"
"            case SLANG_TEXTURE_1D:\n"
"            {\n"
"                outDims[count++] = width;\n"
"                break;\n"
"            }\n"
"            case SLANG_TEXTURE_2D:\n"
"            {\n"
"                outDims[count++] = width;\n"
"                outDims[count++] = height;\n"
"                break;\n"
"            }\n"
"            case SLANG_TEXTURE_3D:\n"
"            {\n"
"                outDims[count++] = width;\n"
"                outDims[count++] = height;\n"
"                outDims[count++] = depth;\n"
"                break;\n"
"            }\n"
"            case SLANG_TEXTURE_CUBE:\n"
"            {\n"
"                outDims[count++] = width;\n"
"                outDims[count++] = height;\n"
"                outDims[count++] = 6;\n"
"                break;\n"
"            }\n"
"        }\n"
"\n"
"        if (shape & SLANG_TEXTURE_ARRAY_FLAG)\n"
"        {\n"
"            outDims[count++] = arrayElementCount;\n"
"        }\n"
"        return count;\n"
"    }\n"
"    int getMIPDims(int outDims[3]) const\n"
"    {\n"
"        const auto baseShape = (shape & SLANG_RESOURCE_BASE_SHAPE_MASK);\n"
"        int count = 0;\n"
"        switch (baseShape)\n"
"        {\n"
"            case SLANG_TEXTURE_1D:\n"
"            {\n"
"                outDims[count++] = width;\n"
"                break;\n"
"            }\n"
"            case SLANG_TEXTURE_CUBE:\n"
"            case SLANG_TEXTURE_2D:\n"
"            {\n"
"                outDims[count++] = width;\n"
"                outDims[count++] = height;\n"
"                break;\n"
"            }\n"
"            case SLANG_TEXTURE_3D:\n"
"            {\n"
"                outDims[count++] = width;\n"
"                outDims[count++] = height;\n"
"                outDims[count++] = depth;\n"
"                break;\n"
"            }\n"
"        }\n"
"        return count;\n"
"    }\n"
"    int calcMaxMIPLevels() const\n"
"    {\n"
"        int dims[3];\n"
"        const int dimCount = getMIPDims(dims);\n"
"        for (int count = 1; true; count++)\n"
"        {\n"
"            bool allOne = true;\n"
"            for (int i = 0; i < dimCount; ++i)\n"
"            {\n"
"                if (dims[i] > 1)\n"
"                {\n"
"                    allOne = false;\n"
"                    dims[i] >>= 1;\n"
"                }\n"
"            }\n"
"            if (allOne)\n"
"            {\n"
"                return count;\n"
"            }\n"
"        }\n"
"    }\n"
"\n"
"    uint32_t shape;\n"
"    uint32_t width, height, depth;\n"
"    uint32_t numberOfLevels;\n"
"    uint32_t arrayElementCount;                  ///< For array types, 0 otherwise\n"
"};\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"// Texture\n"
"\n"
"struct ITexture\n"
"{\n"
"    virtual TextureDimensions GetDimensions(int mipLevel = -1) = 0;\n"
"    virtual void Load(const int32_t* v, void* outData, size_t dataSize) = 0;\n"
"    virtual void Sample(SamplerState samplerState, const float* loc, void* outData, size_t dataSize) = 0;\n"
"    virtual void SampleLevel(SamplerState samplerState, const float* loc, float level, void* outData, size_t dataSize) = 0;\n"
"};\n"
"\n"
"template <typename T>\n"
"struct Texture1D\n"
"{\n"
"    void GetDimensions(uint32_t* outWidth) { *outWidth = texture->GetDimensions().width; }\n"
"    void GetDimensions(uint32_t mipLevel, uint32_t* outWidth, uint32_t* outNumberOfLevels) \n"
"    { \n"
"        auto dims = texture->GetDimensions(mipLevel); \n"
"        *outWidth = dims.width; \n"
"        *outNumberOfLevels = dims.numberOfLevels; \n"
"    }\n"
"    \n"
"    void GetDimensions(float* outWidth) { *outWidth = texture->GetDimensions().width; }\n"
"    void GetDimensions(uint32_t mipLevel, float* outWidth, float* outNumberOfLevels) \n"
"    { \n"
"        auto dims = texture->GetDimensions(mipLevel); \n"
"        *outWidth = dims.width; \n"
"        *outNumberOfLevels = dims.numberOfLevels; \n"
"    }\n"
"    \n"
"    T Load(const int2& loc) const { T out; texture->Load(&loc.x, &out, sizeof(out)); return out; }\n"
"    T Sample(SamplerState samplerState, float loc) const { T out; texture->Sample(samplerState, &loc, &out, sizeof(out)); return out; }\n"
"    T SampleLevel(SamplerState samplerState, float loc, float level) { T out; texture->SampleLevel(samplerState, &loc, level, &out, sizeof(out)); return out; }\n"
"    \n"
"    ITexture* texture;              \n"
"};\n"
"\n"
"template <typename T>\n"
"struct Texture2D\n"
"{\n"
"    void GetDimensions(uint32_t* outWidth, uint32_t* outHeight) \n"
"    { \n"
"        const auto dims = texture->GetDimensions(); \n"
"        *outWidth = dims.width; \n"
"        *outHeight = dims.height; \n"
"    }\n"
;
sb << 
"    void GetDimensions(uint32_t mipLevel, uint32_t* outWidth, uint32_t* outHeight, uint32_t* outNumberOfLevels)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"    void GetDimensions(float* outWidth, float* outHeight) \n"
"    { \n"
"        const auto dims = texture->GetDimensions(); \n"
"        *outWidth = dims.width; \n"
"        *outHeight = dims.height; \n"
"    }\n"
"    void GetDimensions(uint32_t mipLevel, float* outWidth, float* outHeight, float* outNumberOfLevels)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"    \n"
"    T Load(const int3& loc) const { T out; texture->Load(&loc.x, &out, sizeof(out)); return out; }\n"
"    T Sample(SamplerState samplerState, const float2& loc) const { T out; texture->Sample(samplerState, &loc.x, &out, sizeof(out)); return out; }\n"
"    T SampleLevel(SamplerState samplerState, const float2& loc, float level) { T out; texture->SampleLevel(samplerState, &loc.x, level, &out, sizeof(out)); return out; }\n"
"    \n"
"    ITexture* texture;              \n"
"};\n"
"\n"
"template <typename T>\n"
"struct Texture3D\n"
"{\n"
"    void GetDimensions(uint32_t* outWidth, uint32_t* outHeight, uint32_t* outDepth)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(); \n"
"        *outWidth = dims.width; \n"
"        *outHeight = dims.height; \n"
"        *outDepth = dims.depth;\n"
"    }\n"
"    void GetDimensions(uint32_t mipLevel, uint32_t* outWidth, uint32_t* outHeight, uint32_t* outDepth, uint32_t* outNumberOfLevels)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outDepth = dims.depth;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"    void GetDimensions(float* outWidth, float* outHeight, float* outDepth)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(); \n"
"        *outWidth = dims.width; \n"
"        *outHeight = dims.height; \n"
"        *outDepth = dims.depth;\n"
"    }\n"
"    void GetDimensions(uint32_t mipLevel, float* outWidth, float* outHeight, float* outDepth, float* outNumberOfLevels)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outDepth = dims.depth;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"    \n"
"    T Load(const int4& loc) const { T out; texture->Load(&loc.x, &out, sizeof(out)); return out; }\n"
"    T Sample(SamplerState samplerState, const float3& loc) const { T out; texture->Sample(samplerState, &loc.x, &out, sizeof(out)); return out; }\n"
"    T SampleLevel(SamplerState samplerState, const float3& loc, float level) { T out; texture->SampleLevel(samplerState, &loc.x, level, &out, sizeof(out)); return out; }\n"
"    \n"
"    ITexture* texture;              \n"
"};\n"
"\n"
"template <typename T>\n"
"struct TextureCube\n"
"{\n"
"    void GetDimensions(uint32_t* outWidth, uint32_t* outHeight) \n"
"    { \n"
"        const auto dims = texture->GetDimensions(); \n"
"        *outWidth = dims.width; \n"
"        *outHeight = dims.height; \n"
"    }\n"
"    void GetDimensions(uint32_t mipLevel, uint32_t* outWidth, uint32_t* outHeight, uint32_t* outNumberOfLevels)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"    void GetDimensions(float* outWidth, float* outHeight) \n"
"    { \n"
"        const auto dims = texture->GetDimensions(); \n"
"        *outWidth = dims.width; \n"
"        *outHeight = dims.height; \n"
"    }\n"
"    void GetDimensions(uint32_t mipLevel, float* outWidth, float* outHeight, float* outNumberOfLevels)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"    \n"
"    T Sample(SamplerState samplerState, const float3& loc) const { T out; texture->Sample(samplerState, &loc.x, &out, sizeof(out)); return out; }\n"
"    T SampleLevel(SamplerState samplerState, const float3& loc, float level) { T out; texture->SampleLevel(samplerState, &loc.x, level, &out, sizeof(out)); return out; }\n"
"    \n"
"    ITexture* texture;              \n"
"};\n"
"\n"
"template <typename T>\n"
"struct Texture1DArray\n"
"{\n"
"    void GetDimensions(uint32_t* outWidth, uint32_t* outElements) { auto dims = texture->GetDimensions(); *outWidth = dims.width; *outElements = dims.arrayElementCount; }\n"
"    void GetDimensions(uint32_t mipLevel, uint32_t* outWidth, uint32_t* outElements, uint32_t* outNumberOfLevels) \n"
"    {\n"
"        auto dims = texture->GetDimensions(mipLevel); \n"
"        *outWidth = dims.width; \n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"        *outElements = dims.arrayElementCount; \n"
"    }        \n"
"    void GetDimensions(float* outWidth, float* outElements) { auto dims = texture->GetDimensions(); *outWidth = dims.width; *outElements = dims.arrayElementCount; }\n"
"    void GetDimensions(uint32_t mipLevel, float* outWidth, float* outElements, float* outNumberOfLevels) \n"
"    {\n"
"        auto dims = texture->GetDimensions(mipLevel); \n"
"        *outWidth = dims.width; \n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"        *outElements = dims.arrayElementCount; \n"
"    }\n"
"    \n"
"    T Load(const int3& loc) const { T out; texture->Load(&loc.x, &out, sizeof(out)); return out; }\n"
"    T Sample(SamplerState samplerState, const float2& loc) const { T out; texture->Sample(samplerState, &loc.x, &out, sizeof(out)); return out; }\n"
"    T SampleLevel(SamplerState samplerState, const float2& loc, float level) { T out; texture->SampleLevel(samplerState, &loc.x, level, &out, sizeof(out)); return out; }\n"
"    \n"
"    ITexture* texture;              \n"
"};\n"
"\n"
"template <typename T>\n"
"struct Texture2DArray\n"
"{\n"
"    void GetDimensions(uint32_t* outWidth, uint32_t* outHeight, uint32_t* outElements)\n"
"    {\n"
"        auto dims = texture->GetDimensions();\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outElements = dims.arrayElementCount;\n"
"    }\n"
"    void GetDimensions(uint32_t mipLevel, uint32_t* outWidth, uint32_t* outHeight, uint32_t* outElements, uint32_t* outNumberOfLevels)\n"
"    {\n"
"        auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outElements = dims.arrayElementCount;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"    \n"
"    void GetDimensions(uint32_t* outWidth, float* outHeight, float* outElements)\n"
"    {\n"
"        auto dims = texture->GetDimensions();\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outElements = dims.arrayElementCount;\n"
"    }\n"
"    void GetDimensions(uint32_t mipLevel, float* outWidth, float* outHeight, float* outElements, float* outNumberOfLevels)\n"
"    {\n"
"        auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outElements = dims.arrayElementCount;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"    \n"
"    T Load(const int4& loc) const { T out; texture->Load(&loc.x, &out, sizeof(out)); return out; }\n"
"    T Sample(SamplerState samplerState, const float3& loc) const { T out; texture->Sample(samplerState, &loc.x, &out, sizeof(out)); return out; }\n"
"    T SampleLevel(SamplerState samplerState, const float3& loc, float level) { T out; texture->SampleLevel(samplerState, &loc.x, level, &out, sizeof(out)); return out; }\n"
"    \n"
"    ITexture* texture;              \n"
"};\n"
"\n"
"template <typename T>\n"
"struct TextureCubeArray\n"
"{\n"
"    void GetDimensions(uint32_t* outWidth, uint32_t* outHeight, uint32_t* outElements)\n"
"    {\n"
"        auto dims = texture->GetDimensions();\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outElements = dims.arrayElementCount;\n"
"    }\n"
"    void GetDimensions(uint32_t mipLevel, uint32_t* outWidth, uint32_t* outHeight, uint32_t* outElements, uint32_t* outNumberOfLevels)\n"
"    {\n"
"        auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outElements = dims.arrayElementCount;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"    \n"
"    void GetDimensions(uint32_t* outWidth, float* outHeight, float* outElements)\n"
"    {\n"
"        auto dims = texture->GetDimensions();\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outElements = dims.arrayElementCount;\n"
"    }\n"
"    void GetDimensions(uint32_t mipLevel, float* outWidth, float* outHeight, float* outElements, float* outNumberOfLevels)\n"
"    {\n"
"        auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outElements = dims.arrayElementCount;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"    \n"
"    T Sample(SamplerState samplerState, const float4& loc) const { T out; texture->Sample(samplerState, &loc.x, &out, sizeof(out)); return out; }\n"
"    T SampleLevel(SamplerState samplerState, const float4& loc, float level) { T out; texture->SampleLevel(samplerState, &loc.x, level, &out, sizeof(out)); return out; }\n"
"    \n"
"    ITexture* texture;              \n"
"};\n"
"\n"
"/* !!!!!!!!!!!!!!!!!!!!!!!!!!! RWTexture !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! */\n"
"\n"
"struct IRWTexture : ITexture\n"
"{\n"
"        /// Get the reference to the element at loc. \n"
"    virtual void* refAt(const uint32_t* loc) = 0;\n"
"};\n"
"\n"
"template <typename T>\n"
"struct RWTexture1D\n"
"{\n"
"    void GetDimensions(uint32_t* outWidth) { *outWidth = texture->GetDimensions().width; }\n"
"    void GetDimensions(uint32_t mipLevel, uint32_t* outWidth, uint32_t* outNumberOfLevels) { auto dims = texture->GetDimensions(mipLevel); *outWidth = dims.width; *outNumberOfLevels = dims.numberOfLevels; }\n"
"    \n"
"    void GetDimensions(float* outWidth) { *outWidth = texture->GetDimensions().width; }\n"
"    void GetDimensions(uint32_t mipLevel, float* outWidth, float* outNumberOfLevels) { auto dims = texture->GetDimensions(mipLevel); *outWidth = dims.width; *outNumberOfLevels = dims.numberOfLevels; }\n"
"    \n"
"    T Load(int32_t loc) const { T out; texture->Load(&loc, &out, sizeof(out)); return out; }\n"
"    T& operator[](uint32_t loc) { return *(T*)texture->refAt(&loc); }\n"
"    IRWTexture* texture;              \n"
"};\n"
"\n"
"template <typename T>\n"
"struct RWTexture2D\n"
"{\n"
"    void GetDimensions(uint32_t* outWidth, uint32_t* outHeight) \n"
"    { \n"
"        const auto dims = texture->GetDimensions(); \n"
"        *outWidth = dims.width; \n"
"        *outHeight = dims.height; \n"
"    }\n"
"    void GetDimensions(uint32_t mipLevel, uint32_t* outWidth, uint32_t* outHeight, uint32_t* outNumberOfLevels)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"    void GetDimensions(float* outWidth, float* outHeight) \n"
"    { \n"
"        const auto dims = texture->GetDimensions(); \n"
"        *outWidth = dims.width; \n"
"        *outHeight = dims.height; \n"
"    }\n"
"    void GetDimensions(uint32_t mipLevel, float* outWidth, float* outHeight, float* outNumberOfLevels)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"    \n"
"    T Load(const int2& loc) const { T out; texture->Load(&loc.x, &out, sizeof(out)); return out; }\n"
"    T& operator[](const uint2& loc) { return *(T*)texture->refAt(&loc.x); }\n"
"    IRWTexture* texture;\n"
"};\n"
"\n"
"template <typename T>\n"
"struct RWTexture3D\n"
"{\n"
"    void GetDimensions(uint32_t* outWidth, uint32_t* outHeight, uint32_t* outDepth)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(); \n"
"        *outWidth = dims.width; \n"
"        *outHeight = dims.height; \n"
"        *outDepth = dims.depth;\n"
"    }\n"
"    void GetDimensions(uint32_t mipLevel, uint32_t* outWidth, uint32_t* outHeight, uint32_t* outDepth, uint32_t* outNumberOfLevels)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outDepth = dims.depth;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"    void GetDimensions(float* outWidth, float* outHeight, float* outDepth)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(); \n"
"        *outWidth = dims.width; \n"
"        *outHeight = dims.height; \n"
"        *outDepth = dims.depth;\n"
"    }\n"
"    void GetDimensions(uint32_t mipLevel, float* outWidth, float* outHeight, float* outDepth, float* outNumberOfLevels)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outDepth = dims.depth;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"    \n"
"    T Load(const int3& loc) const { T out; texture->Load(&loc.x, &out, sizeof(out)); return out; }\n"
"    T& operator[](const uint3& loc) { return *(T*)texture->refAt(&loc.x); }\n"
"    IRWTexture* texture;\n"
"};\n"
"\n"
"\n"
"template <typename T>\n"
"struct RWTexture1DArray\n"
"{\n"
"    void GetDimensions(uint32_t* outWidth, uint32_t* outElements) \n"
"    { \n"
"        auto dims = texture->GetDimensions(); \n"
"        *outWidth = dims.width; \n"
"        *outElements = dims.arrayElementCount; \n"
"    }\n"
"    void GetDimensions(uint32_t mipLevel, uint32_t* outWidth, uint32_t* outElements, uint32_t* outNumberOfLevels)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outElements = dims.arrayElementCount;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"    void GetDimensions(float* outWidth, float* outElements) \n"
"    { \n"
"        auto dims = texture->GetDimensions(); \n"
"        *outWidth = dims.width; \n"
"        *outElements = dims.arrayElementCount; \n"
"    }\n"
"    void GetDimensions(uint32_t mipLevel, float* outWidth, float* outElements, float* outNumberOfLevels)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outElements = dims.arrayElementCount;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"    \n"
"    T Load(int2 loc) const { T out; texture->Load(&loc.x, &out, sizeof(out)); return out; }\n"
"    T& operator[](uint2 loc) { return *(T*)texture->refAt(&loc.x); }\n"
"\n"
"    IRWTexture* texture;\n"
"};\n"
"\n"
"template <typename T>\n"
"struct RWTexture2DArray\n"
"{\n"
"    void GetDimensions(uint32_t* outWidth, uint32_t* outHeight, uint32_t* outElements)\n"
"    {\n"
"        auto dims = texture->GetDimensions(); \n"
"        *outWidth = dims.width; \n"
"        *outHeight = dims.height;\n"
"        *outElements = dims.arrayElementCount; \n"
"    }\n"
"    void GetDimensions(uint32_t mipLevel, uint32_t* outWidth, uint32_t* outHeight, uint32_t* outElements, uint32_t* outNumberOfLevels)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outElements = dims.arrayElementCount;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"    void GetDimensions(float* outWidth, float* outHeight, float* outElements)\n"
"    {\n"
"        auto dims = texture->GetDimensions(); \n"
"        *outWidth = dims.width; \n"
"        *outHeight = dims.height;\n"
"        *outElements = dims.arrayElementCount; \n"
"    }\n"
"    void GetDimensions(uint32_t mipLevel, float* outWidth, float* outHeight, float* outElements, float* outNumberOfLevels)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outElements = dims.arrayElementCount;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"    \n"
"    T Load(const int3& loc) const { T out; texture->Load(&loc.x, &out, sizeof(out)); return out; }\n"
"    T& operator[](const uint3& loc) { return *(T*)texture->refAt(&loc.x); }\n"
"\n"
"    IRWTexture* texture;\n"
"};\n"
"\n"
"// FeedbackTexture\n"
"\n"
"struct FeedbackType {};\n"
"struct SAMPLER_FEEDBACK_MIN_MIP : FeedbackType {};\n"
"struct SAMPLER_FEEDBACK_MIP_REGION_USED : FeedbackType {};\n"
"\n"
"struct IFeedbackTexture\n"
"{\n"
"    virtual TextureDimensions GetDimensions(int mipLevel = -1) = 0;\n"
"\n"
"    // Note here we pass the optional clamp parameter as a pointer. Passing nullptr means no clamp. \n"
"    // This was preferred over having two function definitions, and having to differentiate their names\n"
"    virtual void WriteSamplerFeedback(ITexture* tex, SamplerState samp, const float* location, const float* clamp = nullptr) = 0;\n"
"    virtual void WriteSamplerFeedbackBias(ITexture* tex, SamplerState samp, const float* location, float bias, const float* clamp = nullptr) = 0;\n"
"    virtual void WriteSamplerFeedbackGrad(ITexture* tex, SamplerState samp, const float* location, const float* ddx, const float* ddy, const float* clamp = nullptr) = 0;\n"
"    \n"
"    virtual void WriteSamplerFeedbackLevel(ITexture* tex, SamplerState samp, const float* location, float lod) = 0;\n"
"};\n"
"\n"
"template <typename T>\n"
"struct FeedbackTexture2D\n"
"{\n"
;
sb << 
"    void GetDimensions(uint32_t* outWidth, uint32_t* outHeight) \n"
"    { \n"
"        const auto dims = texture->GetDimensions(); \n"
"        *outWidth = dims.width; \n"
"        *outHeight = dims.height; \n"
"    }\n"
"    void GetDimensions(uint32_t mipLevel, uint32_t* outWidth, uint32_t* outHeight, uint32_t* outNumberOfLevels)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"    void GetDimensions(float* outWidth, float* outHeight) \n"
"    { \n"
"        const auto dims = texture->GetDimensions(); \n"
"        *outWidth = dims.width; \n"
"        *outHeight = dims.height; \n"
"    }\n"
"    void GetDimensions(uint32_t mipLevel, float* outWidth, float* outHeight, float* outNumberOfLevels)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"    \n"
"    template <typename S>\n"
"    void WriteSamplerFeedback(Texture2D<S> tex, SamplerState samp, float2 location, float clamp) { texture->WriteSamplerFeedback(tex.texture, samp, &location.x, &clamp); } \n"
"\n"
"    template <typename S>\n"
"    void WriteSamplerFeedbackBias(Texture2D<S> tex, SamplerState samp, float2 location, float bias, float clamp) { texture->WriteSamplerFeedbackBias(tex.texture, samp, &location.x, bias, &clamp); }\n"
"\n"
"    template <typename S>\n"
"    void WriteSamplerFeedbackGrad(Texture2D<S> tex, SamplerState samp, float2 location, float2 ddx, float2 ddy, float clamp) { texture->WriteSamplerFeedbackGrad(tex.texture, samp, &location.x, &ddx.x, &ddy.x, &clamp); }\n"
"\n"
"    // Level\n"
"\n"
"    template <typename S> \n"
"    void WriteSamplerFeedbackLevel(Texture2D<S> tex, SamplerState samp, float2 location, float lod) { texture->WriteSamplerFeedbackLevel(tex.texture, samp, &location.x, lod); }\n"
"    \n"
"    // Without Clamp\n"
"    template <typename S> \n"
"    void WriteSamplerFeedback(Texture2D<S> tex, SamplerState samp, float2 location) { texture->WriteSamplerFeedback(tex.texture, samp, &location.x); }\n"
"\n"
"    template <typename S> \n"
"    void WriteSamplerFeedbackBias(Texture2D<S> tex, SamplerState samp, float2 location, float bias) { texture->WriteSamplerFeedbackBias(tex.texture, samp, &location.x, bias); }\n"
"\n"
"    template <typename S> \n"
"    void WriteSamplerFeedbackGrad(Texture2D<S> tex, SamplerState samp, float2 location, float2 ddx, float2 ddy) { texture->WriteSamplerFeedbackGrad(tex.texture, samp, &location.x, &ddx.x, &ddy.x); }\n"
"    \n"
"    IFeedbackTexture* texture;\n"
"};\n"
"\n"
"template <typename T>\n"
"struct FeedbackTexture2DArray\n"
"{\n"
"    void GetDimensions(uint32_t* outWidth, uint32_t* outHeight, uint32_t* outElements)\n"
"    {\n"
"        auto dims = texture->GetDimensions(); \n"
"        *outWidth = dims.width; \n"
"        *outHeight = dims.height;\n"
"        *outElements = dims.arrayElementCount; \n"
"    }\n"
"    void GetDimensions(uint32_t mipLevel, uint32_t* outWidth, uint32_t* outHeight, uint32_t* outElements, uint32_t* outNumberOfLevels)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outElements = dims.arrayElementCount;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"    void GetDimensions(float* outWidth, float* outHeight, float* outElements)\n"
"    {\n"
"        auto dims = texture->GetDimensions(); \n"
"        *outWidth = dims.width; \n"
"        *outHeight = dims.height;\n"
"        *outElements = dims.arrayElementCount; \n"
"    }\n"
"    void GetDimensions(uint32_t mipLevel, float* outWidth, float* outHeight, float* outElements, float* outNumberOfLevels)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outElements = dims.arrayElementCount;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"    \n"
"    template <typename S>\n"
"    void WriteSamplerFeedback(Texture2DArray<S> texArray, SamplerState samp, float3 location, float clamp) { texture->WriteSamplerFeedback(texArray.texture, samp, &location.x, &clamp); }\n"
"\n"
"    template <typename S>\n"
"    void WriteSamplerFeedbackBias(Texture2DArray<S> texArray, SamplerState samp, float3 location, float bias, float clamp) { texture->WriteSamplerFeedbackBias(texArray.texture, samp, &location.x, bias, &clamp); }\n"
"\n"
"    template <typename S>\n"
"    void WriteSamplerFeedbackGrad(Texture2DArray<S> texArray, SamplerState samp, float3 location, float3 ddx, float3 ddy, float clamp) { texture->WriteSamplerFeedbackGrad(texArray.texture, samp, &location.x, &ddx.x, &ddy.x, &clamp); }\n"
"\n"
"    // Level\n"
"    template <typename S>\n"
"    void WriteSamplerFeedbackLevel(Texture2DArray<S> texArray, SamplerState samp, float3 location, float lod) { texture->WriteSamplerFeedbackLevel(texArray.texture, samp, &location.x, lod); }\n"
"\n"
"    // Without Clamp\n"
"\n"
"    template <typename S>\n"
"    void WriteSamplerFeedback(Texture2DArray<S> texArray, SamplerState samp, float3 location) { texture->WriteSamplerFeedback(texArray.texture, samp, &location.x); }\n"
"\n"
"    template <typename S>\n"
"    void WriteSamplerFeedbackBias(Texture2DArray<S> texArray, SamplerState samp, float3 location, float bias) { texture->WriteSamplerFeedbackBias(texArray.texture, samp, &location.x, bias); }\n"
"\n"
"    template <typename S>\n"
"    void WriteSamplerFeedbackGrad(Texture2DArray<S> texArray, SamplerState samp, float3 location, float3 ddx, float3 ddy) { texture->WriteSamplerFeedbackGrad(texArray.texture, samp, &location.x, &ddx.x, &ddy.x); }\n"
"    \n"
"    IFeedbackTexture* texture;\n"
"};\n"
"\n"
"/* Varying input for Compute */\n"
"\n"
"/* Used when running a single thread */\n"
"struct ComputeThreadVaryingInput\n"
"{\n"
"    uint3 groupID;\n"
"    uint3 groupThreadID;\n"
"};\n"
"\n"
"struct ComputeVaryingInput\n"
"{\n"
"    uint3 startGroupID;     ///< start groupID\n"
"    uint3 endGroupID;       ///< Non inclusive end groupID\n"
"};\n"
"\n"
"// The uniformEntryPointParams and uniformState must be set to structures that match layout that the kernel expects.\n"
"// This can be determined via reflection for example.\n"
"\n"
"typedef void(*ComputeThreadFunc)(ComputeThreadVaryingInput* varyingInput, void* uniformEntryPointParams, void* uniformState);\n"
"typedef void(*ComputeFunc)(ComputeVaryingInput* varyingInput, void* uniformEntryPointParams, void* uniformState);\n"
"\n"
"#ifdef SLANG_PRELUDE_NAMESPACE\n"
"}\n"
"#endif\n"
"\n"
"#endif\n"
"\n"
"\n"
"\n"
"\n"
"// TODO(JS): Hack! Output C++ code from slang can copy uninitialized variables. \n"
"#if defined(_MSC_VER)\n"
"#   pragma warning(disable : 4700)\n"
"#endif\n"
"\n"
"#ifndef SLANG_UNROLL\n"
"#   define SLANG_UNROLL\n"
"#endif\n"
"\n"
"#endif\n"
"\n"
;
return sb.produceString();
}
